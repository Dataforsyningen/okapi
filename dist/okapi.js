var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/proj4/dist/proj4.js
var require_proj4 = __commonJS({
  "node_modules/proj4/dist/proj4.js"(exports, module) {
    !function(t, s) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = s() : "function" == typeof define && define.amd ? define(s) : t.proj4 = s();
    }(exports, function() {
      "use strict";
      function t(t2, s2) {
        if (t2[s2])
          return t2[s2];
        for (var i2, a2 = Object.keys(t2), h2 = s2.toLowerCase().replace(Ot, ""), e2 = -1; ++e2 < a2.length; )
          if (i2 = a2[e2], i2.toLowerCase().replace(Ot, "") === h2)
            return t2[i2];
      }
      function s(t2) {
        if ("string" != typeof t2)
          throw new Error("not a string");
        this.text = t2.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = qt;
      }
      function i(t2) {
        return new s(t2).output();
      }
      function a(t2, s2, i2) {
        Array.isArray(s2) && (i2.unshift(s2), s2 = null);
        var a2 = s2 ? {} : t2, e2 = i2.reduce(function(t3, s3) {
          return h(s3, t3), t3;
        }, a2);
        s2 && (t2[s2] = e2);
      }
      function h(t2, s2) {
        if (Array.isArray(t2)) {
          var i2 = t2.shift();
          if ("PARAMETER" === i2 && (i2 = t2.shift()), 1 === t2.length)
            return Array.isArray(t2[0]) ? (s2[i2] = {}, void h(t2[0], s2[i2])) : void (s2[i2] = t2[0]);
          if (t2.length)
            if ("TOWGS84" !== i2) {
              if ("AXIS" === i2)
                return i2 in s2 || (s2[i2] = []), void s2[i2].push(t2);
              Array.isArray(i2) || (s2[i2] = {});
              var e2;
              switch (i2) {
                case "UNIT":
                case "PRIMEM":
                case "VERT_DATUM":
                  return s2[i2] = { name: t2[0].toLowerCase(), convert: t2[1] }, void (3 === t2.length && h(t2[2], s2[i2]));
                case "SPHEROID":
                case "ELLIPSOID":
                  return s2[i2] = { name: t2[0], a: t2[1], rf: t2[2] }, void (4 === t2.length && h(t2[3], s2[i2]));
                case "PROJECTEDCRS":
                case "PROJCRS":
                case "GEOGCS":
                case "GEOCCS":
                case "PROJCS":
                case "LOCAL_CS":
                case "GEODCRS":
                case "GEODETICCRS":
                case "GEODETICDATUM":
                case "EDATUM":
                case "ENGINEERINGDATUM":
                case "VERT_CS":
                case "VERTCRS":
                case "VERTICALCRS":
                case "COMPD_CS":
                case "COMPOUNDCRS":
                case "ENGINEERINGCRS":
                case "ENGCRS":
                case "FITTED_CS":
                case "LOCAL_DATUM":
                case "DATUM":
                  return t2[0] = ["name", t2[0]], void a(s2, i2, t2);
                default:
                  for (e2 = -1; ++e2 < t2.length; )
                    if (!Array.isArray(t2[e2]))
                      return h(t2, s2[i2]);
                  return a(s2, i2, t2);
              }
            } else
              s2[i2] = t2;
          else
            s2[i2] = true;
        } else
          s2[t2] = true;
      }
      function e(t2, s2) {
        var i2 = s2[0], a2 = s2[1];
        !(i2 in t2) && a2 in t2 && (t2[i2] = t2[a2], 3 === s2.length && (t2[i2] = s2[2](t2[i2])));
      }
      function n(t2) {
        return t2 * Bt;
      }
      function r(t2) {
        function s2(s3) {
          return s3 * (t2.to_meter || 1);
        }
        if ("GEOGCS" === t2.type ? t2.projName = "longlat" : "LOCAL_CS" === t2.type ? (t2.projName = "identity", t2.local = true) : "object" == typeof t2.PROJECTION ? t2.projName = Object.keys(t2.PROJECTION)[0] : t2.projName = t2.PROJECTION, t2.AXIS) {
          for (var i2 = "", a2 = 0, h2 = t2.AXIS.length; a2 < h2; ++a2) {
            var r2 = [t2.AXIS[a2][0].toLowerCase(), t2.AXIS[a2][1].toLowerCase()];
            -1 !== r2[0].indexOf("north") || ("y" === r2[0] || "lat" === r2[0]) && "north" === r2[1] ? i2 += "n" : -1 !== r2[0].indexOf("south") || ("y" === r2[0] || "lat" === r2[0]) && "south" === r2[1] ? i2 += "s" : -1 !== r2[0].indexOf("east") || ("x" === r2[0] || "lon" === r2[0]) && "east" === r2[1] ? i2 += "e" : -1 === r2[0].indexOf("west") && ("x" !== r2[0] && "lon" !== r2[0] || "west" !== r2[1]) || (i2 += "w");
          }
          2 === i2.length && (i2 += "u"), 3 === i2.length && (t2.axis = i2);
        }
        t2.UNIT && (t2.units = t2.UNIT.name.toLowerCase(), "metre" === t2.units && (t2.units = "meter"), t2.UNIT.convert && ("GEOGCS" === t2.type ? t2.DATUM && t2.DATUM.SPHEROID && (t2.to_meter = t2.UNIT.convert * t2.DATUM.SPHEROID.a) : t2.to_meter = t2.UNIT.convert));
        var o2 = t2.GEOGCS;
        "GEOGCS" === t2.type && (o2 = t2), o2 && (o2.DATUM ? t2.datumCode = o2.DATUM.name.toLowerCase() : t2.datumCode = o2.name.toLowerCase(), "d_" === t2.datumCode.slice(0, 2) && (t2.datumCode = t2.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t2.datumCode && "new_zealand_1949" !== t2.datumCode || (t2.datumCode = "nzgd49"), "wgs_1984" !== t2.datumCode && "world_geodetic_system_1984" !== t2.datumCode || ("Mercator_Auxiliary_Sphere" === t2.PROJECTION && (t2.sphere = true), t2.datumCode = "wgs84"), "_ferro" === t2.datumCode.slice(-6) && (t2.datumCode = t2.datumCode.slice(0, -6)), "_jakarta" === t2.datumCode.slice(-8) && (t2.datumCode = t2.datumCode.slice(0, -8)), ~t2.datumCode.indexOf("belge") && (t2.datumCode = "rnb72"), o2.DATUM && o2.DATUM.SPHEROID && (t2.ellps = o2.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t2.ellps.toLowerCase().slice(0, 13) && (t2.ellps = "intl"), t2.a = o2.DATUM.SPHEROID.a, t2.rf = parseFloat(o2.DATUM.SPHEROID.rf, 10)), o2.DATUM && o2.DATUM.TOWGS84 && (t2.datum_params = o2.DATUM.TOWGS84), ~t2.datumCode.indexOf("osgb_1936") && (t2.datumCode = "osgb36"), ~t2.datumCode.indexOf("osni_1952") && (t2.datumCode = "osni52"), (~t2.datumCode.indexOf("tm65") || ~t2.datumCode.indexOf("geodetic_datum_of_1965")) && (t2.datumCode = "ire65"), "ch1903+" === t2.datumCode && (t2.datumCode = "ch1903"), ~t2.datumCode.indexOf("israel") && (t2.datumCode = "isr93")), t2.b && !isFinite(t2.b) && (t2.b = t2.a);
        [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", n], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", n], ["x0", "false_easting", s2], ["y0", "false_northing", s2], ["long0", "central_meridian", n], ["lat0", "latitude_of_origin", n], ["lat0", "standard_parallel_1", n], ["lat1", "standard_parallel_1", n], ["lat2", "standard_parallel_2", n], ["azimuth", "Azimuth"], ["alpha", "azimuth", n], ["srsCode", "name"]].forEach(function(s3) {
          return e(t2, s3);
        }), t2.long0 || !t2.longc || "Albers_Conic_Equal_Area" !== t2.projName && "Lambert_Azimuthal_Equal_Area" !== t2.projName || (t2.long0 = t2.longc), t2.lat_ts || !t2.lat1 || "Stereographic_South_Pole" !== t2.projName && "Polar Stereographic (variant B)" !== t2.projName ? !t2.lat_ts && t2.lat0 && "Polar_Stereographic" === t2.projName && (t2.lat_ts = t2.lat0, t2.lat0 = n(t2.lat0 > 0 ? 90 : -90)) : (t2.lat0 = n(t2.lat1 > 0 ? 90 : -90), t2.lat_ts = t2.lat1);
      }
      function o(t2) {
        var s2 = this;
        if (2 === arguments.length) {
          var i2 = arguments[1];
          "string" == typeof i2 ? "+" === i2.charAt(0) ? o[t2] = kt(arguments[1]) : o[t2] = zt(arguments[1]) : o[t2] = i2;
        } else if (1 === arguments.length) {
          if (Array.isArray(t2))
            return t2.map(function(t3) {
              Array.isArray(t3) ? o.apply(s2, t3) : o(t3);
            });
          if ("string" == typeof t2) {
            if (t2 in o)
              return o[t2];
          } else
            "EPSG" in t2 ? o["EPSG:" + t2.EPSG] = t2 : "ESRI" in t2 ? o["ESRI:" + t2.ESRI] = t2 : "IAU2000" in t2 ? o["IAU2000:" + t2.IAU2000] = t2 : console.log(t2);
          return;
        }
      }
      function l(t2) {
        return "string" == typeof t2;
      }
      function u(t2) {
        return t2 in o;
      }
      function c(t2) {
        return Ft.some(function(s2) {
          return t2.indexOf(s2) > -1;
        });
      }
      function M(s2) {
        var i2 = t(s2, "authority");
        if (i2) {
          var a2 = t(i2, "epsg");
          return a2 && Dt.indexOf(a2) > -1;
        }
      }
      function f(s2) {
        var i2 = t(s2, "extension");
        if (i2)
          return t(i2, "proj4");
      }
      function d(t2) {
        return "+" === t2[0];
      }
      function p(t2) {
        if (!l(t2))
          return t2;
        if (u(t2))
          return o[t2];
        if (c(t2)) {
          var s2 = zt(t2);
          if (M(s2))
            return o["EPSG:3857"];
          var i2 = f(s2);
          return i2 ? kt(i2) : s2;
        }
        return d(t2) ? kt(t2) : void 0;
      }
      function m(t2) {
        return t2;
      }
      function _(t2, s2) {
        var i2 = Zt.length;
        return t2.names ? (Zt[i2] = t2, t2.names.forEach(function(t3) {
          Vt[t3.toLowerCase()] = i2;
        }), this) : (console.log(s2), true);
      }
      function y(t2, s2, i2, a2) {
        var h2 = t2 * t2, e2 = s2 * s2, n2 = (h2 - e2) / h2, r2 = 0;
        return a2 ? (h2 = (t2 *= 1 - n2 * (gt + n2 * (vt + n2 * bt))) * t2, n2 = 0) : r2 = Math.sqrt(n2), { es: n2, e: r2, ep2: (h2 - e2) / e2 };
      }
      function x(s2, i2, a2, h2, e2) {
        if (!s2) {
          var n2 = t($t, h2);
          n2 || (n2 = ts), s2 = n2.a, i2 = n2.b, a2 = n2.rf;
        }
        return a2 && !i2 && (i2 = (1 - 1 / a2) * s2), (0 === a2 || Math.abs(s2 - i2) < wt) && (e2 = true, i2 = s2), { a: s2, b: i2, rf: a2, sphere: e2 };
      }
      function g(t2, s2, i2, a2, h2, e2, n2) {
        var r2 = {};
        return r2.datum_type = void 0 === t2 || "none" === t2 ? _t : mt, s2 && (r2.datum_params = s2.map(parseFloat), 0 === r2.datum_params[0] && 0 === r2.datum_params[1] && 0 === r2.datum_params[2] || (r2.datum_type = ft), r2.datum_params.length > 3 && (0 === r2.datum_params[3] && 0 === r2.datum_params[4] && 0 === r2.datum_params[5] && 0 === r2.datum_params[6] || (r2.datum_type = dt, r2.datum_params[3] *= yt, r2.datum_params[4] *= yt, r2.datum_params[5] *= yt, r2.datum_params[6] = r2.datum_params[6] / 1e6 + 1))), n2 && (r2.datum_type = pt, r2.grids = n2), r2.a = i2, r2.b = a2, r2.es = h2, r2.ep2 = e2, r2;
      }
      function v(t2) {
        return void 0 === t2 ? null : t2.split(",").map(b);
      }
      function b(t2) {
        if (0 === t2.length)
          return null;
        var s2 = "@" === t2[0];
        return s2 && (t2 = t2.slice(1)), "null" === t2 ? { name: "null", mandatory: !s2, grid: null, isNull: true } : { name: t2, mandatory: !s2, grid: is[t2] || null, isNull: false };
      }
      function w(t2) {
        return t2 / 3600 * Math.PI / 180;
      }
      function N(t2) {
        var s2 = t2.getInt32(8, false);
        return 11 !== s2 && (11 !== (s2 = t2.getInt32(8, true)) && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), true);
      }
      function A(t2, s2) {
        return { nFields: t2.getInt32(8, s2), nSubgridFields: t2.getInt32(24, s2), nSubgrids: t2.getInt32(40, s2), shiftType: E(t2, 56, 64).trim(), fromSemiMajorAxis: t2.getFloat64(120, s2), fromSemiMinorAxis: t2.getFloat64(136, s2), toSemiMajorAxis: t2.getFloat64(152, s2), toSemiMinorAxis: t2.getFloat64(168, s2) };
      }
      function E(t2, s2, i2) {
        return String.fromCharCode.apply(null, new Uint8Array(t2.buffer.slice(s2, i2)));
      }
      function C(t2, s2, i2) {
        for (var a2 = 176, h2 = [], e2 = 0; e2 < s2.nSubgrids; e2++) {
          var n2 = S(t2, a2, i2), r2 = I(t2, a2, n2, i2), o2 = Math.round(1 + (n2.upperLongitude - n2.lowerLongitude) / n2.longitudeInterval), l2 = Math.round(1 + (n2.upperLatitude - n2.lowerLatitude) / n2.latitudeInterval);
          h2.push({ ll: [w(n2.lowerLongitude), w(n2.lowerLatitude)], del: [w(n2.longitudeInterval), w(n2.latitudeInterval)], lim: [o2, l2], count: n2.gridNodeCount, cvs: P(r2) }), a2 += 176 + 16 * n2.gridNodeCount;
        }
        return h2;
      }
      function P(t2) {
        return t2.map(function(t3) {
          return [w(t3.longitudeShift), w(t3.latitudeShift)];
        });
      }
      function S(t2, s2, i2) {
        return { name: E(t2, s2 + 8, s2 + 16).trim(), parent: E(t2, s2 + 24, s2 + 24 + 8).trim(), lowerLatitude: t2.getFloat64(s2 + 72, i2), upperLatitude: t2.getFloat64(s2 + 88, i2), lowerLongitude: t2.getFloat64(s2 + 104, i2), upperLongitude: t2.getFloat64(s2 + 120, i2), latitudeInterval: t2.getFloat64(s2 + 136, i2), longitudeInterval: t2.getFloat64(s2 + 152, i2), gridNodeCount: t2.getInt32(s2 + 168, i2) };
      }
      function I(t2, s2, i2, a2) {
        for (var h2 = s2 + 176, e2 = [], n2 = 0; n2 < i2.gridNodeCount; n2++) {
          var r2 = { latitudeShift: t2.getFloat32(h2 + 16 * n2, a2), longitudeShift: t2.getFloat32(h2 + 16 * n2 + 4, a2), latitudeAccuracy: t2.getFloat32(h2 + 16 * n2 + 8, a2), longitudeAccuracy: t2.getFloat32(h2 + 16 * n2 + 12, a2) };
          e2.push(r2);
        }
        return e2;
      }
      function Projection2(s2, i2) {
        if (!(this instanceof Projection2))
          return new Projection2(s2);
        i2 = i2 || function(t2) {
          if (t2)
            throw t2;
        };
        var a2 = p(s2);
        if ("object" == typeof a2) {
          var h2 = Projection2.projections.get(a2.projName);
          if (h2) {
            if (a2.datumCode && "none" !== a2.datumCode) {
              var e2 = t(ss, a2.datumCode);
              e2 && (a2.datum_params = a2.datum_params || (e2.towgs84 ? e2.towgs84.split(",") : null), a2.ellps = e2.ellipse, a2.datumName = e2.datumName ? e2.datumName : a2.datumCode);
            }
            a2.k0 = a2.k0 || 1, a2.axis = a2.axis || "enu", a2.ellps = a2.ellps || "wgs84", a2.lat1 = a2.lat1 || a2.lat0;
            var n2 = x(a2.a, a2.b, a2.rf, a2.ellps, a2.sphere), r2 = y(n2.a, n2.b, n2.rf, a2.R_A), o2 = v(a2.nadgrids), l2 = a2.datum || g(a2.datumCode, a2.datum_params, n2.a, n2.b, r2.es, r2.ep2, o2);
            Ut(this, a2), Ut(this, h2), this.a = n2.a, this.b = n2.b, this.rf = n2.rf, this.sphere = n2.sphere, this.es = r2.es, this.e = r2.e, this.ep2 = r2.ep2, this.datum = l2, this.init(), i2(null, this);
          } else
            i2(s2);
        } else
          i2(s2);
      }
      function O(t2, s2) {
        return t2.datum_type === s2.datum_type && (!(t2.a !== s2.a || Math.abs(t2.es - s2.es) > 5e-11) && (t2.datum_type === ft ? t2.datum_params[0] === s2.datum_params[0] && t2.datum_params[1] === s2.datum_params[1] && t2.datum_params[2] === s2.datum_params[2] : t2.datum_type !== dt || t2.datum_params[0] === s2.datum_params[0] && t2.datum_params[1] === s2.datum_params[1] && t2.datum_params[2] === s2.datum_params[2] && t2.datum_params[3] === s2.datum_params[3] && t2.datum_params[4] === s2.datum_params[4] && t2.datum_params[5] === s2.datum_params[5] && t2.datum_params[6] === s2.datum_params[6]));
      }
      function k(t2, s2, i2) {
        var a2, h2, e2, n2, r2 = t2.x, o2 = t2.y, l2 = t2.z ? t2.z : 0;
        if (o2 < -xt && o2 > -1.001 * xt)
          o2 = -xt;
        else if (o2 > xt && o2 < 1.001 * xt)
          o2 = xt;
        else {
          if (o2 < -xt)
            return { x: -1 / 0, y: -1 / 0, z: t2.z };
          if (o2 > xt)
            return { x: 1 / 0, y: 1 / 0, z: t2.z };
        }
        return r2 > Math.PI && (r2 -= 2 * Math.PI), h2 = Math.sin(o2), n2 = Math.cos(o2), e2 = h2 * h2, a2 = i2 / Math.sqrt(1 - s2 * e2), { x: (a2 + l2) * n2 * Math.cos(r2), y: (a2 + l2) * n2 * Math.sin(r2), z: (a2 * (1 - s2) + l2) * h2 };
      }
      function q(t2, s2, i2, a2) {
        var h2, e2, n2, r2, o2, l2, u2, c2, M2, f2, d2, p5, m2, _2, y2, x2, g2 = t2.x, v2 = t2.y, b2 = t2.z ? t2.z : 0;
        if (h2 = Math.sqrt(g2 * g2 + v2 * v2), e2 = Math.sqrt(g2 * g2 + v2 * v2 + b2 * b2), h2 / i2 < 1e-12) {
          if (_2 = 0, e2 / i2 < 1e-12)
            return y2 = xt, x2 = -a2, { x: t2.x, y: t2.y, z: t2.z };
        } else
          _2 = Math.atan2(v2, g2);
        n2 = b2 / e2, c2 = (r2 = h2 / e2) * (1 - s2) * (o2 = 1 / Math.sqrt(1 - s2 * (2 - s2) * r2 * r2)), M2 = n2 * o2, m2 = 0;
        do {
          m2++, l2 = s2 * (u2 = i2 / Math.sqrt(1 - s2 * M2 * M2)) / (u2 + (x2 = h2 * c2 + b2 * M2 - u2 * (1 - s2 * M2 * M2))), p5 = (d2 = n2 * (o2 = 1 / Math.sqrt(1 - l2 * (2 - l2) * r2 * r2))) * c2 - (f2 = r2 * (1 - l2) * o2) * M2, c2 = f2, M2 = d2;
        } while (p5 * p5 > 1e-24 && m2 < 30);
        return y2 = Math.atan(d2 / Math.abs(f2)), { x: _2, y: y2, z: x2 };
      }
      function R(t2, s2, i2) {
        if (s2 === ft)
          return { x: t2.x + i2[0], y: t2.y + i2[1], z: t2.z + i2[2] };
        if (s2 === dt) {
          var a2 = i2[0], h2 = i2[1], e2 = i2[2], n2 = i2[3], r2 = i2[4], o2 = i2[5], l2 = i2[6];
          return { x: l2 * (t2.x - o2 * t2.y + r2 * t2.z) + a2, y: l2 * (o2 * t2.x + t2.y - n2 * t2.z) + h2, z: l2 * (-r2 * t2.x + n2 * t2.y + t2.z) + e2 };
        }
      }
      function L(t2, s2, i2) {
        if (s2 === ft)
          return { x: t2.x - i2[0], y: t2.y - i2[1], z: t2.z - i2[2] };
        if (s2 === dt) {
          var a2 = i2[0], h2 = i2[1], e2 = i2[2], n2 = i2[3], r2 = i2[4], o2 = i2[5], l2 = i2[6], u2 = (t2.x - a2) / l2, c2 = (t2.y - h2) / l2, M2 = (t2.z - e2) / l2;
          return { x: u2 + o2 * c2 - r2 * M2, y: -o2 * u2 + c2 + n2 * M2, z: r2 * u2 - n2 * c2 + M2 };
        }
      }
      function T(t2) {
        return t2 === ft || t2 === dt;
      }
      function G(t2, s2, i2) {
        if (null === t2.grids || 0 === t2.grids.length)
          return console.log("Grid shift grids not found"), -1;
        var a2 = { x: -i2.x, y: i2.y }, h2 = { x: Number.NaN, y: Number.NaN }, e2 = [];
        t:
          for (var n2 = 0; n2 < t2.grids.length; n2++) {
            var r2 = t2.grids[n2];
            if (e2.push(r2.name), r2.isNull) {
              h2 = a2;
              break;
            }
            if (null !== r2.grid)
              for (var o2 = r2.grid.subgrids, l2 = 0, u2 = o2.length; l2 < u2; l2++) {
                var c2 = o2[l2], M2 = (Math.abs(c2.del[1]) + Math.abs(c2.del[0])) / 1e4, f2 = c2.ll[0] - M2, d2 = c2.ll[1] - M2, p5 = c2.ll[0] + (c2.lim[0] - 1) * c2.del[0] + M2, m2 = c2.ll[1] + (c2.lim[1] - 1) * c2.del[1] + M2;
                if (!(d2 > a2.y || f2 > a2.x || m2 < a2.y || p5 < a2.x) && (h2 = j(a2, s2, c2), !isNaN(h2.x)))
                  break t;
              }
            else if (r2.mandatory)
              return console.log("Unable to find mandatory grid '" + r2.name + "'"), -1;
          }
        return isNaN(h2.x) ? (console.log("Failed to find a grid shift table for location '" + -a2.x * At + " " + a2.y * At + " tried: '" + e2 + "'"), -1) : (i2.x = -h2.x, i2.y = h2.y, 0);
      }
      function j(t2, s2, i2) {
        var a2 = { x: Number.NaN, y: Number.NaN };
        if (isNaN(t2.x))
          return a2;
        var h2 = { x: t2.x, y: t2.y };
        h2.x -= i2.ll[0], h2.y -= i2.ll[1], h2.x = Ht(h2.x - Math.PI) + Math.PI;
        var e2 = B(h2, i2);
        if (s2) {
          if (isNaN(e2.x))
            return a2;
          e2.x = h2.x - e2.x, e2.y = h2.y - e2.y;
          var n2, r2, o2 = 9;
          do {
            if (r2 = B(e2, i2), isNaN(r2.x)) {
              console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
              break;
            }
            n2 = { x: h2.x - (r2.x + e2.x), y: h2.y - (r2.y + e2.y) }, e2.x += n2.x, e2.y += n2.y;
          } while (o2-- && Math.abs(n2.x) > 1e-12 && Math.abs(n2.y) > 1e-12);
          if (o2 < 0)
            return console.log("Inverse grid shift iterator failed to converge."), a2;
          a2.x = Ht(e2.x + i2.ll[0]), a2.y = e2.y + i2.ll[1];
        } else
          isNaN(e2.x) || (a2.x = t2.x + e2.x, a2.y = t2.y + e2.y);
        return a2;
      }
      function B(t2, s2) {
        var i2, a2 = { x: t2.x / s2.del[0], y: t2.y / s2.del[1] }, h2 = { x: Math.floor(a2.x), y: Math.floor(a2.y) }, e2 = { x: a2.x - 1 * h2.x, y: a2.y - 1 * h2.y }, n2 = { x: Number.NaN, y: Number.NaN };
        if (h2.x < 0 || h2.x >= s2.lim[0])
          return n2;
        if (h2.y < 0 || h2.y >= s2.lim[1])
          return n2;
        i2 = h2.y * s2.lim[0] + h2.x;
        var r2 = { x: s2.cvs[i2][0], y: s2.cvs[i2][1] };
        i2++;
        var o2 = { x: s2.cvs[i2][0], y: s2.cvs[i2][1] };
        i2 += s2.lim[0];
        var l2 = { x: s2.cvs[i2][0], y: s2.cvs[i2][1] };
        i2--;
        var u2 = { x: s2.cvs[i2][0], y: s2.cvs[i2][1] }, c2 = e2.x * e2.y, M2 = e2.x * (1 - e2.y), f2 = (1 - e2.x) * (1 - e2.y), d2 = (1 - e2.x) * e2.y;
        return n2.x = f2 * r2.x + M2 * o2.x + d2 * u2.x + c2 * l2.x, n2.y = f2 * r2.y + M2 * o2.y + d2 * u2.y + c2 * l2.y, n2;
      }
      function z(t2) {
        if ("function" == typeof Number.isFinite) {
          if (Number.isFinite(t2))
            return;
          throw new TypeError("coordinates must be finite numbers");
        }
        if ("number" != typeof t2 || t2 !== t2 || !isFinite(t2))
          throw new TypeError("coordinates must be finite numbers");
      }
      function F(t2, s2) {
        return (t2.datum.datum_type === ft || t2.datum.datum_type === dt || t2.datum.datum_type === pt) && "WGS84" !== s2.datumCode || (s2.datum.datum_type === ft || s2.datum.datum_type === dt || s2.datum.datum_type === pt) && "WGS84" !== t2.datumCode;
      }
      function D(t2, s2, i2, a2) {
        var h2, e2 = void 0 !== (i2 = Array.isArray(i2) ? es(i2) : { x: i2.x, y: i2.y, z: i2.z, m: i2.m }).z;
        if (ns(i2), t2.datum && s2.datum && F(t2, s2) && (i2 = D(t2, h2 = new Projection2("WGS84"), i2, a2), t2 = h2), a2 && "enu" !== t2.axis && (i2 = hs(t2, false, i2)), "longlat" === t2.projName)
          i2 = { x: i2.x * Nt, y: i2.y * Nt, z: i2.z || 0 };
        else if (t2.to_meter && (i2 = { x: i2.x * t2.to_meter, y: i2.y * t2.to_meter, z: i2.z || 0 }), !(i2 = t2.inverse(i2)))
          return;
        if (t2.from_greenwich && (i2.x += t2.from_greenwich), i2 = as(t2.datum, s2.datum, i2))
          return s2.from_greenwich && (i2 = { x: i2.x - s2.from_greenwich, y: i2.y, z: i2.z || 0 }), "longlat" === s2.projName ? i2 = { x: i2.x * At, y: i2.y * At, z: i2.z || 0 } : (i2 = s2.forward(i2), s2.to_meter && (i2 = { x: i2.x / s2.to_meter, y: i2.y / s2.to_meter, z: i2.z || 0 })), a2 && "enu" !== s2.axis ? hs(s2, true, i2) : (i2 && !e2 && delete i2.z, i2);
      }
      function U(t2, s2, i2, a2) {
        var h2, e2, n2;
        return Array.isArray(i2) ? (h2 = D(t2, s2, i2, a2) || { x: NaN, y: NaN }, i2.length > 2 ? void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name ? "number" == typeof h2.z ? [h2.x, h2.y, h2.z].concat(i2.splice(3)) : [h2.x, h2.y, i2[2]].concat(i2.splice(3)) : [h2.x, h2.y].concat(i2.splice(2)) : [h2.x, h2.y]) : (e2 = D(t2, s2, i2, a2), 2 === (n2 = Object.keys(i2)).length ? e2 : (n2.forEach(function(a3) {
          if (void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name) {
            if ("x" === a3 || "y" === a3 || "z" === a3)
              return;
          } else if ("x" === a3 || "y" === a3)
            return;
          e2[a3] = i2[a3];
        }), e2));
      }
      function Q(t2) {
        return t2 instanceof Projection2 ? t2 : t2.oProj ? t2.oProj : Projection2(t2);
      }
      function W(t2, s2, i2) {
        t2 = Q(t2);
        var a2, h2 = false;
        return void 0 === s2 ? (s2 = t2, t2 = rs, h2 = true) : (void 0 !== s2.x || Array.isArray(s2)) && (i2 = s2, s2 = t2, t2 = rs, h2 = true), s2 = Q(s2), i2 ? U(t2, s2, i2) : (a2 = { forward: function(i3, a3) {
          return U(t2, s2, i3, a3);
        }, inverse: function(i3, a3) {
          return U(s2, t2, i3, a3);
        } }, h2 && (a2.oProj = s2), a2);
      }
      function H(t2, s2) {
        return s2 = s2 || 5, $(V({ lat: t2[1], lon: t2[0] }), s2);
      }
      function X(t2) {
        var s2 = Z(at(t2.toUpperCase()));
        return s2.lat && s2.lon ? [s2.lon, s2.lat] : [(s2.left + s2.right) / 2, (s2.top + s2.bottom) / 2];
      }
      function J(t2) {
        return t2 * (Math.PI / 180);
      }
      function K(t2) {
        return t2 / Math.PI * 180;
      }
      function V(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2 = t2.lat, l2 = t2.lon, u2 = 6378137, c2 = J(o2), M2 = J(l2);
        r2 = Math.floor((l2 + 180) / 6) + 1, 180 === l2 && (r2 = 60), o2 >= 56 && o2 < 64 && l2 >= 3 && l2 < 12 && (r2 = 32), o2 >= 72 && o2 < 84 && (l2 >= 0 && l2 < 9 ? r2 = 31 : l2 >= 9 && l2 < 21 ? r2 = 33 : l2 >= 21 && l2 < 33 ? r2 = 35 : l2 >= 33 && l2 < 42 && (r2 = 37)), n2 = J(6 * (r2 - 1) - 180 + 3), s2 = u2 / Math.sqrt(1 - 669438e-8 * Math.sin(c2) * Math.sin(c2)), i2 = Math.tan(c2) * Math.tan(c2), a2 = 0.006739496752268451 * Math.cos(c2) * Math.cos(c2);
        var f2 = 0.9996 * s2 * ((h2 = Math.cos(c2) * (M2 - n2)) + (1 - i2 + a2) * h2 * h2 * h2 / 6 + (5 - 18 * i2 + i2 * i2 + 72 * a2 - 0.39089081163157013) * h2 * h2 * h2 * h2 * h2 / 120) + 5e5, d2 = 0.9996 * ((e2 = u2 * (0.9983242984503243 * c2 - 0.002514607064228144 * Math.sin(2 * c2) + 2639046602129982e-21 * Math.sin(4 * c2) - 3418046101696858e-24 * Math.sin(6 * c2))) + s2 * Math.tan(c2) * (h2 * h2 / 2 + (5 - i2 + 9 * a2 + 4 * a2 * a2) * h2 * h2 * h2 * h2 / 24 + (61 - 58 * i2 + i2 * i2 + 600 * a2 - 2.2240339282485886) * h2 * h2 * h2 * h2 * h2 * h2 / 720));
        return o2 < 0 && (d2 += 1e7), { northing: Math.round(d2), easting: Math.round(f2), zoneNumber: r2, zoneLetter: Y(o2) };
      }
      function Z(t2) {
        var s2 = t2.northing, i2 = t2.easting, a2 = t2.zoneLetter, h2 = t2.zoneNumber;
        if (h2 < 0 || h2 > 60)
          return null;
        var e2, n2, r2, o2, l2, u2, c2, M2, f2 = 6378137, d2 = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)), p5 = i2 - 5e5, m2 = s2;
        a2 < "N" && (m2 -= 1e7), u2 = 6 * (h2 - 1) - 180 + 3, M2 = (c2 = m2 / 0.9996 / 6367449145945056e-9) + (3 * d2 / 2 - 27 * d2 * d2 * d2 / 32) * Math.sin(2 * c2) + (21 * d2 * d2 / 16 - 55 * d2 * d2 * d2 * d2 / 32) * Math.sin(4 * c2) + 151 * d2 * d2 * d2 / 96 * Math.sin(6 * c2), e2 = f2 / Math.sqrt(1 - 669438e-8 * Math.sin(M2) * Math.sin(M2)), n2 = Math.tan(M2) * Math.tan(M2), r2 = 0.006739496752268451 * Math.cos(M2) * Math.cos(M2), o2 = 0.99330562 * f2 / Math.pow(1 - 669438e-8 * Math.sin(M2) * Math.sin(M2), 1.5), l2 = p5 / (0.9996 * e2);
        var _2 = M2 - e2 * Math.tan(M2) / o2 * (l2 * l2 / 2 - (5 + 3 * n2 + 10 * r2 - 4 * r2 * r2 - 0.06065547077041606) * l2 * l2 * l2 * l2 / 24 + (61 + 90 * n2 + 298 * r2 + 45 * n2 * n2 - 1.6983531815716497 - 3 * r2 * r2) * l2 * l2 * l2 * l2 * l2 * l2 / 720);
        _2 = K(_2);
        var y2 = (l2 - (1 + 2 * n2 + r2) * l2 * l2 * l2 / 6 + (5 - 2 * r2 + 28 * n2 - 3 * r2 * r2 + 0.05391597401814761 + 24 * n2 * n2) * l2 * l2 * l2 * l2 * l2 / 120) / Math.cos(M2);
        y2 = u2 + K(y2);
        var x2;
        if (t2.accuracy) {
          var g2 = Z({ northing: t2.northing + t2.accuracy, easting: t2.easting + t2.accuracy, zoneLetter: t2.zoneLetter, zoneNumber: t2.zoneNumber });
          x2 = { top: g2.lat, right: g2.lon, bottom: _2, left: y2 };
        } else
          x2 = { lat: _2, lon: y2 };
        return x2;
      }
      function Y(t2) {
        var s2 = "Z";
        return 84 >= t2 && t2 >= 72 ? s2 = "X" : 72 > t2 && t2 >= 64 ? s2 = "W" : 64 > t2 && t2 >= 56 ? s2 = "V" : 56 > t2 && t2 >= 48 ? s2 = "U" : 48 > t2 && t2 >= 40 ? s2 = "T" : 40 > t2 && t2 >= 32 ? s2 = "S" : 32 > t2 && t2 >= 24 ? s2 = "R" : 24 > t2 && t2 >= 16 ? s2 = "Q" : 16 > t2 && t2 >= 8 ? s2 = "P" : 8 > t2 && t2 >= 0 ? s2 = "N" : 0 > t2 && t2 >= -8 ? s2 = "M" : -8 > t2 && t2 >= -16 ? s2 = "L" : -16 > t2 && t2 >= -24 ? s2 = "K" : -24 > t2 && t2 >= -32 ? s2 = "J" : -32 > t2 && t2 >= -40 ? s2 = "H" : -40 > t2 && t2 >= -48 ? s2 = "G" : -48 > t2 && t2 >= -56 ? s2 = "F" : -56 > t2 && t2 >= -64 ? s2 = "E" : -64 > t2 && t2 >= -72 ? s2 = "D" : -72 > t2 && t2 >= -80 && (s2 = "C"), s2;
      }
      function $(t2, s2) {
        var i2 = "00000" + t2.easting, a2 = "00000" + t2.northing;
        return t2.zoneNumber + t2.zoneLetter + tt(t2.easting, t2.northing, t2.zoneNumber) + i2.substr(i2.length - 5, s2) + a2.substr(a2.length - 5, s2);
      }
      function tt(t2, s2, i2) {
        var a2 = st(i2);
        return it(Math.floor(t2 / 1e5), Math.floor(s2 / 1e5) % 20, a2);
      }
      function st(t2) {
        var s2 = t2 % os;
        return 0 === s2 && (s2 = os), s2;
      }
      function it(t2, s2, i2) {
        var a2 = i2 - 1, h2 = ls.charCodeAt(a2), e2 = us.charCodeAt(a2), n2 = h2 + t2 - 1, r2 = e2 + s2, o2 = false;
        return n2 > ps && (n2 = n2 - ps + cs - 1, o2 = true), (n2 === Ms || h2 < Ms && n2 > Ms || (n2 > Ms || h2 < Ms) && o2) && n2++, (n2 === fs || h2 < fs && n2 > fs || (n2 > fs || h2 < fs) && o2) && ++n2 === Ms && n2++, n2 > ps && (n2 = n2 - ps + cs - 1), r2 > ds ? (r2 = r2 - ds + cs - 1, o2 = true) : o2 = false, (r2 === Ms || e2 < Ms && r2 > Ms || (r2 > Ms || e2 < Ms) && o2) && r2++, (r2 === fs || e2 < fs && r2 > fs || (r2 > fs || e2 < fs) && o2) && ++r2 === Ms && r2++, r2 > ds && (r2 = r2 - ds + cs - 1), String.fromCharCode(n2) + String.fromCharCode(r2);
      }
      function at(t2) {
        if (t2 && 0 === t2.length)
          throw "MGRSPoint coverting from nothing";
        for (var s2, i2 = t2.length, a2 = null, h2 = "", e2 = 0; !/[A-Z]/.test(s2 = t2.charAt(e2)); ) {
          if (e2 >= 2)
            throw "MGRSPoint bad conversion from: " + t2;
          h2 += s2, e2++;
        }
        var n2 = parseInt(h2, 10);
        if (0 === e2 || e2 + 3 > i2)
          throw "MGRSPoint bad conversion from: " + t2;
        var r2 = t2.charAt(e2++);
        if (r2 <= "A" || "B" === r2 || "Y" === r2 || r2 >= "Z" || "I" === r2 || "O" === r2)
          throw "MGRSPoint zone letter " + r2 + " not handled: " + t2;
        a2 = t2.substring(e2, e2 += 2);
        for (var o2 = st(n2), l2 = ht(a2.charAt(0), o2), u2 = et(a2.charAt(1), o2); u2 < nt(r2); )
          u2 += 2e6;
        var c2 = i2 - e2;
        if (c2 % 2 != 0)
          throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t2;
        var M2, f2, d2, p5, m2, _2 = c2 / 2, y2 = 0, x2 = 0;
        return _2 > 0 && (M2 = 1e5 / Math.pow(10, _2), f2 = t2.substring(e2, e2 + _2), y2 = parseFloat(f2) * M2, d2 = t2.substring(e2 + _2), x2 = parseFloat(d2) * M2), p5 = y2 + l2, m2 = x2 + u2, { easting: p5, northing: m2, zoneLetter: r2, zoneNumber: n2, accuracy: M2 };
      }
      function ht(t2, s2) {
        for (var i2 = ls.charCodeAt(s2 - 1), a2 = 1e5, h2 = false; i2 !== t2.charCodeAt(0); ) {
          if (++i2 === Ms && i2++, i2 === fs && i2++, i2 > ps) {
            if (h2)
              throw "Bad character: " + t2;
            i2 = cs, h2 = true;
          }
          a2 += 1e5;
        }
        return a2;
      }
      function et(t2, s2) {
        if (t2 > "V")
          throw "MGRSPoint given invalid Northing " + t2;
        for (var i2 = us.charCodeAt(s2 - 1), a2 = 0, h2 = false; i2 !== t2.charCodeAt(0); ) {
          if (++i2 === Ms && i2++, i2 === fs && i2++, i2 > ds) {
            if (h2)
              throw "Bad character: " + t2;
            i2 = cs, h2 = true;
          }
          a2 += 1e5;
        }
        return a2;
      }
      function nt(t2) {
        var s2;
        switch (t2) {
          case "C":
            s2 = 11e5;
            break;
          case "D":
            s2 = 2e6;
            break;
          case "E":
            s2 = 28e5;
            break;
          case "F":
            s2 = 37e5;
            break;
          case "G":
            s2 = 46e5;
            break;
          case "H":
            s2 = 55e5;
            break;
          case "J":
            s2 = 64e5;
            break;
          case "K":
            s2 = 73e5;
            break;
          case "L":
            s2 = 82e5;
            break;
          case "M":
            s2 = 91e5;
            break;
          case "N":
            s2 = 0;
            break;
          case "P":
            s2 = 8e5;
            break;
          case "Q":
            s2 = 17e5;
            break;
          case "R":
            s2 = 26e5;
            break;
          case "S":
            s2 = 35e5;
            break;
          case "T":
            s2 = 44e5;
            break;
          case "U":
            s2 = 53e5;
            break;
          case "V":
            s2 = 62e5;
            break;
          case "W":
            s2 = 7e6;
            break;
          case "X":
            s2 = 79e5;
            break;
          default:
            s2 = -1;
        }
        if (s2 >= 0)
          return s2;
        throw "Invalid zone letter: " + t2;
      }
      function Point2(t2, s2, i2) {
        if (!(this instanceof Point2))
          return new Point2(t2, s2, i2);
        if (Array.isArray(t2))
          this.x = t2[0], this.y = t2[1], this.z = t2[2] || 0;
        else if ("object" == typeof t2)
          this.x = t2.x, this.y = t2.y, this.z = t2.z || 0;
        else if ("string" == typeof t2 && void 0 === s2) {
          var a2 = t2.split(",");
          this.x = parseFloat(a2[0], 10), this.y = parseFloat(a2[1], 10), this.z = parseFloat(a2[2], 10) || 0;
        } else
          this.x = t2, this.y = s2, this.z = i2 || 0;
        console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
      }
      function rt(t2) {
        var s2 = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], i2 = "object" == typeof t2.PROJECTION ? Object.keys(t2.PROJECTION)[0] : t2.PROJECTION;
        return "no_uoff" in t2 || "no_off" in t2 || -1 !== s2.indexOf(i2);
      }
      function ot(t2) {
        var s2, i2 = [];
        return i2[0] = t2 * $s, s2 = t2 * t2, i2[0] += s2 * ti, i2[1] = s2 * ii, s2 *= t2, i2[0] += s2 * si, i2[1] += s2 * ai, i2[2] = s2 * hi, i2;
      }
      function lt(t2, s2) {
        var i2 = t2 + t2;
        return t2 + s2[0] * Math.sin(i2) + s2[1] * Math.sin(i2 + i2) + s2[2] * Math.sin(i2 + i2 + i2);
      }
      function ut(t2, s2, i2, a2) {
        var h2;
        return t2 < wt ? (a2.value = Ni.AREA_0, h2 = 0) : (h2 = Math.atan2(s2, i2), Math.abs(h2) <= Et ? a2.value = Ni.AREA_0 : h2 > Et && h2 <= xt + Et ? (a2.value = Ni.AREA_1, h2 -= xt) : h2 > xt + Et || h2 <= -(xt + Et) ? (a2.value = Ni.AREA_2, h2 = h2 >= 0 ? h2 - Pt : h2 + Pt) : (a2.value = Ni.AREA_3, h2 += xt)), h2;
      }
      function ct(t2, s2) {
        var i2 = t2 + s2;
        return i2 < -Pt ? i2 += Ct : i2 > +Pt && (i2 -= Ct), i2;
      }
      function Mt(t2, s2, i2, a2) {
        for (var h2 = s2; a2; --a2) {
          var e2 = t2(h2);
          if (h2 -= e2, Math.abs(e2) < i2)
            break;
        }
        return h2;
      }
      var ft = 1, dt = 2, pt = 3, mt = 4, _t = 5, yt = 484813681109536e-20, xt = Math.PI / 2, gt = 0.16666666666666666, vt = 0.04722222222222222, bt = 0.022156084656084655, wt = 1e-10, Nt = 0.017453292519943295, At = 57.29577951308232, Et = Math.PI / 4, Ct = 2 * Math.PI, Pt = 3.14159265359, St = {};
      St.greenwich = 0, St.lisbon = -9.131906111111, St.paris = 2.337229166667, St.bogota = -74.080916666667, St.madrid = -3.687938888889, St.rome = 12.452333333333, St.bern = 7.439583333333, St.jakarta = 106.807719444444, St.ferro = -17.666666666667, St.brussels = 4.367975, St.stockholm = 18.058277777778, St.athens = 23.7163375, St.oslo = 10.722916666667;
      var It = { ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 } }, Ot = /[\s_\-\/\(\)]/g, kt = function(s2) {
        var i2, a2, h2, e2 = {}, n2 = s2.split("+").map(function(t2) {
          return t2.trim();
        }).filter(function(t2) {
          return t2;
        }).reduce(function(t2, s3) {
          var i3 = s3.split("=");
          return i3.push(true), t2[i3[0].toLowerCase()] = i3[1], t2;
        }, {}), r2 = { proj: "projName", datum: "datumCode", rf: function(t2) {
          e2.rf = parseFloat(t2);
        }, lat_0: function(t2) {
          e2.lat0 = t2 * Nt;
        }, lat_1: function(t2) {
          e2.lat1 = t2 * Nt;
        }, lat_2: function(t2) {
          e2.lat2 = t2 * Nt;
        }, lat_ts: function(t2) {
          e2.lat_ts = t2 * Nt;
        }, lon_0: function(t2) {
          e2.long0 = t2 * Nt;
        }, lon_1: function(t2) {
          e2.long1 = t2 * Nt;
        }, lon_2: function(t2) {
          e2.long2 = t2 * Nt;
        }, alpha: function(t2) {
          e2.alpha = parseFloat(t2) * Nt;
        }, gamma: function(t2) {
          e2.rectified_grid_angle = parseFloat(t2);
        }, lonc: function(t2) {
          e2.longc = t2 * Nt;
        }, x_0: function(t2) {
          e2.x0 = parseFloat(t2);
        }, y_0: function(t2) {
          e2.y0 = parseFloat(t2);
        }, k_0: function(t2) {
          e2.k0 = parseFloat(t2);
        }, k: function(t2) {
          e2.k0 = parseFloat(t2);
        }, a: function(t2) {
          e2.a = parseFloat(t2);
        }, b: function(t2) {
          e2.b = parseFloat(t2);
        }, r_a: function() {
          e2.R_A = true;
        }, zone: function(t2) {
          e2.zone = parseInt(t2, 10);
        }, south: function() {
          e2.utmSouth = true;
        }, towgs84: function(t2) {
          e2.datum_params = t2.split(",").map(function(t3) {
            return parseFloat(t3);
          });
        }, to_meter: function(t2) {
          e2.to_meter = parseFloat(t2);
        }, units: function(s3) {
          e2.units = s3;
          var i3 = t(It, s3);
          i3 && (e2.to_meter = i3.to_meter);
        }, from_greenwich: function(t2) {
          e2.from_greenwich = t2 * Nt;
        }, pm: function(s3) {
          var i3 = t(St, s3);
          e2.from_greenwich = (i3 || parseFloat(s3)) * Nt;
        }, nadgrids: function(t2) {
          "@null" === t2 ? e2.datumCode = "none" : e2.nadgrids = t2;
        }, axis: function(t2) {
          3 === t2.length && -1 !== "ewnsud".indexOf(t2.substr(0, 1)) && -1 !== "ewnsud".indexOf(t2.substr(1, 1)) && -1 !== "ewnsud".indexOf(t2.substr(2, 1)) && (e2.axis = t2);
        }, approx: function() {
          e2.approx = true;
        } };
        for (i2 in n2)
          a2 = n2[i2], i2 in r2 ? "function" == typeof (h2 = r2[i2]) ? h2(a2) : e2[h2] = a2 : e2[i2] = a2;
        return "string" == typeof e2.datumCode && "WGS84" !== e2.datumCode && (e2.datumCode = e2.datumCode.toLowerCase()), e2;
      }, qt = 1, Rt = /\s/, Lt = /[A-Za-z]/, Tt = /[A-Za-z84_]/, Gt = /[,\]]/, jt = /[\d\.E\-\+]/;
      s.prototype.readCharicter = function() {
        var t2 = this.text[this.place++];
        if (4 !== this.state)
          for (; Rt.test(t2); ) {
            if (this.place >= this.text.length)
              return;
            t2 = this.text[this.place++];
          }
        switch (this.state) {
          case qt:
            return this.neutral(t2);
          case 2:
            return this.keyword(t2);
          case 4:
            return this.quoted(t2);
          case 5:
            return this.afterquote(t2);
          case 3:
            return this.number(t2);
          case -1:
            return;
        }
      }, s.prototype.afterquote = function(t2) {
        if ('"' === t2)
          return this.word += '"', void (this.state = 4);
        if (Gt.test(t2))
          return this.word = this.word.trim(), void this.afterItem(t2);
        throw new Error(`havn't handled "` + t2 + '" in afterquote yet, index ' + this.place);
      }, s.prototype.afterItem = function(t2) {
        return "," === t2 ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = qt)) : "]" === t2 ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = qt, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
      }, s.prototype.number = function(t2) {
        if (!jt.test(t2)) {
          if (Gt.test(t2))
            return this.word = parseFloat(this.word), void this.afterItem(t2);
          throw new Error(`havn't handled "` + t2 + '" in number yet, index ' + this.place);
        }
        this.word += t2;
      }, s.prototype.quoted = function(t2) {
        '"' !== t2 ? this.word += t2 : this.state = 5;
      }, s.prototype.keyword = function(t2) {
        if (Tt.test(t2))
          this.word += t2;
        else {
          if ("[" === t2) {
            var s2 = [];
            return s2.push(this.word), this.level++, null === this.root ? this.root = s2 : this.currentObject.push(s2), this.stack.push(this.currentObject), this.currentObject = s2, void (this.state = qt);
          }
          if (!Gt.test(t2))
            throw new Error(`havn't handled "` + t2 + '" in keyword yet, index ' + this.place);
          this.afterItem(t2);
        }
      }, s.prototype.neutral = function(t2) {
        if (Lt.test(t2))
          return this.word = t2, void (this.state = 2);
        if ('"' === t2)
          return this.word = "", void (this.state = 4);
        if (jt.test(t2))
          return this.word = t2, void (this.state = 3);
        {
          if (!Gt.test(t2))
            throw new Error(`havn't handled "` + t2 + '" in neutral yet, index ' + this.place);
          this.afterItem(t2);
        }
      }, s.prototype.output = function() {
        for (; this.place < this.text.length; )
          this.readCharicter();
        if (-1 === this.state)
          return this.root;
        throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
      };
      var Bt = 0.017453292519943295, zt = function(t2) {
        var s2 = i(t2), a2 = s2.shift(), e2 = s2.shift();
        s2.unshift(["name", e2]), s2.unshift(["type", a2]);
        var n2 = {};
        return h(s2, n2), r(n2), n2;
      };
      !function(t2) {
        t2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t2.WGS84 = t2["EPSG:4326"], t2["EPSG:3785"] = t2["EPSG:3857"], t2.GOOGLE = t2["EPSG:3857"], t2["EPSG:900913"] = t2["EPSG:3857"], t2["EPSG:102113"] = t2["EPSG:3857"];
      }(o);
      var Ft = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"], Dt = ["3857", "900913", "3785", "102113"], Ut = function(t2, s2) {
        t2 = t2 || {};
        var i2, a2;
        if (!s2)
          return t2;
        for (a2 in s2)
          void 0 !== (i2 = s2[a2]) && (t2[a2] = i2);
        return t2;
      }, Qt = function(t2, s2, i2) {
        var a2 = t2 * s2;
        return i2 / Math.sqrt(1 - a2 * a2);
      }, Wt = function(t2) {
        return t2 < 0 ? -1 : 1;
      }, Ht = function(t2) {
        return Math.abs(t2) <= Pt ? t2 : t2 - Wt(t2) * Ct;
      }, Xt = function(t2, s2, i2) {
        var a2 = t2 * i2, h2 = 0.5 * t2;
        return a2 = Math.pow((1 - a2) / (1 + a2), h2), Math.tan(0.5 * (xt - s2)) / a2;
      }, Jt = function(t2, s2) {
        for (var i2, a2, h2 = 0.5 * t2, e2 = xt - 2 * Math.atan(s2), n2 = 0; n2 <= 15; n2++)
          if (i2 = t2 * Math.sin(e2), a2 = xt - 2 * Math.atan(s2 * Math.pow((1 - i2) / (1 + i2), h2)) - e2, e2 += a2, Math.abs(a2) <= 1e-10)
            return e2;
        return -9999;
      }, Kt = [{ init: function() {
        var t2 = this.b / this.a;
        this.es = 1 - t2 * t2, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Qt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        if (i2 * At > 90 && i2 * At < -90 && s2 * At > 180 && s2 * At < -180)
          return null;
        var a2, h2;
        if (Math.abs(Math.abs(i2) - xt) <= wt)
          return null;
        if (this.sphere)
          a2 = this.x0 + this.a * this.k0 * Ht(s2 - this.long0), h2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(Et + 0.5 * i2));
        else {
          var e2 = Math.sin(i2), n2 = Xt(this.e, i2, e2);
          a2 = this.x0 + this.a * this.k0 * Ht(s2 - this.long0), h2 = this.y0 - this.a * this.k0 * Math.log(n2);
        }
        return t2.x = a2, t2.y = h2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2 = t2.x - this.x0, h2 = t2.y - this.y0;
        if (this.sphere)
          i2 = xt - 2 * Math.atan(Math.exp(-h2 / (this.a * this.k0)));
        else {
          var e2 = Math.exp(-h2 / (this.a * this.k0));
          if (-9999 === (i2 = Jt(this.e, e2)))
            return null;
        }
        return s2 = Ht(this.long0 + a2 / (this.a * this.k0)), t2.x = s2, t2.y = i2, t2;
      }, names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"] }, { init: function() {
      }, forward: m, inverse: m, names: ["longlat", "identity"] }], Vt = {}, Zt = [], Yt = { start: function() {
        Kt.forEach(_);
      }, add: _, get: function(t2) {
        if (!t2)
          return false;
        var s2 = t2.toLowerCase();
        return void 0 !== Vt[s2] && Zt[Vt[s2]] ? Zt[Vt[s2]] : void 0;
      } }, $t = {};
      $t.MERIT = { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, $t.SGS85 = { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, $t.GRS80 = { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, $t.IAU76 = { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, $t.airy = { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, $t.APL4 = { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, $t.NWL9D = { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, $t.mod_airy = { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, $t.andrae = { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, $t.aust_SA = { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, $t.GRS67 = { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, $t.bessel = { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, $t.bess_nam = { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, $t.clrk66 = { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, $t.clrk80 = { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, $t.clrk80ign = { a: 63782492e-1, b: 6356515, rf: 293.4660213, ellipseName: "Clarke 1880 (IGN)" }, $t.clrk58 = { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, $t.CPM = { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, $t.delmbr = { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, $t.engelis = { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, $t.evrst30 = { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, $t.evrst48 = { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, $t.evrst56 = { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, $t.evrst69 = { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, $t.evrstSS = { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, $t.fschr60 = { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, $t.fschr60m = { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, $t.fschr68 = { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, $t.helmert = { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, $t.hough = { a: 6378270, rf: 297, ellipseName: "Hough" }, $t.intl = { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, $t.kaula = { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, $t.lerch = { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, $t.mprts = { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, $t.new_intl = { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, $t.plessis = { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, $t.krass = { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, $t.SEasia = { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, $t.walbeck = { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, $t.WGS60 = { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, $t.WGS66 = { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, $t.WGS7 = { a: 6378135, rf: 298.26, ellipseName: "WGS 72" };
      var ts = $t.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" };
      $t.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" };
      var ss = {};
      ss.wgs84 = { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, ss.ch1903 = { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, ss.ggrs87 = { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, ss.nad83 = { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, ss.nad27 = { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, ss.potsdam = { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, ss.carthage = { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, ss.hermannskogel = { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, ss.osni52 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, ss.ire65 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, ss.rassadiran = { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, ss.nzgd49 = { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, ss.osgb36 = { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, ss.s_jtsk = { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, ss.beduaram = { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, ss.gunung_segara = { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, ss.rnb72 = { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" };
      var is = {};
      Projection2.projections = Yt, Projection2.projections.start();
      var as = function(t2, s2, i2) {
        if (O(t2, s2))
          return i2;
        if (t2.datum_type === _t || s2.datum_type === _t)
          return i2;
        var a2 = t2.a, h2 = t2.es;
        if (t2.datum_type === pt) {
          if (0 !== G(t2, false, i2))
            return;
          a2 = 6378137, h2 = 0.0066943799901413165;
        }
        var e2 = s2.a, n2 = s2.b, r2 = s2.es;
        return s2.datum_type === pt && (e2 = 6378137, n2 = 6356752314e-3, r2 = 0.0066943799901413165), h2 !== r2 || a2 !== e2 || T(t2.datum_type) || T(s2.datum_type) ? (i2 = k(i2, h2, a2), T(t2.datum_type) && (i2 = R(i2, t2.datum_type, t2.datum_params)), T(s2.datum_type) && (i2 = L(i2, s2.datum_type, s2.datum_params)), i2 = q(i2, r2, e2, n2), s2.datum_type !== pt || 0 === G(s2, true, i2) ? i2 : void 0) : i2;
      }, hs = function(t2, s2, i2) {
        var a2, h2, e2, n2 = i2.x, r2 = i2.y, o2 = i2.z || 0, l2 = {};
        for (e2 = 0; e2 < 3; e2++)
          if (!s2 || 2 !== e2 || void 0 !== i2.z)
            switch (0 === e2 ? (a2 = n2, h2 = -1 !== "ew".indexOf(t2.axis[e2]) ? "x" : "y") : 1 === e2 ? (a2 = r2, h2 = -1 !== "ns".indexOf(t2.axis[e2]) ? "y" : "x") : (a2 = o2, h2 = "z"), t2.axis[e2]) {
              case "e":
                l2[h2] = a2;
                break;
              case "w":
                l2[h2] = -a2;
                break;
              case "n":
                l2[h2] = a2;
                break;
              case "s":
                l2[h2] = -a2;
                break;
              case "u":
                void 0 !== i2[h2] && (l2.z = a2);
                break;
              case "d":
                void 0 !== i2[h2] && (l2.z = -a2);
                break;
              default:
                return null;
            }
        return l2;
      }, es = function(t2) {
        var s2 = { x: t2[0], y: t2[1] };
        return t2.length > 2 && (s2.z = t2[2]), t2.length > 3 && (s2.m = t2[3]), s2;
      }, ns = function(t2) {
        z(t2.x), z(t2.y);
      }, rs = Projection2("WGS84"), os = 6, ls = "AJSAJS", us = "AFAFAF", cs = 65, Ms = 73, fs = 79, ds = 86, ps = 90, ms = { forward: H, inverse: function(t2) {
        var s2 = Z(at(t2.toUpperCase()));
        return s2.lat && s2.lon ? [s2.lon, s2.lat, s2.lon, s2.lat] : [s2.left, s2.bottom, s2.right, s2.top];
      }, toPoint: X };
      Point2.fromMGRS = function(t2) {
        return new Point2(X(t2));
      }, Point2.prototype.toMGRS = function(t2) {
        return H([this.x, this.y], t2);
      };
      var _s = 0.01068115234375, ys = function(t2) {
        var s2 = [];
        s2[0] = 1 - t2 * (0.25 + t2 * (0.046875 + t2 * (0.01953125 + t2 * _s))), s2[1] = t2 * (0.75 - t2 * (0.046875 + t2 * (0.01953125 + t2 * _s)));
        var i2 = t2 * t2;
        return s2[2] = i2 * (0.46875 - t2 * (0.013020833333333334 + 0.007120768229166667 * t2)), i2 *= t2, s2[3] = i2 * (0.3645833333333333 - 0.005696614583333333 * t2), s2[4] = i2 * t2 * 0.3076171875, s2;
      }, xs = function(t2, s2, i2, a2) {
        return i2 *= s2, s2 *= s2, a2[0] * t2 - i2 * (a2[1] + s2 * (a2[2] + s2 * (a2[3] + s2 * a2[4])));
      }, gs = function(t2, s2, i2) {
        for (var a2 = 1 / (1 - s2), h2 = t2, e2 = 20; e2; --e2) {
          var n2 = Math.sin(h2), r2 = 1 - s2 * n2 * n2;
          if (r2 = (xs(h2, n2, Math.cos(h2), i2) - t2) * (r2 * Math.sqrt(r2)) * a2, h2 -= r2, Math.abs(r2) < wt)
            return h2;
        }
        return h2;
      }, vs = { init: function() {
        this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = ys(this.es), this.ml0 = xs(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
      }, forward: function(t2) {
        var s2, i2, a2, h2 = t2.x, e2 = t2.y, n2 = Ht(h2 - this.long0), r2 = Math.sin(e2), o2 = Math.cos(e2);
        if (this.es) {
          var l2 = o2 * n2, u2 = Math.pow(l2, 2), c2 = this.ep2 * Math.pow(o2, 2), M2 = Math.pow(c2, 2), f2 = Math.abs(o2) > wt ? Math.tan(e2) : 0, d2 = Math.pow(f2, 2), p5 = Math.pow(d2, 2);
          s2 = 1 - this.es * Math.pow(r2, 2), l2 /= Math.sqrt(s2);
          var m2 = xs(e2, r2, o2, this.en);
          i2 = this.a * (this.k0 * l2 * (1 + u2 / 6 * (1 - d2 + c2 + u2 / 20 * (5 - 18 * d2 + p5 + 14 * c2 - 58 * d2 * c2 + u2 / 42 * (61 + 179 * p5 - p5 * d2 - 479 * d2))))) + this.x0, a2 = this.a * (this.k0 * (m2 - this.ml0 + r2 * n2 * l2 / 2 * (1 + u2 / 12 * (5 - d2 + 9 * c2 + 4 * M2 + u2 / 30 * (61 + p5 - 58 * d2 + 270 * c2 - 330 * d2 * c2 + u2 / 56 * (1385 + 543 * p5 - p5 * d2 - 3111 * d2)))))) + this.y0;
        } else {
          var _2 = o2 * Math.sin(n2);
          if (Math.abs(Math.abs(_2) - 1) < wt)
            return 93;
          if (i2 = 0.5 * this.a * this.k0 * Math.log((1 + _2) / (1 - _2)) + this.x0, a2 = o2 * Math.cos(n2) / Math.sqrt(1 - Math.pow(_2, 2)), (_2 = Math.abs(a2)) >= 1) {
            if (_2 - 1 > wt)
              return 93;
            a2 = 0;
          } else
            a2 = Math.acos(a2);
          e2 < 0 && (a2 = -a2), a2 = this.a * this.k0 * (a2 - this.lat0) + this.y0;
        }
        return t2.x = i2, t2.y = a2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2 = (t2.x - this.x0) * (1 / this.a), n2 = (t2.y - this.y0) * (1 / this.a);
        if (this.es)
          if (s2 = this.ml0 + n2 / this.k0, i2 = gs(s2, this.es, this.en), Math.abs(i2) < xt) {
            var r2 = Math.sin(i2), o2 = Math.cos(i2), l2 = Math.abs(o2) > wt ? Math.tan(i2) : 0, u2 = this.ep2 * Math.pow(o2, 2), c2 = Math.pow(u2, 2), M2 = Math.pow(l2, 2), f2 = Math.pow(M2, 2);
            s2 = 1 - this.es * Math.pow(r2, 2);
            var d2 = e2 * Math.sqrt(s2) / this.k0, p5 = Math.pow(d2, 2);
            a2 = i2 - (s2 *= l2) * p5 / (1 - this.es) * 0.5 * (1 - p5 / 12 * (5 + 3 * M2 - 9 * u2 * M2 + u2 - 4 * c2 - p5 / 30 * (61 + 90 * M2 - 252 * u2 * M2 + 45 * f2 + 46 * u2 - p5 / 56 * (1385 + 3633 * M2 + 4095 * f2 + 1574 * f2 * M2)))), h2 = Ht(this.long0 + d2 * (1 - p5 / 6 * (1 + 2 * M2 + u2 - p5 / 20 * (5 + 28 * M2 + 24 * f2 + 8 * u2 * M2 + 6 * u2 - p5 / 42 * (61 + 662 * M2 + 1320 * f2 + 720 * f2 * M2)))) / o2);
          } else
            a2 = xt * Wt(n2), h2 = 0;
        else {
          var m2 = Math.exp(e2 / this.k0), _2 = 0.5 * (m2 - 1 / m2), y2 = this.lat0 + n2 / this.k0, x2 = Math.cos(y2);
          s2 = Math.sqrt((1 - Math.pow(x2, 2)) / (1 + Math.pow(_2, 2))), a2 = Math.asin(s2), n2 < 0 && (a2 = -a2), h2 = 0 === _2 && 0 === x2 ? 0 : Ht(Math.atan2(_2, x2) + this.long0);
        }
        return t2.x = h2, t2.y = a2, t2;
      }, names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"] }, bs = function(t2) {
        var s2 = Math.exp(t2);
        return s2 = (s2 - 1 / s2) / 2;
      }, ws = function(t2, s2) {
        t2 = Math.abs(t2), s2 = Math.abs(s2);
        var i2 = Math.max(t2, s2), a2 = Math.min(t2, s2) / (i2 || 1);
        return i2 * Math.sqrt(1 + Math.pow(a2, 2));
      }, Ns = function(t2) {
        var s2 = 1 + t2, i2 = s2 - 1;
        return 0 === i2 ? t2 : t2 * Math.log(s2) / i2;
      }, As = function(t2) {
        var s2 = Math.abs(t2);
        return s2 = Ns(s2 * (1 + s2 / (ws(1, s2) + 1))), t2 < 0 ? -s2 : s2;
      }, Es = function(t2, s2) {
        for (var i2, a2 = 2 * Math.cos(2 * s2), h2 = t2.length - 1, e2 = t2[h2], n2 = 0; --h2 >= 0; )
          i2 = a2 * e2 - n2 + t2[h2], n2 = e2, e2 = i2;
        return s2 + i2 * Math.sin(2 * s2);
      }, Cs = function(t2, s2) {
        for (var i2, a2 = 2 * Math.cos(s2), h2 = t2.length - 1, e2 = t2[h2], n2 = 0; --h2 >= 0; )
          i2 = a2 * e2 - n2 + t2[h2], n2 = e2, e2 = i2;
        return Math.sin(s2) * i2;
      }, Ps = function(t2) {
        var s2 = Math.exp(t2);
        return s2 = (s2 + 1 / s2) / 2;
      }, Ss = function(t2, s2, i2) {
        for (var a2, h2, e2 = Math.sin(s2), n2 = Math.cos(s2), r2 = bs(i2), o2 = Ps(i2), l2 = 2 * n2 * o2, u2 = -2 * e2 * r2, c2 = t2.length - 1, M2 = t2[c2], f2 = 0, d2 = 0, p5 = 0; --c2 >= 0; )
          a2 = d2, h2 = f2, M2 = l2 * (d2 = M2) - a2 - u2 * (f2 = p5) + t2[c2], p5 = u2 * d2 - h2 + l2 * f2;
        return l2 = e2 * o2, u2 = n2 * r2, [l2 * M2 - u2 * p5, l2 * p5 + u2 * M2];
      }, Is = { init: function() {
        if (!this.approx && (isNaN(this.es) || this.es <= 0))
          throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
        this.approx && (vs.init.apply(this), this.forward = vs.forward, this.inverse = vs.inverse), this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
        var t2 = this.es / (1 + Math.sqrt(1 - this.es)), s2 = t2 / (2 - t2), i2 = s2;
        this.cgb[0] = s2 * (2 + s2 * (-2 / 3 + s2 * (s2 * (116 / 45 + s2 * (26 / 45 + s2 * (-2854 / 675))) - 2))), this.cbg[0] = s2 * (s2 * (2 / 3 + s2 * (4 / 3 + s2 * (-82 / 45 + s2 * (32 / 45 + s2 * (4642 / 4725))))) - 2), i2 *= s2, this.cgb[1] = i2 * (7 / 3 + s2 * (s2 * (-227 / 45 + s2 * (2704 / 315 + s2 * (2323 / 945))) - 1.6)), this.cbg[1] = i2 * (5 / 3 + s2 * (-16 / 15 + s2 * (-13 / 9 + s2 * (904 / 315 + s2 * (-1522 / 945))))), i2 *= s2, this.cgb[2] = i2 * (56 / 15 + s2 * (-136 / 35 + s2 * (-1262 / 105 + s2 * (73814 / 2835)))), this.cbg[2] = i2 * (-26 / 15 + s2 * (34 / 21 + s2 * (1.6 + s2 * (-12686 / 2835)))), i2 *= s2, this.cgb[3] = i2 * (4279 / 630 + s2 * (-332 / 35 + s2 * (-399572 / 14175))), this.cbg[3] = i2 * (1237 / 630 + s2 * (s2 * (-24832 / 14175) - 2.4)), i2 *= s2, this.cgb[4] = i2 * (4174 / 315 + s2 * (-144838 / 6237)), this.cbg[4] = i2 * (-734 / 315 + s2 * (109598 / 31185)), i2 *= s2, this.cgb[5] = i2 * (601676 / 22275), this.cbg[5] = i2 * (444337 / 155925), i2 = Math.pow(s2, 2), this.Qn = this.k0 / (1 + s2) * (1 + i2 * (0.25 + i2 * (1 / 64 + i2 / 256))), this.utg[0] = s2 * (s2 * (2 / 3 + s2 * (-37 / 96 + s2 * (1 / 360 + s2 * (81 / 512 + s2 * (-96199 / 604800))))) - 0.5), this.gtu[0] = s2 * (0.5 + s2 * (-2 / 3 + s2 * (5 / 16 + s2 * (41 / 180 + s2 * (-127 / 288 + s2 * (7891 / 37800)))))), this.utg[1] = i2 * (-1 / 48 + s2 * (-1 / 15 + s2 * (437 / 1440 + s2 * (-46 / 105 + s2 * (1118711 / 3870720))))), this.gtu[1] = i2 * (13 / 48 + s2 * (s2 * (557 / 1440 + s2 * (281 / 630 + s2 * (-1983433 / 1935360))) - 0.6)), i2 *= s2, this.utg[2] = i2 * (-17 / 480 + s2 * (37 / 840 + s2 * (209 / 4480 + s2 * (-5569 / 90720)))), this.gtu[2] = i2 * (61 / 240 + s2 * (-103 / 140 + s2 * (15061 / 26880 + s2 * (167603 / 181440)))), i2 *= s2, this.utg[3] = i2 * (-4397 / 161280 + s2 * (11 / 504 + s2 * (830251 / 7257600))), this.gtu[3] = i2 * (49561 / 161280 + s2 * (-179 / 168 + s2 * (6601661 / 7257600))), i2 *= s2, this.utg[4] = i2 * (-4583 / 161280 + s2 * (108847 / 3991680)), this.gtu[4] = i2 * (34729 / 80640 + s2 * (-3418889 / 1995840)), i2 *= s2, this.utg[5] = -0.03233083094085698 * i2, this.gtu[5] = 0.6650675310896665 * i2;
        var a2 = Es(this.cbg, this.lat0);
        this.Zb = -this.Qn * (a2 + Cs(this.gtu, 2 * a2));
      }, forward: function(t2) {
        var s2 = Ht(t2.x - this.long0), i2 = t2.y;
        i2 = Es(this.cbg, i2);
        var a2 = Math.sin(i2), h2 = Math.cos(i2), e2 = Math.sin(s2), n2 = Math.cos(s2);
        i2 = Math.atan2(a2, n2 * h2), s2 = Math.atan2(e2 * h2, ws(a2, h2 * n2)), s2 = As(Math.tan(s2));
        var r2 = Ss(this.gtu, 2 * i2, 2 * s2);
        i2 += r2[0], s2 += r2[1];
        var o2, l2;
        return Math.abs(s2) <= 2.623395162778 ? (o2 = this.a * (this.Qn * s2) + this.x0, l2 = this.a * (this.Qn * i2 + this.Zb) + this.y0) : (o2 = 1 / 0, l2 = 1 / 0), t2.x = o2, t2.y = l2, t2;
      }, inverse: function(t2) {
        var s2 = (t2.x - this.x0) * (1 / this.a), i2 = (t2.y - this.y0) * (1 / this.a);
        i2 = (i2 - this.Zb) / this.Qn, s2 /= this.Qn;
        var a2, h2;
        if (Math.abs(s2) <= 2.623395162778) {
          var e2 = Ss(this.utg, 2 * i2, 2 * s2);
          i2 += e2[0], s2 += e2[1], s2 = Math.atan(bs(s2));
          var n2 = Math.sin(i2), r2 = Math.cos(i2), o2 = Math.sin(s2), l2 = Math.cos(s2);
          i2 = Math.atan2(n2 * l2, ws(o2, l2 * r2)), s2 = Math.atan2(o2, l2 * r2), a2 = Ht(s2 + this.long0), h2 = Es(this.cgb, i2);
        } else
          a2 = 1 / 0, h2 = 1 / 0;
        return t2.x = a2, t2.y = h2, t2;
      }, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"] }, Os = function(t2, s2) {
        if (void 0 === t2) {
          if ((t2 = Math.floor(30 * (Ht(s2) + Math.PI) / Math.PI) + 1) < 0)
            return 0;
          if (t2 > 60)
            return 60;
        }
        return t2;
      }, ks = { init: function() {
        var t2 = Os(this.zone, this.long0);
        if (void 0 === t2)
          throw new Error("unknown utm zone");
        this.lat0 = 0, this.long0 = (6 * Math.abs(t2) - 183) * Nt, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Is.init.apply(this), this.forward = Is.forward, this.inverse = Is.inverse;
      }, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc" }, qs = function(t2, s2) {
        return Math.pow((1 - t2) / (1 + t2), s2);
      }, Rs = 20, Ls = { init: function() {
        var t2 = Math.sin(this.lat0), s2 = Math.cos(this.lat0);
        s2 *= s2, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t2 * t2), this.C = Math.sqrt(1 + this.es * s2 * s2 / (1 - this.es)), this.phic0 = Math.asin(t2 / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Et) / (Math.pow(Math.tan(0.5 * this.lat0 + Et), this.C) * qs(this.e * t2, this.ratexp));
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        return t2.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * i2 + Et), this.C) * qs(this.e * Math.sin(i2), this.ratexp)) - xt, t2.x = this.C * s2, t2;
      }, inverse: function(t2) {
        for (var s2 = t2.x / this.C, i2 = t2.y, a2 = Math.pow(Math.tan(0.5 * i2 + Et) / this.K, 1 / this.C), h2 = Rs; h2 > 0 && (i2 = 2 * Math.atan(a2 * qs(this.e * Math.sin(t2.y), -0.5 * this.e)) - xt, !(Math.abs(i2 - t2.y) < 1e-14)); --h2)
          t2.y = i2;
        return h2 ? (t2.x = s2, t2.y = i2, t2) : null;
      }, names: ["gauss"] }, Ts = { init: function() {
        Ls.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
      }, forward: function(t2) {
        var s2, i2, a2, h2;
        return t2.x = Ht(t2.x - this.long0), Ls.forward.apply(this, [t2]), s2 = Math.sin(t2.y), i2 = Math.cos(t2.y), a2 = Math.cos(t2.x), h2 = this.k0 * this.R2 / (1 + this.sinc0 * s2 + this.cosc0 * i2 * a2), t2.x = h2 * i2 * Math.sin(t2.x), t2.y = h2 * (this.cosc0 * s2 - this.sinc0 * i2 * a2), t2.x = this.a * t2.x + this.x0, t2.y = this.a * t2.y + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2;
        if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, e2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) {
          var n2 = 2 * Math.atan2(e2, this.R2);
          s2 = Math.sin(n2), i2 = Math.cos(n2), h2 = Math.asin(i2 * this.sinc0 + t2.y * s2 * this.cosc0 / e2), a2 = Math.atan2(t2.x * s2, e2 * this.cosc0 * i2 - t2.y * this.sinc0 * s2);
        } else
          h2 = this.phic0, a2 = 0;
        return t2.x = a2, t2.y = h2, Ls.inverse.apply(this, [t2]), t2.x = Ht(t2.x + this.long0), t2;
      }, names: ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"] }, Gs = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= wt && (this.k0 = 0.5 * (1 + Wt(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= wt && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= wt && Math.abs(Math.cos(this.lat_ts)) > wt && (this.k0 = 0.5 * this.cons * Qt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Xt(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Qt(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - xt, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2 = t2.x, o2 = t2.y, l2 = Math.sin(o2), u2 = Math.cos(o2), c2 = Ht(r2 - this.long0);
        return Math.abs(Math.abs(r2 - this.long0) - Math.PI) <= wt && Math.abs(o2 + this.lat0) <= wt ? (t2.x = NaN, t2.y = NaN, t2) : this.sphere ? (s2 = 2 * this.k0 / (1 + this.sinlat0 * l2 + this.coslat0 * u2 * Math.cos(c2)), t2.x = this.a * s2 * u2 * Math.sin(c2) + this.x0, t2.y = this.a * s2 * (this.coslat0 * l2 - this.sinlat0 * u2 * Math.cos(c2)) + this.y0, t2) : (i2 = 2 * Math.atan(this.ssfn_(o2, l2, this.e)) - xt, h2 = Math.cos(i2), a2 = Math.sin(i2), Math.abs(this.coslat0) <= wt ? (e2 = Xt(this.e, o2 * this.con, this.con * l2), n2 = 2 * this.a * this.k0 * e2 / this.cons, t2.x = this.x0 + n2 * Math.sin(r2 - this.long0), t2.y = this.y0 - this.con * n2 * Math.cos(r2 - this.long0), t2) : (Math.abs(this.sinlat0) < wt ? (s2 = 2 * this.a * this.k0 / (1 + h2 * Math.cos(c2)), t2.y = s2 * a2) : (s2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * a2 + this.cosX0 * h2 * Math.cos(c2))), t2.y = s2 * (this.cosX0 * a2 - this.sinX0 * h2 * Math.cos(c2)) + this.y0), t2.x = s2 * h2 * Math.sin(c2) + this.x0, t2));
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2, a2, h2, e2, n2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y);
        if (this.sphere) {
          var r2 = 2 * Math.atan(n2 / (2 * this.a * this.k0));
          return s2 = this.long0, i2 = this.lat0, n2 <= wt ? (t2.x = s2, t2.y = i2, t2) : (i2 = Math.asin(Math.cos(r2) * this.sinlat0 + t2.y * Math.sin(r2) * this.coslat0 / n2), s2 = Ht(Math.abs(this.coslat0) < wt ? this.lat0 > 0 ? this.long0 + Math.atan2(t2.x, -1 * t2.y) : this.long0 + Math.atan2(t2.x, t2.y) : this.long0 + Math.atan2(t2.x * Math.sin(r2), n2 * this.coslat0 * Math.cos(r2) - t2.y * this.sinlat0 * Math.sin(r2))), t2.x = s2, t2.y = i2, t2);
        }
        if (Math.abs(this.coslat0) <= wt) {
          if (n2 <= wt)
            return i2 = this.lat0, s2 = this.long0, t2.x = s2, t2.y = i2, t2;
          t2.x *= this.con, t2.y *= this.con, a2 = n2 * this.cons / (2 * this.a * this.k0), i2 = this.con * Jt(this.e, a2), s2 = this.con * Ht(this.con * this.long0 + Math.atan2(t2.x, -1 * t2.y));
        } else
          h2 = 2 * Math.atan(n2 * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), s2 = this.long0, n2 <= wt ? e2 = this.X0 : (e2 = Math.asin(Math.cos(h2) * this.sinX0 + t2.y * Math.sin(h2) * this.cosX0 / n2), s2 = Ht(this.long0 + Math.atan2(t2.x * Math.sin(h2), n2 * this.cosX0 * Math.cos(h2) - t2.y * this.sinX0 * Math.sin(h2)))), i2 = -1 * Jt(this.e, Math.tan(0.5 * (xt + e2)));
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"], ssfn_: function(t2, s2, i2) {
        return s2 *= i2, Math.tan(0.5 * (xt + t2)) * Math.pow((1 - s2) / (1 + s2), 0.5 * i2);
      } }, js = { init: function() {
        var t2 = this.lat0;
        this.lambda0 = this.long0;
        var s2 = Math.sin(t2), i2 = this.a, a2 = 1 / this.rf, h2 = 2 * a2 - Math.pow(a2, 2), e2 = this.e = Math.sqrt(h2);
        this.R = this.k0 * i2 * Math.sqrt(1 - h2) / (1 - h2 * Math.pow(s2, 2)), this.alpha = Math.sqrt(1 + h2 / (1 - h2) * Math.pow(Math.cos(t2), 4)), this.b0 = Math.asin(s2 / this.alpha);
        var n2 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), r2 = Math.log(Math.tan(Math.PI / 4 + t2 / 2)), o2 = Math.log((1 + e2 * s2) / (1 - e2 * s2));
        this.K = n2 - this.alpha * r2 + this.alpha * e2 / 2 * o2;
      }, forward: function(t2) {
        var s2 = Math.log(Math.tan(Math.PI / 4 - t2.y / 2)), i2 = this.e / 2 * Math.log((1 + this.e * Math.sin(t2.y)) / (1 - this.e * Math.sin(t2.y))), a2 = -this.alpha * (s2 + i2) + this.K, h2 = 2 * (Math.atan(Math.exp(a2)) - Math.PI / 4), e2 = this.alpha * (t2.x - this.lambda0), n2 = Math.atan(Math.sin(e2) / (Math.sin(this.b0) * Math.tan(h2) + Math.cos(this.b0) * Math.cos(e2))), r2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) - Math.sin(this.b0) * Math.cos(h2) * Math.cos(e2));
        return t2.y = this.R / 2 * Math.log((1 + Math.sin(r2)) / (1 - Math.sin(r2))) + this.y0, t2.x = this.R * n2 + this.x0, t2;
      }, inverse: function(t2) {
        for (var s2 = t2.x - this.x0, i2 = t2.y - this.y0, a2 = s2 / this.R, h2 = 2 * (Math.atan(Math.exp(i2 / this.R)) - Math.PI / 4), e2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) + Math.sin(this.b0) * Math.cos(h2) * Math.cos(a2)), n2 = Math.atan(Math.sin(a2) / (Math.cos(this.b0) * Math.cos(a2) - Math.sin(this.b0) * Math.tan(h2))), r2 = this.lambda0 + n2 / this.alpha, o2 = 0, l2 = e2, u2 = -1e3, c2 = 0; Math.abs(l2 - u2) > 1e-7; ) {
          if (++c2 > 20)
            return;
          o2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + e2 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l2)) / 2)), u2 = l2, l2 = 2 * Math.atan(Math.exp(o2)) - Math.PI / 2;
        }
        return t2.x = r2, t2.y = l2, t2;
      }, names: ["somerc"] }, Bs = 1e-7, zs = { init: function() {
        var t2, s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2 = 0, M2 = 0, f2 = 0, d2 = 0, p5 = 0, m2 = 0, _2 = 0;
        this.no_off = rt(this), this.no_rot = "no_rot" in this;
        var y2 = false;
        "alpha" in this && (y2 = true);
        var x2 = false;
        if ("rectified_grid_angle" in this && (x2 = true), y2 && (_2 = this.alpha), x2 && (c2 = this.rectified_grid_angle * Nt), y2 || x2)
          M2 = this.longc;
        else if (f2 = this.long1, p5 = this.lat1, d2 = this.long2, m2 = this.lat2, Math.abs(p5 - m2) <= Bs || (t2 = Math.abs(p5)) <= Bs || Math.abs(t2 - xt) <= Bs || Math.abs(Math.abs(this.lat0) - xt) <= Bs || Math.abs(Math.abs(m2) - xt) <= Bs)
          throw new Error();
        var g2 = 1 - this.es;
        s2 = Math.sqrt(g2), Math.abs(this.lat0) > wt ? (r2 = Math.sin(this.lat0), i2 = Math.cos(this.lat0), t2 = 1 - this.es * r2 * r2, this.B = i2 * i2, this.B = Math.sqrt(1 + this.es * this.B * this.B / g2), this.A = this.B * this.k0 * s2 / t2, (h2 = (a2 = this.B * s2 / (i2 * Math.sqrt(t2))) * a2 - 1) <= 0 ? h2 = 0 : (h2 = Math.sqrt(h2), this.lat0 < 0 && (h2 = -h2)), this.E = h2 += a2, this.E *= Math.pow(Xt(this.e, this.lat0, r2), this.B)) : (this.B = 1 / s2, this.A = this.k0, this.E = a2 = h2 = 1), y2 || x2 ? (y2 ? (u2 = Math.asin(Math.sin(_2) / a2), x2 || (c2 = _2)) : (u2 = c2, _2 = Math.asin(a2 * Math.sin(u2))), this.lam0 = M2 - Math.asin(0.5 * (h2 - 1 / h2) * Math.tan(u2)) / this.B) : (e2 = Math.pow(Xt(this.e, p5, Math.sin(p5)), this.B), n2 = Math.pow(Xt(this.e, m2, Math.sin(m2)), this.B), h2 = this.E / e2, o2 = (n2 - e2) / (n2 + e2), l2 = ((l2 = this.E * this.E) - n2 * e2) / (l2 + n2 * e2), (t2 = f2 - d2) < -Math.pi ? d2 -= Ct : t2 > Math.pi && (d2 += Ct), this.lam0 = Ht(0.5 * (f2 + d2) - Math.atan(l2 * Math.tan(0.5 * this.B * (f2 - d2)) / o2) / this.B), u2 = Math.atan(2 * Math.sin(this.B * Ht(f2 - this.lam0)) / (h2 - 1 / h2)), c2 = _2 = Math.asin(a2 * Math.sin(u2))), this.singam = Math.sin(u2), this.cosgam = Math.cos(u2), this.sinrot = Math.sin(c2), this.cosrot = Math.cos(c2), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(a2 * a2 - 1) / Math.cos(_2))), this.lat0 < 0 && (this.u_0 = -this.u_0)), h2 = 0.5 * u2, this.v_pole_n = this.ArB * Math.log(Math.tan(Et - h2)), this.v_pole_s = this.ArB * Math.log(Math.tan(Et + h2));
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2, l2 = {};
        if (t2.x = t2.x - this.lam0, Math.abs(Math.abs(t2.y) - xt) > wt) {
          if (e2 = this.E / Math.pow(Xt(this.e, t2.y, Math.sin(t2.y)), this.B), n2 = 1 / e2, s2 = 0.5 * (e2 - n2), i2 = 0.5 * (e2 + n2), h2 = Math.sin(this.B * t2.x), a2 = (s2 * this.singam - h2 * this.cosgam) / i2, Math.abs(Math.abs(a2) - 1) < wt)
            throw new Error();
          o2 = 0.5 * this.ArB * Math.log((1 - a2) / (1 + a2)), n2 = Math.cos(this.B * t2.x), r2 = Math.abs(n2) < Bs ? this.A * t2.x : this.ArB * Math.atan2(s2 * this.cosgam + h2 * this.singam, n2);
        } else
          o2 = t2.y > 0 ? this.v_pole_n : this.v_pole_s, r2 = this.ArB * t2.y;
        return this.no_rot ? (l2.x = r2, l2.y = o2) : (r2 -= this.u_0, l2.x = o2 * this.cosrot + r2 * this.sinrot, l2.y = r2 * this.cosrot - o2 * this.sinrot), l2.x = this.a * l2.x + this.x0, l2.y = this.a * l2.y + this.y0, l2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2 = {};
        if (t2.x = (t2.x - this.x0) * (1 / this.a), t2.y = (t2.y - this.y0) * (1 / this.a), this.no_rot ? (i2 = t2.y, s2 = t2.x) : (i2 = t2.x * this.cosrot - t2.y * this.sinrot, s2 = t2.y * this.cosrot + t2.x * this.sinrot + this.u_0), a2 = Math.exp(-this.BrA * i2), h2 = 0.5 * (a2 - 1 / a2), e2 = 0.5 * (a2 + 1 / a2), n2 = Math.sin(this.BrA * s2), r2 = (n2 * this.cosgam + h2 * this.singam) / e2, Math.abs(Math.abs(r2) - 1) < wt)
          o2.x = 0, o2.y = r2 < 0 ? -xt : xt;
        else {
          if (o2.y = this.E / Math.sqrt((1 + r2) / (1 - r2)), o2.y = Jt(this.e, Math.pow(o2.y, 1 / this.B)), o2.y === 1 / 0)
            throw new Error();
          o2.x = -this.rB * Math.atan2(h2 * this.cosgam - n2 * this.singam, Math.cos(this.BrA * s2));
        }
        return o2.x += this.lam0, o2;
      }, names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"] }, Fs = { init: function() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < wt)) {
          var t2 = this.b / this.a;
          this.e = Math.sqrt(1 - t2 * t2);
          var s2 = Math.sin(this.lat1), i2 = Math.cos(this.lat1), a2 = Qt(this.e, s2, i2), h2 = Xt(this.e, this.lat1, s2), e2 = Math.sin(this.lat2), n2 = Math.cos(this.lat2), r2 = Qt(this.e, e2, n2), o2 = Xt(this.e, this.lat2, e2), l2 = Xt(this.e, this.lat0, Math.sin(this.lat0));
          Math.abs(this.lat1 - this.lat2) > wt ? this.ns = Math.log(a2 / r2) / Math.log(h2 / o2) : this.ns = s2, isNaN(this.ns) && (this.ns = s2), this.f0 = a2 / (this.ns * Math.pow(h2, this.ns)), this.rh = this.a * this.f0 * Math.pow(l2, this.ns), this.title || (this.title = "Lambert Conformal Conic");
        }
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        Math.abs(2 * Math.abs(i2) - Math.PI) <= wt && (i2 = Wt(i2) * (xt - 2 * wt));
        var a2, h2, e2 = Math.abs(Math.abs(i2) - xt);
        if (e2 > wt)
          a2 = Xt(this.e, i2, Math.sin(i2)), h2 = this.a * this.f0 * Math.pow(a2, this.ns);
        else {
          if ((e2 = i2 * this.ns) <= 0)
            return null;
          h2 = 0;
        }
        var n2 = this.ns * Ht(s2 - this.long0);
        return t2.x = this.k0 * (h2 * Math.sin(n2)) + this.x0, t2.y = this.k0 * (this.rh - h2 * Math.cos(n2)) + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2 = (t2.x - this.x0) / this.k0, r2 = this.rh - (t2.y - this.y0) / this.k0;
        this.ns > 0 ? (s2 = Math.sqrt(n2 * n2 + r2 * r2), i2 = 1) : (s2 = -Math.sqrt(n2 * n2 + r2 * r2), i2 = -1);
        var o2 = 0;
        if (0 !== s2 && (o2 = Math.atan2(i2 * n2, i2 * r2)), 0 !== s2 || this.ns > 0) {
          if (i2 = 1 / this.ns, a2 = Math.pow(s2 / (this.a * this.f0), i2), -9999 === (h2 = Jt(this.e, a2)))
            return null;
        } else
          h2 = -xt;
        return e2 = Ht(o2 / this.ns + this.long0), t2.x = e2, t2.y = h2, t2;
      }, names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"] }, Ds = { init: function() {
        this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.4334234309119251), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y, u2 = Ht(o2 - this.long0);
        return s2 = Math.pow((1 + this.e * Math.sin(l2)) / (1 - this.e * Math.sin(l2)), this.alfa * this.e / 2), i2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(l2 / 2 + this.s45), this.alfa) / s2) - this.s45), a2 = -u2 * this.alfa, h2 = Math.asin(Math.cos(this.ad) * Math.sin(i2) + Math.sin(this.ad) * Math.cos(i2) * Math.cos(a2)), e2 = Math.asin(Math.cos(i2) * Math.sin(a2) / Math.cos(h2)), n2 = this.n * e2, r2 = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(h2 / 2 + this.s45), this.n), t2.y = r2 * Math.cos(n2) / 1, t2.x = r2 * Math.sin(n2) / 1, this.czech || (t2.y *= -1, t2.x *= -1), t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x;
        t2.x = t2.y, t2.y = o2, this.czech || (t2.y *= -1, t2.x *= -1), e2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), h2 = Math.atan2(t2.y, t2.x) / Math.sin(this.s0), a2 = 2 * (Math.atan(Math.pow(this.ro0 / e2, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), s2 = Math.asin(Math.cos(this.ad) * Math.sin(a2) - Math.sin(this.ad) * Math.cos(a2) * Math.cos(h2)), i2 = Math.asin(Math.cos(a2) * Math.sin(h2) / Math.cos(s2)), t2.x = this.long0 - i2 / this.alfa, n2 = s2, r2 = 0;
        var l2 = 0;
        do {
          t2.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(s2 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(n2)) / (1 - this.e * Math.sin(n2)), this.e / 2)) - this.s45), Math.abs(n2 - t2.y) < 1e-10 && (r2 = 1), n2 = t2.y, l2 += 1;
        } while (0 === r2 && l2 < 15);
        return l2 >= 15 ? null : t2;
      }, names: ["Krovak", "krovak"] }, Us = function(t2, s2, i2, a2, h2) {
        return t2 * h2 - s2 * Math.sin(2 * h2) + i2 * Math.sin(4 * h2) - a2 * Math.sin(6 * h2);
      }, Qs = function(t2) {
        return 1 - 0.25 * t2 * (1 + t2 / 16 * (3 + 1.25 * t2));
      }, Ws = function(t2) {
        return 0.375 * t2 * (1 + 0.25 * t2 * (1 + 0.46875 * t2));
      }, Hs = function(t2) {
        return 0.05859375 * t2 * t2 * (1 + 0.75 * t2);
      }, Xs = function(t2) {
        return t2 * t2 * t2 * (35 / 3072);
      }, Js = function(t2, s2, i2) {
        var a2 = s2 * i2;
        return t2 / Math.sqrt(1 - a2 * a2);
      }, Ks = function(t2) {
        return Math.abs(t2) < xt ? t2 : t2 - Wt(t2) * Math.PI;
      }, Vs = function(t2, s2, i2, a2, h2) {
        var e2, n2;
        e2 = t2 / s2;
        for (var r2 = 0; r2 < 15; r2++)
          if (n2 = (t2 - (s2 * e2 - i2 * Math.sin(2 * e2) + a2 * Math.sin(4 * e2) - h2 * Math.sin(6 * e2))) / (s2 - 2 * i2 * Math.cos(2 * e2) + 4 * a2 * Math.cos(4 * e2) - 6 * h2 * Math.cos(6 * e2)), e2 += n2, Math.abs(n2) <= 1e-10)
            return e2;
        return NaN;
      }, Zs = { init: function() {
        this.sphere || (this.e0 = Qs(this.es), this.e1 = Ws(this.es), this.e2 = Hs(this.es), this.e3 = Xs(this.es), this.ml0 = this.a * Us(this.e0, this.e1, this.e2, this.e3, this.lat0));
      }, forward: function(t2) {
        var s2, i2, a2 = t2.x, h2 = t2.y;
        if (a2 = Ht(a2 - this.long0), this.sphere)
          s2 = this.a * Math.asin(Math.cos(h2) * Math.sin(a2)), i2 = this.a * (Math.atan2(Math.tan(h2), Math.cos(a2)) - this.lat0);
        else {
          var e2 = Math.sin(h2), n2 = Math.cos(h2), r2 = Js(this.a, this.e, e2), o2 = Math.tan(h2) * Math.tan(h2), l2 = a2 * Math.cos(h2), u2 = l2 * l2, c2 = this.es * n2 * n2 / (1 - this.es);
          s2 = r2 * l2 * (1 - u2 * o2 * (1 / 6 - (8 - o2 + 8 * c2) * u2 / 120)), i2 = this.a * Us(this.e0, this.e1, this.e2, this.e3, h2) - this.ml0 + r2 * e2 / n2 * u2 * (0.5 + (5 - o2 + 6 * c2) * u2 / 24);
        }
        return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2, a2 = t2.x / this.a, h2 = t2.y / this.a;
        if (this.sphere) {
          var e2 = h2 + this.lat0;
          s2 = Math.asin(Math.sin(e2) * Math.cos(a2)), i2 = Math.atan2(Math.tan(a2), Math.cos(e2));
        } else {
          var n2 = this.ml0 / this.a + h2, r2 = Vs(n2, this.e0, this.e1, this.e2, this.e3);
          if (Math.abs(Math.abs(r2) - xt) <= wt)
            return t2.x = this.long0, t2.y = xt, h2 < 0 && (t2.y *= -1), t2;
          var o2 = Js(this.a, this.e, Math.sin(r2)), l2 = o2 * o2 * o2 / this.a / this.a * (1 - this.es), u2 = Math.pow(Math.tan(r2), 2), c2 = a2 * this.a / o2, M2 = c2 * c2;
          s2 = r2 - o2 * Math.tan(r2) / l2 * c2 * c2 * (0.5 - (1 + 3 * u2) * c2 * c2 / 24), i2 = c2 * (1 - M2 * (u2 / 3 + (1 + 3 * u2) * u2 * M2 / 15)) / Math.cos(r2);
        }
        return t2.x = Ht(i2 + this.long0), t2.y = Ks(s2), t2;
      }, names: ["Cassini", "Cassini_Soldner", "cass"] }, Ys = function(t2, s2) {
        var i2;
        return t2 > 1e-7 ? (i2 = t2 * s2, (1 - t2 * t2) * (s2 / (1 - i2 * i2) - 0.5 / t2 * Math.log((1 - i2) / (1 + i2)))) : 2 * s2;
      }, $s = 0.3333333333333333, ti = 0.17222222222222222, si = 0.10257936507936508, ii = 0.06388888888888888, ai = 0.0664021164021164, hi = 0.016415012942191543, ei = { init: function() {
        var t2 = Math.abs(this.lat0);
        if (Math.abs(t2 - xt) < wt ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t2) < wt ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
          var s2;
          switch (this.qp = Ys(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = ot(this.es), this.mode) {
            case this.N_POLE:
            case this.S_POLE:
              this.dd = 1;
              break;
            case this.EQUIT:
              this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
              break;
            case this.OBLIQ:
              this.rq = Math.sqrt(0.5 * this.qp), s2 = Math.sin(this.lat0), this.sinb1 = Ys(this.e, s2) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * s2 * s2) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
          }
        } else
          this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2 = t2.x, M2 = t2.y;
        if (c2 = Ht(c2 - this.long0), this.sphere) {
          if (e2 = Math.sin(M2), u2 = Math.cos(M2), a2 = Math.cos(c2), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if ((i2 = this.mode === this.EQUIT ? 1 + u2 * a2 : 1 + this.sinph0 * e2 + this.cosph0 * u2 * a2) <= wt)
              return null;
            s2 = (i2 = Math.sqrt(2 / i2)) * u2 * Math.sin(c2), i2 *= this.mode === this.EQUIT ? e2 : this.cosph0 * e2 - this.sinph0 * u2 * a2;
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (a2 = -a2), Math.abs(M2 + this.lat0) < wt)
              return null;
            i2 = Et - 0.5 * M2, s2 = (i2 = 2 * (this.mode === this.S_POLE ? Math.cos(i2) : Math.sin(i2))) * Math.sin(c2), i2 *= a2;
          }
        } else {
          switch (r2 = 0, o2 = 0, l2 = 0, a2 = Math.cos(c2), h2 = Math.sin(c2), e2 = Math.sin(M2), n2 = Ys(this.e, e2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (r2 = n2 / this.qp, o2 = Math.sqrt(1 - r2 * r2)), this.mode) {
            case this.OBLIQ:
              l2 = 1 + this.sinb1 * r2 + this.cosb1 * o2 * a2;
              break;
            case this.EQUIT:
              l2 = 1 + o2 * a2;
              break;
            case this.N_POLE:
              l2 = xt + M2, n2 = this.qp - n2;
              break;
            case this.S_POLE:
              l2 = M2 - xt, n2 = this.qp + n2;
          }
          if (Math.abs(l2) < wt)
            return null;
          switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
              l2 = Math.sqrt(2 / l2), i2 = this.mode === this.OBLIQ ? this.ymf * l2 * (this.cosb1 * r2 - this.sinb1 * o2 * a2) : (l2 = Math.sqrt(2 / (1 + o2 * a2))) * r2 * this.ymf, s2 = this.xmf * l2 * o2 * h2;
              break;
            case this.N_POLE:
            case this.S_POLE:
              n2 >= 0 ? (s2 = (l2 = Math.sqrt(n2)) * h2, i2 = a2 * (this.mode === this.S_POLE ? l2 : -l2)) : s2 = i2 = 0;
          }
        }
        return t2.x = this.a * s2 + this.x0, t2.y = this.a * i2 + this.y0, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x / this.a, l2 = t2.y / this.a;
        if (this.sphere) {
          var u2, c2 = 0, M2 = 0;
          if (u2 = Math.sqrt(o2 * o2 + l2 * l2), (i2 = 0.5 * u2) > 1)
            return null;
          switch (i2 = 2 * Math.asin(i2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (M2 = Math.sin(i2), c2 = Math.cos(i2)), this.mode) {
            case this.EQUIT:
              i2 = Math.abs(u2) <= wt ? 0 : Math.asin(l2 * M2 / u2), o2 *= M2, l2 = c2 * u2;
              break;
            case this.OBLIQ:
              i2 = Math.abs(u2) <= wt ? this.lat0 : Math.asin(c2 * this.sinph0 + l2 * M2 * this.cosph0 / u2), o2 *= M2 * this.cosph0, l2 = (c2 - Math.sin(i2) * this.sinph0) * u2;
              break;
            case this.N_POLE:
              l2 = -l2, i2 = xt - i2;
              break;
            case this.S_POLE:
              i2 -= xt;
          }
          s2 = 0 !== l2 || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(o2, l2) : 0;
        } else {
          if (r2 = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
            if (o2 /= this.dd, l2 *= this.dd, (n2 = Math.sqrt(o2 * o2 + l2 * l2)) < wt)
              return t2.x = this.long0, t2.y = this.lat0, t2;
            h2 = 2 * Math.asin(0.5 * n2 / this.rq), a2 = Math.cos(h2), o2 *= h2 = Math.sin(h2), this.mode === this.OBLIQ ? (r2 = a2 * this.sinb1 + l2 * h2 * this.cosb1 / n2, e2 = this.qp * r2, l2 = n2 * this.cosb1 * a2 - l2 * this.sinb1 * h2) : (r2 = l2 * h2 / n2, e2 = this.qp * r2, l2 = n2 * a2);
          } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
            if (this.mode === this.N_POLE && (l2 = -l2), !(e2 = o2 * o2 + l2 * l2))
              return t2.x = this.long0, t2.y = this.lat0, t2;
            r2 = 1 - e2 / this.qp, this.mode === this.S_POLE && (r2 = -r2);
          }
          s2 = Math.atan2(o2, l2), i2 = lt(Math.asin(r2), this.apa);
        }
        return t2.x = Ht(this.long0 + s2), t2.y = i2, t2;
      }, names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4 }, ni = function(t2) {
        return Math.abs(t2) > 1 && (t2 = t2 > 1 ? 1 : -1), Math.asin(t2);
      }, ri = { init: function() {
        Math.abs(this.lat1 + this.lat2) < wt || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Qt(this.e3, this.sin_po, this.cos_po), this.qs1 = Ys(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Qt(this.e3, this.sin_po, this.cos_po), this.qs2 = Ys(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Ys(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > wt ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        this.sin_phi = Math.sin(i2), this.cos_phi = Math.cos(i2);
        var a2 = Ys(this.e3, this.sin_phi), h2 = this.a * Math.sqrt(this.c - this.ns0 * a2) / this.ns0, e2 = this.ns0 * Ht(s2 - this.long0), n2 = h2 * Math.sin(e2) + this.x0, r2 = this.rh - h2 * Math.cos(e2) + this.y0;
        return t2.x = n2, t2.y = r2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2;
        return t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0, this.ns0 >= 0 ? (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), a2 = 1) : (s2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), a2 = -1), h2 = 0, 0 !== s2 && (h2 = Math.atan2(a2 * t2.x, a2 * t2.y)), a2 = s2 * this.ns0 / this.a, this.sphere ? n2 = Math.asin((this.c - a2 * a2) / (2 * this.ns0)) : (i2 = (this.c - a2 * a2) / this.ns0, n2 = this.phi1z(this.e3, i2)), e2 = Ht(h2 / this.ns0 + this.long0), t2.x = e2, t2.y = n2, t2;
      }, names: ["Albers_Conic_Equal_Area", "Albers", "aea"], phi1z: function(t2, s2) {
        var i2, a2, h2, e2, n2, r2 = ni(0.5 * s2);
        if (t2 < wt)
          return r2;
        for (var o2 = t2 * t2, l2 = 1; l2 <= 25; l2++)
          if (i2 = Math.sin(r2), a2 = Math.cos(r2), h2 = t2 * i2, e2 = 1 - h2 * h2, n2 = 0.5 * e2 * e2 / a2 * (s2 / (1 - o2) - i2 / e2 + 0.5 / t2 * Math.log((1 - h2) / (1 + h2))), r2 += n2, Math.abs(n2) <= 1e-7)
            return r2;
        return null;
      } }, oi = { init: function() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y;
        return a2 = Ht(o2 - this.long0), s2 = Math.sin(l2), i2 = Math.cos(l2), h2 = Math.cos(a2), (e2 = this.sin_p14 * s2 + this.cos_p14 * i2 * h2) > 0 || Math.abs(e2) <= wt ? (n2 = this.x0 + 1 * this.a * i2 * Math.sin(a2) / e2, r2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2) / e2) : (n2 = this.x0 + this.infinity_dist * i2 * Math.sin(a2), r2 = this.y0 + this.infinity_dist * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2)), t2.x = n2, t2.y = r2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2;
        return t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) ? (h2 = Math.atan2(s2, this.rc), i2 = Math.sin(h2), a2 = Math.cos(h2), n2 = ni(a2 * this.sin_p14 + t2.y * i2 * this.cos_p14 / s2), e2 = Math.atan2(t2.x * i2, s2 * this.cos_p14 * a2 - t2.y * this.sin_p14 * i2), e2 = Ht(this.long0 + e2)) : (n2 = this.phic0, e2 = 0), t2.x = e2, t2.y = n2, t2;
      }, names: ["gnom"] }, li = function(t2, s2) {
        var i2 = 1 - (1 - t2 * t2) / (2 * t2) * Math.log((1 - t2) / (1 + t2));
        if (Math.abs(Math.abs(s2) - i2) < 1e-6)
          return s2 < 0 ? -1 * xt : xt;
        for (var a2, h2, e2, n2, r2 = Math.asin(0.5 * s2), o2 = 0; o2 < 30; o2++)
          if (h2 = Math.sin(r2), e2 = Math.cos(r2), n2 = t2 * h2, a2 = Math.pow(1 - n2 * n2, 2) / (2 * e2) * (s2 / (1 - t2 * t2) - h2 / (1 - n2 * n2) + 0.5 / t2 * Math.log((1 - n2) / (1 + n2))), r2 += a2, Math.abs(a2) <= 1e-10)
            return r2;
        return NaN;
      }, ui = { init: function() {
        this.sphere || (this.k0 = Qt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
      }, forward: function(t2) {
        var s2, i2, a2 = t2.x, h2 = t2.y, e2 = Ht(a2 - this.long0);
        if (this.sphere)
          s2 = this.x0 + this.a * e2 * Math.cos(this.lat_ts), i2 = this.y0 + this.a * Math.sin(h2) / Math.cos(this.lat_ts);
        else {
          var n2 = Ys(this.e, Math.sin(h2));
          s2 = this.x0 + this.a * this.k0 * e2, i2 = this.y0 + this.a * n2 * 0.5 / this.k0;
        }
        return t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2;
        return this.sphere ? (s2 = Ht(this.long0 + t2.x / this.a / Math.cos(this.lat_ts)), i2 = Math.asin(t2.y / this.a * Math.cos(this.lat_ts))) : (i2 = li(this.e, 2 * t2.y * this.k0 / this.a), s2 = Ht(this.long0 + t2.x / (this.a * this.k0))), t2.x = s2, t2.y = i2, t2;
      }, names: ["cea"] }, ci = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y, a2 = Ht(s2 - this.long0), h2 = Ks(i2 - this.lat0);
        return t2.x = this.x0 + this.a * a2 * this.rc, t2.y = this.y0 + this.a * h2, t2;
      }, inverse: function(t2) {
        var s2 = t2.x, i2 = t2.y;
        return t2.x = Ht(this.long0 + (s2 - this.x0) / (this.a * this.rc)), t2.y = Ks(this.lat0 + (i2 - this.y0) / this.a), t2;
      }, names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"] }, Mi = 20, fi = { init: function() {
        this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Qs(this.es), this.e1 = Ws(this.es), this.e2 = Hs(this.es), this.e3 = Xs(this.es), this.ml0 = this.a * Us(this.e0, this.e1, this.e2, this.e3, this.lat0);
      }, forward: function(t2) {
        var s2, i2, a2, h2 = t2.x, e2 = t2.y, n2 = Ht(h2 - this.long0);
        if (a2 = n2 * Math.sin(e2), this.sphere)
          Math.abs(e2) <= wt ? (s2 = this.a * n2, i2 = -1 * this.a * this.lat0) : (s2 = this.a * Math.sin(a2) / Math.tan(e2), i2 = this.a * (Ks(e2 - this.lat0) + (1 - Math.cos(a2)) / Math.tan(e2)));
        else if (Math.abs(e2) <= wt)
          s2 = this.a * n2, i2 = -1 * this.ml0;
        else {
          var r2 = Js(this.a, this.e, Math.sin(e2)) / Math.tan(e2);
          s2 = r2 * Math.sin(a2), i2 = this.a * Us(this.e0, this.e1, this.e2, this.e3, e2) - this.ml0 + r2 * (1 - Math.cos(a2));
        }
        return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2, l2;
        if (a2 = t2.x - this.x0, h2 = t2.y - this.y0, this.sphere)
          if (Math.abs(h2 + this.a * this.lat0) <= wt)
            s2 = Ht(a2 / this.a + this.long0), i2 = 0;
          else {
            n2 = this.lat0 + h2 / this.a, r2 = a2 * a2 / this.a / this.a + n2 * n2, o2 = n2;
            var u2;
            for (e2 = Mi; e2; --e2)
              if (u2 = Math.tan(o2), l2 = -1 * (n2 * (o2 * u2 + 1) - o2 - 0.5 * (o2 * o2 + r2) * u2) / ((o2 - n2) / u2 - 1), o2 += l2, Math.abs(l2) <= wt) {
                i2 = o2;
                break;
              }
            s2 = Ht(this.long0 + Math.asin(a2 * Math.tan(o2) / this.a) / Math.sin(i2));
          }
        else if (Math.abs(h2 + this.ml0) <= wt)
          i2 = 0, s2 = Ht(this.long0 + a2 / this.a);
        else {
          n2 = (this.ml0 + h2) / this.a, r2 = a2 * a2 / this.a / this.a + n2 * n2, o2 = n2;
          var c2, M2, f2, d2, p5;
          for (e2 = Mi; e2; --e2)
            if (p5 = this.e * Math.sin(o2), c2 = Math.sqrt(1 - p5 * p5) * Math.tan(o2), M2 = this.a * Us(this.e0, this.e1, this.e2, this.e3, o2), f2 = this.e0 - 2 * this.e1 * Math.cos(2 * o2) + 4 * this.e2 * Math.cos(4 * o2) - 6 * this.e3 * Math.cos(6 * o2), d2 = M2 / this.a, l2 = (n2 * (c2 * d2 + 1) - d2 - 0.5 * c2 * (d2 * d2 + r2)) / (this.es * Math.sin(2 * o2) * (d2 * d2 + r2 - 2 * n2 * d2) / (4 * c2) + (n2 - d2) * (c2 * f2 - 2 / Math.sin(2 * o2)) - f2), o2 -= l2, Math.abs(l2) <= wt) {
              i2 = o2;
              break;
            }
          c2 = Math.sqrt(1 - this.es * Math.pow(Math.sin(i2), 2)) * Math.tan(i2), s2 = Ht(this.long0 + Math.asin(a2 * c2 / this.a) / Math.sin(i2));
        }
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["Polyconic", "poly"] }, di = { init: function() {
        this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
      }, forward: function(t2) {
        var s2, i2 = t2.x, a2 = t2.y - this.lat0, h2 = i2 - this.long0, e2 = a2 / yt * 1e-5, n2 = h2, r2 = 1, o2 = 0;
        for (s2 = 1; s2 <= 10; s2++)
          r2 *= e2, o2 += this.A[s2] * r2;
        var l2, u2 = o2, c2 = n2, M2 = 1, f2 = 0, d2 = 0, p5 = 0;
        for (s2 = 1; s2 <= 6; s2++)
          l2 = f2 * u2 + M2 * c2, M2 = M2 * u2 - f2 * c2, f2 = l2, d2 = d2 + this.B_re[s2] * M2 - this.B_im[s2] * f2, p5 = p5 + this.B_im[s2] * M2 + this.B_re[s2] * f2;
        return t2.x = p5 * this.a + this.x0, t2.y = d2 * this.a + this.y0, t2;
      }, inverse: function(t2) {
        var s2, i2, a2 = t2.x, h2 = t2.y, e2 = a2 - this.x0, n2 = (h2 - this.y0) / this.a, r2 = e2 / this.a, o2 = 1, l2 = 0, u2 = 0, c2 = 0;
        for (s2 = 1; s2 <= 6; s2++)
          i2 = l2 * n2 + o2 * r2, o2 = o2 * n2 - l2 * r2, l2 = i2, u2 = u2 + this.C_re[s2] * o2 - this.C_im[s2] * l2, c2 = c2 + this.C_im[s2] * o2 + this.C_re[s2] * l2;
        for (var M2 = 0; M2 < this.iterations; M2++) {
          var f2, d2 = u2, p5 = c2, m2 = n2, _2 = r2;
          for (s2 = 2; s2 <= 6; s2++)
            f2 = p5 * u2 + d2 * c2, d2 = d2 * u2 - p5 * c2, p5 = f2, m2 += (s2 - 1) * (this.B_re[s2] * d2 - this.B_im[s2] * p5), _2 += (s2 - 1) * (this.B_im[s2] * d2 + this.B_re[s2] * p5);
          d2 = 1, p5 = 0;
          var y2 = this.B_re[1], x2 = this.B_im[1];
          for (s2 = 2; s2 <= 6; s2++)
            f2 = p5 * u2 + d2 * c2, d2 = d2 * u2 - p5 * c2, p5 = f2, y2 += s2 * (this.B_re[s2] * d2 - this.B_im[s2] * p5), x2 += s2 * (this.B_im[s2] * d2 + this.B_re[s2] * p5);
          var g2 = y2 * y2 + x2 * x2;
          u2 = (m2 * y2 + _2 * x2) / g2, c2 = (_2 * y2 - m2 * x2) / g2;
        }
        var v2 = u2, b2 = c2, w2 = 1, N2 = 0;
        for (s2 = 1; s2 <= 9; s2++)
          w2 *= v2, N2 += this.D[s2] * w2;
        var A2 = this.lat0 + N2 * yt * 1e5, E2 = this.long0 + b2;
        return t2.x = E2, t2.y = A2, t2;
      }, names: ["New_Zealand_Map_Grid", "nzmg"] }, pi = { init: function() {
      }, forward: function(t2) {
        var s2 = t2.x, i2 = t2.y, a2 = Ht(s2 - this.long0), h2 = this.x0 + this.a * a2, e2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i2 / 2.5)) * 1.25;
        return t2.x = h2, t2.y = e2, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2 = Ht(this.long0 + t2.x / this.a), i2 = 2.5 * (Math.atan(Math.exp(0.8 * t2.y / this.a)) - Math.PI / 4);
        return t2.x = s2, t2.y = i2, t2;
      }, names: ["Miller_Cylindrical", "mill"] }, mi = 20, _i = { init: function() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = ys(this.es);
      }, forward: function(t2) {
        var s2, i2, a2 = t2.x, h2 = t2.y;
        if (a2 = Ht(a2 - this.long0), this.sphere) {
          if (this.m)
            for (var e2 = this.n * Math.sin(h2), n2 = mi; n2; --n2) {
              var r2 = (this.m * h2 + Math.sin(h2) - e2) / (this.m + Math.cos(h2));
              if (h2 -= r2, Math.abs(r2) < wt)
                break;
            }
          else
            h2 = 1 !== this.n ? Math.asin(this.n * Math.sin(h2)) : h2;
          s2 = this.a * this.C_x * a2 * (this.m + Math.cos(h2)), i2 = this.a * this.C_y * h2;
        } else {
          var o2 = Math.sin(h2), l2 = Math.cos(h2);
          i2 = this.a * xs(h2, o2, l2, this.en), s2 = this.a * a2 * l2 / Math.sqrt(1 - this.es * o2 * o2);
        }
        return t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2;
        return t2.x -= this.x0, a2 = t2.x / this.a, t2.y -= this.y0, s2 = t2.y / this.a, this.sphere ? (s2 /= this.C_y, a2 /= this.C_x * (this.m + Math.cos(s2)), this.m ? s2 = ni((this.m * s2 + Math.sin(s2)) / this.n) : 1 !== this.n && (s2 = ni(Math.sin(s2) / this.n)), a2 = Ht(a2 + this.long0), s2 = Ks(s2)) : (s2 = gs(t2.y / this.a, this.es, this.en), (h2 = Math.abs(s2)) < xt ? (h2 = Math.sin(s2), i2 = this.long0 + t2.x * Math.sqrt(1 - this.es * h2 * h2) / (this.a * Math.cos(s2)), a2 = Ht(i2)) : h2 - wt < xt && (a2 = this.long0)), t2.x = a2, t2.y = s2, t2;
      }, names: ["Sinusoidal", "sinu"] }, yi = { init: function() {
      }, forward: function(t2) {
        for (var s2 = t2.x, i2 = t2.y, a2 = Ht(s2 - this.long0), h2 = i2, e2 = Math.PI * Math.sin(i2); ; ) {
          var n2 = -(h2 + Math.sin(h2) - e2) / (1 + Math.cos(h2));
          if (h2 += n2, Math.abs(n2) < wt)
            break;
        }
        h2 /= 2, Math.PI / 2 - Math.abs(i2) < wt && (a2 = 0);
        var r2 = 0.900316316158 * this.a * a2 * Math.cos(h2) + this.x0, o2 = 1.4142135623731 * this.a * Math.sin(h2) + this.y0;
        return t2.x = r2, t2.y = o2, t2;
      }, inverse: function(t2) {
        var s2, i2;
        t2.x -= this.x0, t2.y -= this.y0, i2 = t2.y / (1.4142135623731 * this.a), Math.abs(i2) > 0.999999999999 && (i2 = 0.999999999999), s2 = Math.asin(i2);
        var a2 = Ht(this.long0 + t2.x / (0.900316316158 * this.a * Math.cos(s2)));
        a2 < -Math.PI && (a2 = -Math.PI), a2 > Math.PI && (a2 = Math.PI), i2 = (2 * s2 + Math.sin(2 * s2)) / Math.PI, Math.abs(i2) > 1 && (i2 = 1);
        var h2 = Math.asin(i2);
        return t2.x = a2, t2.y = h2, t2;
      }, names: ["Mollweide", "moll"] }, xi = { init: function() {
        Math.abs(this.lat1 + this.lat2) < wt || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Qs(this.es), this.e1 = Ws(this.es), this.e2 = Hs(this.es), this.e3 = Xs(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Qt(this.e, this.sinphi, this.cosphi), this.ml1 = Us(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < wt ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Qt(this.e, this.sinphi, this.cosphi), this.ml2 = Us(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Us(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
      }, forward: function(t2) {
        var s2, i2 = t2.x, a2 = t2.y;
        if (this.sphere)
          s2 = this.a * (this.g - a2);
        else {
          var h2 = Us(this.e0, this.e1, this.e2, this.e3, a2);
          s2 = this.a * (this.g - h2);
        }
        var e2 = this.ns * Ht(i2 - this.long0), n2 = this.x0 + s2 * Math.sin(e2), r2 = this.y0 + this.rh - s2 * Math.cos(e2);
        return t2.x = n2, t2.y = r2, t2;
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0;
        var s2, i2, a2, h2;
        this.ns >= 0 ? (i2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = 1) : (i2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = -1);
        var e2 = 0;
        if (0 !== i2 && (e2 = Math.atan2(s2 * t2.x, s2 * t2.y)), this.sphere)
          return h2 = Ht(this.long0 + e2 / this.ns), a2 = Ks(this.g - i2 / this.a), t2.x = h2, t2.y = a2, t2;
        var n2 = this.g - i2 / this.a;
        return a2 = Vs(n2, this.e0, this.e1, this.e2, this.e3), h2 = Ht(this.long0 + e2 / this.ns), t2.x = h2, t2.y = a2, t2;
      }, names: ["Equidistant_Conic", "eqdc"] }, gi = { init: function() {
        this.R = this.a;
      }, forward: function(t2) {
        var s2, i2, a2 = t2.x, h2 = t2.y, e2 = Ht(a2 - this.long0);
        Math.abs(h2) <= wt && (s2 = this.x0 + this.R * e2, i2 = this.y0);
        var n2 = ni(2 * Math.abs(h2 / Math.PI));
        (Math.abs(e2) <= wt || Math.abs(Math.abs(h2) - xt) <= wt) && (s2 = this.x0, i2 = h2 >= 0 ? this.y0 + Math.PI * this.R * Math.tan(0.5 * n2) : this.y0 + Math.PI * this.R * -Math.tan(0.5 * n2));
        var r2 = 0.5 * Math.abs(Math.PI / e2 - e2 / Math.PI), o2 = r2 * r2, l2 = Math.sin(n2), u2 = Math.cos(n2), c2 = u2 / (l2 + u2 - 1), M2 = c2 * c2, f2 = c2 * (2 / l2 - 1), d2 = f2 * f2, p5 = Math.PI * this.R * (r2 * (c2 - d2) + Math.sqrt(o2 * (c2 - d2) * (c2 - d2) - (d2 + o2) * (M2 - d2))) / (d2 + o2);
        e2 < 0 && (p5 = -p5), s2 = this.x0 + p5;
        var m2 = o2 + c2;
        return p5 = Math.PI * this.R * (f2 * m2 - r2 * Math.sqrt((d2 + o2) * (o2 + 1) - m2 * m2)) / (d2 + o2), i2 = h2 >= 0 ? this.y0 + p5 : this.y0 - p5, t2.x = s2, t2.y = i2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2, M2, f2;
        return t2.x -= this.x0, t2.y -= this.y0, c2 = Math.PI * this.R, a2 = t2.x / c2, h2 = t2.y / c2, e2 = a2 * a2 + h2 * h2, n2 = -Math.abs(h2) * (1 + e2), r2 = n2 - 2 * h2 * h2 + a2 * a2, o2 = -2 * n2 + 1 + 2 * h2 * h2 + e2 * e2, f2 = h2 * h2 / o2 + (2 * r2 * r2 * r2 / o2 / o2 / o2 - 9 * n2 * r2 / o2 / o2) / 27, l2 = (n2 - r2 * r2 / 3 / o2) / o2, u2 = 2 * Math.sqrt(-l2 / 3), c2 = 3 * f2 / l2 / u2, Math.abs(c2) > 1 && (c2 = c2 >= 0 ? 1 : -1), M2 = Math.acos(c2) / 3, i2 = t2.y >= 0 ? (-u2 * Math.cos(M2 + Math.PI / 3) - r2 / 3 / o2) * Math.PI : -(-u2 * Math.cos(M2 + Math.PI / 3) - r2 / 3 / o2) * Math.PI, s2 = Math.abs(a2) < wt ? this.long0 : Ht(this.long0 + Math.PI * (e2 - 1 + Math.sqrt(1 + 2 * (a2 * a2 - h2 * h2) + e2 * e2)) / 2 / a2), t2.x = s2, t2.y = i2, t2;
      }, names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"] }, vi = { init: function() {
        this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2, M2, f2, d2, p5, m2, _2, y2, x2, g2, v2, b2, w2, N2 = t2.x, A2 = t2.y, E2 = Math.sin(t2.y), C2 = Math.cos(t2.y), P2 = Ht(N2 - this.long0);
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= wt ? (t2.x = this.x0 + this.a * (xt - A2) * Math.sin(P2), t2.y = this.y0 - this.a * (xt - A2) * Math.cos(P2), t2) : Math.abs(this.sin_p12 + 1) <= wt ? (t2.x = this.x0 + this.a * (xt + A2) * Math.sin(P2), t2.y = this.y0 + this.a * (xt + A2) * Math.cos(P2), t2) : (y2 = this.sin_p12 * E2 + this.cos_p12 * C2 * Math.cos(P2), m2 = Math.acos(y2), _2 = m2 ? m2 / Math.sin(m2) : 1, t2.x = this.x0 + this.a * _2 * C2 * Math.sin(P2), t2.y = this.y0 + this.a * _2 * (this.cos_p12 * E2 - this.sin_p12 * C2 * Math.cos(P2)), t2) : (s2 = Qs(this.es), i2 = Ws(this.es), a2 = Hs(this.es), h2 = Xs(this.es), Math.abs(this.sin_p12 - 1) <= wt ? (e2 = this.a * Us(s2, i2, a2, h2, xt), n2 = this.a * Us(s2, i2, a2, h2, A2), t2.x = this.x0 + (e2 - n2) * Math.sin(P2), t2.y = this.y0 - (e2 - n2) * Math.cos(P2), t2) : Math.abs(this.sin_p12 + 1) <= wt ? (e2 = this.a * Us(s2, i2, a2, h2, xt), n2 = this.a * Us(s2, i2, a2, h2, A2), t2.x = this.x0 + (e2 + n2) * Math.sin(P2), t2.y = this.y0 + (e2 + n2) * Math.cos(P2), t2) : (r2 = E2 / C2, o2 = Js(this.a, this.e, this.sin_p12), l2 = Js(this.a, this.e, E2), u2 = Math.atan((1 - this.es) * r2 + this.es * o2 * this.sin_p12 / (l2 * C2)), c2 = Math.atan2(Math.sin(P2), this.cos_p12 * Math.tan(u2) - this.sin_p12 * Math.cos(P2)), x2 = 0 === c2 ? Math.asin(this.cos_p12 * Math.sin(u2) - this.sin_p12 * Math.cos(u2)) : Math.abs(Math.abs(c2) - Math.PI) <= wt ? -Math.asin(this.cos_p12 * Math.sin(u2) - this.sin_p12 * Math.cos(u2)) : Math.asin(Math.sin(P2) * Math.cos(u2) / Math.sin(c2)), M2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es), f2 = this.e * this.cos_p12 * Math.cos(c2) / Math.sqrt(1 - this.es), d2 = M2 * f2, p5 = f2 * f2, g2 = x2 * x2, v2 = g2 * x2, b2 = v2 * x2, w2 = b2 * x2, m2 = o2 * x2 * (1 - g2 * p5 * (1 - p5) / 6 + v2 / 8 * d2 * (1 - 2 * p5) + b2 / 120 * (p5 * (4 - 7 * p5) - 3 * M2 * M2 * (1 - 7 * p5)) - w2 / 48 * d2), t2.x = this.x0 + m2 * Math.sin(c2), t2.y = this.y0 + m2 * Math.cos(c2), t2));
      }, inverse: function(t2) {
        t2.x -= this.x0, t2.y -= this.y0;
        var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2, c2, M2, f2, d2, p5, m2, _2, y2, x2, g2, v2, b2, w2, N2;
        if (this.sphere) {
          if ((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) > 2 * xt * this.a)
            return;
          return i2 = s2 / this.a, a2 = Math.sin(i2), h2 = Math.cos(i2), e2 = this.long0, Math.abs(s2) <= wt ? n2 = this.lat0 : (n2 = ni(h2 * this.sin_p12 + t2.y * a2 * this.cos_p12 / s2), r2 = Math.abs(this.lat0) - xt, e2 = Ht(Math.abs(r2) <= wt ? this.lat0 >= 0 ? this.long0 + Math.atan2(t2.x, -t2.y) : this.long0 - Math.atan2(-t2.x, t2.y) : this.long0 + Math.atan2(t2.x * a2, s2 * this.cos_p12 * h2 - t2.y * this.sin_p12 * a2))), t2.x = e2, t2.y = n2, t2;
        }
        return o2 = Qs(this.es), l2 = Ws(this.es), u2 = Hs(this.es), c2 = Xs(this.es), Math.abs(this.sin_p12 - 1) <= wt ? (M2 = this.a * Us(o2, l2, u2, c2, xt), s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), f2 = M2 - s2, n2 = Vs(f2 / this.a, o2, l2, u2, c2), e2 = Ht(this.long0 + Math.atan2(t2.x, -1 * t2.y)), t2.x = e2, t2.y = n2, t2) : Math.abs(this.sin_p12 + 1) <= wt ? (M2 = this.a * Us(o2, l2, u2, c2, xt), s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), f2 = s2 - M2, n2 = Vs(f2 / this.a, o2, l2, u2, c2), e2 = Ht(this.long0 + Math.atan2(t2.x, t2.y)), t2.x = e2, t2.y = n2, t2) : (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), m2 = Math.atan2(t2.x, t2.y), d2 = Js(this.a, this.e, this.sin_p12), _2 = Math.cos(m2), y2 = this.e * this.cos_p12 * _2, x2 = -y2 * y2 / (1 - this.es), g2 = 3 * this.es * (1 - x2) * this.sin_p12 * this.cos_p12 * _2 / (1 - this.es), v2 = s2 / d2, b2 = v2 - x2 * (1 + x2) * Math.pow(v2, 3) / 6 - g2 * (1 + 3 * x2) * Math.pow(v2, 4) / 24, w2 = 1 - x2 * b2 * b2 / 2 - v2 * b2 * b2 * b2 / 6, p5 = Math.asin(this.sin_p12 * Math.cos(b2) + this.cos_p12 * Math.sin(b2) * _2), e2 = Ht(this.long0 + Math.asin(Math.sin(m2) * Math.sin(b2) / Math.cos(p5))), N2 = Math.sin(p5), n2 = Math.atan2((N2 - this.es * w2 * this.sin_p12) * Math.tan(p5), N2 * (1 - this.es)), t2.x = e2, t2.y = n2, t2);
      }, names: ["Azimuthal_Equidistant", "aeqd"] }, bi = { init: function() {
        this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y;
        return a2 = Ht(o2 - this.long0), s2 = Math.sin(l2), i2 = Math.cos(l2), h2 = Math.cos(a2), ((e2 = this.sin_p14 * s2 + this.cos_p14 * i2 * h2) > 0 || Math.abs(e2) <= wt) && (n2 = 1 * this.a * i2 * Math.sin(a2), r2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2)), t2.x = n2, t2.y = r2, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2;
        return t2.x -= this.x0, t2.y -= this.y0, s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), i2 = ni(s2 / this.a), a2 = Math.sin(i2), h2 = Math.cos(i2), n2 = this.long0, Math.abs(s2) <= wt ? (r2 = this.lat0, t2.x = n2, t2.y = r2, t2) : (r2 = ni(h2 * this.sin_p14 + t2.y * a2 * this.cos_p14 / s2), e2 = Math.abs(this.lat0) - xt, Math.abs(e2) <= wt ? (n2 = Ht(this.lat0 >= 0 ? this.long0 + Math.atan2(t2.x, -t2.y) : this.long0 - Math.atan2(-t2.x, t2.y)), t2.x = n2, t2.y = r2, t2) : (n2 = Ht(this.long0 + Math.atan2(t2.x * a2, s2 * this.cos_p14 * h2 - t2.y * this.sin_p14 * a2)), t2.x = n2, t2.y = r2, t2));
      }, names: ["ortho"] }, wi = { FRONT: 1, RIGHT: 2, BACK: 3, LEFT: 4, TOP: 5, BOTTOM: 6 }, Ni = { AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4 }, Ai = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= xt - Et / 2 ? this.face = wi.TOP : this.lat0 <= -(xt - Et / 2) ? this.face = wi.BOTTOM : Math.abs(this.long0) <= Et ? this.face = wi.FRONT : Math.abs(this.long0) <= xt + Et ? this.face = this.long0 > 0 ? wi.RIGHT : wi.LEFT : this.face = wi.BACK, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2 = { x: 0, y: 0 }, o2 = { value: 0 };
        if (t2.x -= this.long0, s2 = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t2.y)) : t2.y, i2 = t2.x, this.face === wi.TOP)
          h2 = xt - s2, i2 >= Et && i2 <= xt + Et ? (o2.value = Ni.AREA_0, a2 = i2 - xt) : i2 > xt + Et || i2 <= -(xt + Et) ? (o2.value = Ni.AREA_1, a2 = i2 > 0 ? i2 - Pt : i2 + Pt) : i2 > -(xt + Et) && i2 <= -Et ? (o2.value = Ni.AREA_2, a2 = i2 + xt) : (o2.value = Ni.AREA_3, a2 = i2);
        else if (this.face === wi.BOTTOM)
          h2 = xt + s2, i2 >= Et && i2 <= xt + Et ? (o2.value = Ni.AREA_0, a2 = -i2 + xt) : i2 < Et && i2 >= -Et ? (o2.value = Ni.AREA_1, a2 = -i2) : i2 < -Et && i2 >= -(xt + Et) ? (o2.value = Ni.AREA_2, a2 = -i2 - xt) : (o2.value = Ni.AREA_3, a2 = i2 > 0 ? -i2 + Pt : -i2 - Pt);
        else {
          var l2, u2, c2, M2, f2, d2;
          this.face === wi.RIGHT ? i2 = ct(i2, +xt) : this.face === wi.BACK ? i2 = ct(i2, +Pt) : this.face === wi.LEFT && (i2 = ct(i2, -xt)), M2 = Math.sin(s2), f2 = Math.cos(s2), d2 = Math.sin(i2), l2 = f2 * Math.cos(i2), u2 = f2 * d2, c2 = M2, this.face === wi.FRONT ? a2 = ut(h2 = Math.acos(l2), c2, u2, o2) : this.face === wi.RIGHT ? a2 = ut(h2 = Math.acos(u2), c2, -l2, o2) : this.face === wi.BACK ? a2 = ut(h2 = Math.acos(-l2), c2, -u2, o2) : this.face === wi.LEFT ? a2 = ut(h2 = Math.acos(-u2), c2, l2, o2) : (h2 = a2 = 0, o2.value = Ni.AREA_0);
        }
        return n2 = Math.atan(12 / Pt * (a2 + Math.acos(Math.sin(a2) * Math.cos(Et)) - xt)), e2 = Math.sqrt((1 - Math.cos(h2)) / (Math.cos(n2) * Math.cos(n2)) / (1 - Math.cos(Math.atan(1 / Math.cos(a2))))), o2.value === Ni.AREA_1 ? n2 += xt : o2.value === Ni.AREA_2 ? n2 += Pt : o2.value === Ni.AREA_3 && (n2 += 1.5 * Pt), r2.x = e2 * Math.cos(n2), r2.y = e2 * Math.sin(n2), r2.x = r2.x * this.a + this.x0, r2.y = r2.y * this.a + this.y0, t2.x = r2.x, t2.y = r2.y, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2, n2, r2, o2, l2, u2 = { lam: 0, phi: 0 }, c2 = { value: 0 };
        if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, i2 = Math.atan(Math.sqrt(t2.x * t2.x + t2.y * t2.y)), s2 = Math.atan2(t2.y, t2.x), t2.x >= 0 && t2.x >= Math.abs(t2.y) ? c2.value = Ni.AREA_0 : t2.y >= 0 && t2.y >= Math.abs(t2.x) ? (c2.value = Ni.AREA_1, s2 -= xt) : t2.x < 0 && -t2.x >= Math.abs(t2.y) ? (c2.value = Ni.AREA_2, s2 = s2 < 0 ? s2 + Pt : s2 - Pt) : (c2.value = Ni.AREA_3, s2 += xt), l2 = Pt / 12 * Math.tan(s2), e2 = Math.sin(l2) / (Math.cos(l2) - 1 / Math.sqrt(2)), n2 = Math.atan(e2), a2 = Math.cos(s2), h2 = Math.tan(i2), (r2 = 1 - a2 * a2 * h2 * h2 * (1 - Math.cos(Math.atan(1 / Math.cos(n2))))) < -1 ? r2 = -1 : r2 > 1 && (r2 = 1), this.face === wi.TOP)
          o2 = Math.acos(r2), u2.phi = xt - o2, c2.value === Ni.AREA_0 ? u2.lam = n2 + xt : c2.value === Ni.AREA_1 ? u2.lam = n2 < 0 ? n2 + Pt : n2 - Pt : c2.value === Ni.AREA_2 ? u2.lam = n2 - xt : u2.lam = n2;
        else if (this.face === wi.BOTTOM)
          o2 = Math.acos(r2), u2.phi = o2 - xt, c2.value === Ni.AREA_0 ? u2.lam = -n2 + xt : c2.value === Ni.AREA_1 ? u2.lam = -n2 : c2.value === Ni.AREA_2 ? u2.lam = -n2 - xt : u2.lam = n2 < 0 ? -n2 - Pt : -n2 + Pt;
        else {
          var M2, f2, d2;
          l2 = (M2 = r2) * M2, f2 = (l2 += (d2 = l2 >= 1 ? 0 : Math.sqrt(1 - l2) * Math.sin(n2)) * d2) >= 1 ? 0 : Math.sqrt(1 - l2), c2.value === Ni.AREA_1 ? (l2 = f2, f2 = -d2, d2 = l2) : c2.value === Ni.AREA_2 ? (f2 = -f2, d2 = -d2) : c2.value === Ni.AREA_3 && (l2 = f2, f2 = d2, d2 = -l2), this.face === wi.RIGHT ? (l2 = M2, M2 = -f2, f2 = l2) : this.face === wi.BACK ? (M2 = -M2, f2 = -f2) : this.face === wi.LEFT && (l2 = M2, M2 = f2, f2 = -l2), u2.phi = Math.acos(-d2) - xt, u2.lam = Math.atan2(f2, M2), this.face === wi.RIGHT ? u2.lam = ct(u2.lam, -xt) : this.face === wi.BACK ? u2.lam = ct(u2.lam, -Pt) : this.face === wi.LEFT && (u2.lam = ct(u2.lam, +xt));
        }
        if (0 !== this.es) {
          var p5, m2, _2;
          p5 = u2.phi < 0 ? 1 : 0, m2 = Math.tan(u2.phi), _2 = this.b / Math.sqrt(m2 * m2 + this.one_minus_f_squared), u2.phi = Math.atan(Math.sqrt(this.a * this.a - _2 * _2) / (this.one_minus_f * _2)), p5 && (u2.phi = -u2.phi);
        }
        return u2.lam += this.long0, t2.x = u2.lam, t2.y = u2.phi, t2;
      }, names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"] }, Ei = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]], Ci = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]], Pi = 0.8487, Si = 1.3523, Ii = At / 5, Oi = 1 / Ii, ki = 18, qi = function(t2, s2) {
        return t2[0] + s2 * (t2[1] + s2 * (t2[2] + s2 * t2[3]));
      }, Ri = function(t2, s2) {
        return t2[1] + s2 * (2 * t2[2] + 3 * s2 * t2[3]);
      }, Li = { init: function() {
        this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
      }, forward: function(t2) {
        var s2 = Ht(t2.x - this.long0), i2 = Math.abs(t2.y), a2 = Math.floor(i2 * Ii);
        a2 < 0 ? a2 = 0 : a2 >= ki && (a2 = ki - 1), i2 = At * (i2 - Oi * a2);
        var h2 = { x: qi(Ei[a2], i2) * s2, y: qi(Ci[a2], i2) };
        return t2.y < 0 && (h2.y = -h2.y), h2.x = h2.x * this.a * Pi + this.x0, h2.y = h2.y * this.a * Si + this.y0, h2;
      }, inverse: function(t2) {
        var s2 = { x: (t2.x - this.x0) / (this.a * Pi), y: Math.abs(t2.y - this.y0) / (this.a * Si) };
        if (s2.y >= 1)
          s2.x /= Ei[ki][0], s2.y = t2.y < 0 ? -xt : xt;
        else {
          var i2 = Math.floor(s2.y * ki);
          for (i2 < 0 ? i2 = 0 : i2 >= ki && (i2 = ki - 1); ; )
            if (Ci[i2][0] > s2.y)
              --i2;
            else {
              if (!(Ci[i2 + 1][0] <= s2.y))
                break;
              ++i2;
            }
          var a2 = Ci[i2], h2 = 5 * (s2.y - a2[0]) / (Ci[i2 + 1][0] - a2[0]);
          h2 = Mt(function(t3) {
            return (qi(a2, t3) - s2.y) / Ri(a2, t3);
          }, h2, wt, 100), s2.x /= qi(Ei[i2], h2), s2.y = (5 * i2 + h2) * Nt, t2.y < 0 && (s2.y = -s2.y);
        }
        return s2.x = Ht(s2.x + this.long0), s2;
      }, names: ["Robinson", "robin"] }, Ti = { init: function() {
        this.name = "geocent";
      }, forward: function(t2) {
        return k(t2, this.es, this.a);
      }, inverse: function(t2) {
        return q(t2, this.es, this.a, this.b);
      }, names: ["Geocentric", "geocentric", "geocent", "Geocent"] }, Gi = { N_POLE: 0, S_POLE: 1, EQUIT: 2, OBLIQ: 3 }, ji = { h: { def: 1e5, num: true }, azi: { def: 0, num: true, degrees: true }, tilt: { def: 0, num: true, degrees: true }, long0: { def: 0, num: true }, lat0: { def: 0, num: true } }, Bi = { init: function() {
        if (Object.keys(ji).forEach(function(t3) {
          if (void 0 === this[t3])
            this[t3] = ji[t3].def;
          else {
            if (ji[t3].num && isNaN(this[t3]))
              throw new Error("Invalid parameter value, must be numeric " + t3 + " = " + this[t3]);
            ji[t3].num && (this[t3] = parseFloat(this[t3]));
          }
          ji[t3].degrees && (this[t3] = this[t3] * Nt);
        }.bind(this)), Math.abs(Math.abs(this.lat0) - xt) < wt ? this.mode = this.lat0 < 0 ? Gi.S_POLE : Gi.N_POLE : Math.abs(this.lat0) < wt ? this.mode = Gi.EQUIT : (this.mode = Gi.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
          throw new Error("Invalid height");
        this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
        var t2 = this.tilt, s2 = this.azi;
        this.cg = Math.cos(s2), this.sg = Math.sin(s2), this.cw = Math.cos(t2), this.sw = Math.sin(t2);
      }, forward: function(t2) {
        t2.x -= this.long0;
        var s2, i2, a2 = Math.sin(t2.y), h2 = Math.cos(t2.y), e2 = Math.cos(t2.x);
        switch (this.mode) {
          case Gi.OBLIQ:
            i2 = this.sinph0 * a2 + this.cosph0 * h2 * e2;
            break;
          case Gi.EQUIT:
            i2 = h2 * e2;
            break;
          case Gi.S_POLE:
            i2 = -a2;
            break;
          case Gi.N_POLE:
            i2 = a2;
        }
        switch (i2 = this.pn1 / (this.p - i2), s2 = i2 * h2 * Math.sin(t2.x), this.mode) {
          case Gi.OBLIQ:
            i2 *= this.cosph0 * a2 - this.sinph0 * h2 * e2;
            break;
          case Gi.EQUIT:
            i2 *= a2;
            break;
          case Gi.N_POLE:
            i2 *= -h2 * e2;
            break;
          case Gi.S_POLE:
            i2 *= h2 * e2;
        }
        var n2, r2;
        return n2 = i2 * this.cg + s2 * this.sg, r2 = 1 / (n2 * this.sw * this.h1 + this.cw), s2 = (s2 * this.cg - i2 * this.sg) * this.cw * r2, i2 = n2 * r2, t2.x = s2 * this.a, t2.y = i2 * this.a, t2;
      }, inverse: function(t2) {
        t2.x /= this.a, t2.y /= this.a;
        var s2, i2, a2, h2 = { x: t2.x, y: t2.y };
        a2 = 1 / (this.pn1 - t2.y * this.sw), s2 = this.pn1 * t2.x * a2, i2 = this.pn1 * t2.y * this.cw * a2, t2.x = s2 * this.cg + i2 * this.sg, t2.y = i2 * this.cg - s2 * this.sg;
        var e2 = ws(t2.x, t2.y);
        if (Math.abs(e2) < wt)
          h2.x = 0, h2.y = t2.y;
        else {
          var n2, r2;
          switch (r2 = 1 - e2 * e2 * this.pfact, r2 = (this.p - Math.sqrt(r2)) / (this.pn1 / e2 + e2 / this.pn1), n2 = Math.sqrt(1 - r2 * r2), this.mode) {
            case Gi.OBLIQ:
              h2.y = Math.asin(n2 * this.sinph0 + t2.y * r2 * this.cosph0 / e2), t2.y = (n2 - this.sinph0 * Math.sin(h2.y)) * e2, t2.x *= r2 * this.cosph0;
              break;
            case Gi.EQUIT:
              h2.y = Math.asin(t2.y * r2 / e2), t2.y = n2 * e2, t2.x *= r2;
              break;
            case Gi.N_POLE:
              h2.y = Math.asin(n2), t2.y = -t2.y;
              break;
            case Gi.S_POLE:
              h2.y = -Math.asin(n2);
          }
          h2.x = Math.atan2(t2.x, t2.y);
        }
        return t2.x = h2.x + this.long0, t2.y = h2.y, t2;
      }, names: ["Tilted_Perspective", "tpers"] }, zi = { init: function() {
        if (this.flip_axis = "x" === this.sweep ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
          throw new Error();
        if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, 0 !== this.es) {
          var t2 = 1 - this.es, s2 = 1 / t2;
          this.radius_p = Math.sqrt(t2), this.radius_p2 = t2, this.radius_p_inv2 = s2, this.shape = "ellipse";
        } else
          this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
        this.title || (this.title = "Geostationary Satellite View");
      }, forward: function(t2) {
        var s2, i2, a2, h2, e2 = t2.x, n2 = t2.y;
        if (e2 -= this.long0, "ellipse" === this.shape) {
          n2 = Math.atan(this.radius_p2 * Math.tan(n2));
          var r2 = this.radius_p / ws(this.radius_p * Math.cos(n2), Math.sin(n2));
          if (i2 = r2 * Math.cos(e2) * Math.cos(n2), a2 = r2 * Math.sin(e2) * Math.cos(n2), h2 = r2 * Math.sin(n2), (this.radius_g - i2) * i2 - a2 * a2 - h2 * h2 * this.radius_p_inv2 < 0)
            return t2.x = Number.NaN, t2.y = Number.NaN, t2;
          s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a2 / ws(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a2 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / ws(a2, s2)));
        } else
          "sphere" === this.shape && (s2 = Math.cos(n2), i2 = Math.cos(e2) * s2, a2 = Math.sin(e2) * s2, h2 = Math.sin(n2), s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a2 / ws(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a2 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / ws(a2, s2))));
        return t2.x = t2.x * this.a, t2.y = t2.y * this.a, t2;
      }, inverse: function(t2) {
        var s2, i2, a2, h2, e2 = -1, n2 = 0, r2 = 0;
        if (t2.x = t2.x / this.a, t2.y = t2.y / this.a, "ellipse" === this.shape) {
          this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * ws(1, r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * ws(1, n2));
          var o2 = r2 / this.radius_p;
          if (s2 = n2 * n2 + o2 * o2 + e2 * e2, i2 = 2 * this.radius_g * e2, (a2 = i2 * i2 - 4 * s2 * this.C) < 0)
            return t2.x = Number.NaN, t2.y = Number.NaN, t2;
          h2 = (-i2 - Math.sqrt(a2)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2), t2.y = Math.atan(this.radius_p_inv2 * Math.tan(t2.y));
        } else if ("sphere" === this.shape) {
          if (this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * Math.sqrt(1 + r2 * r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * Math.sqrt(1 + n2 * n2)), s2 = n2 * n2 + r2 * r2 + e2 * e2, i2 = 2 * this.radius_g * e2, (a2 = i2 * i2 - 4 * s2 * this.C) < 0)
            return t2.x = Number.NaN, t2.y = Number.NaN, t2;
          h2 = (-i2 - Math.sqrt(a2)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2);
        }
        return t2.x = t2.x + this.long0, t2;
      }, names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"] };
      return W.defaultDatum = "WGS84", W.Proj = Projection2, W.WGS84 = new W.Proj("WGS84"), W.Point = Point2, W.toPoint = es, W.defs = o, W.nadgrid = function(t2, s2) {
        var i2 = new DataView(s2), a2 = N(i2), h2 = A(i2, a2), e2 = { header: h2, subgrids: C(i2, h2, a2) };
        return is[t2] = e2, e2;
      }, W.transform = D, W.mgrs = ms, W.version = "2.9.2", function(proj42) {
        proj42.Proj.projections.add(vs), proj42.Proj.projections.add(Is), proj42.Proj.projections.add(ks), proj42.Proj.projections.add(Ts), proj42.Proj.projections.add(Gs), proj42.Proj.projections.add(js), proj42.Proj.projections.add(zs), proj42.Proj.projections.add(Fs), proj42.Proj.projections.add(Ds), proj42.Proj.projections.add(Zs), proj42.Proj.projections.add(ei), proj42.Proj.projections.add(ri), proj42.Proj.projections.add(oi), proj42.Proj.projections.add(ui), proj42.Proj.projections.add(ci), proj42.Proj.projections.add(fi), proj42.Proj.projections.add(di), proj42.Proj.projections.add(pi), proj42.Proj.projections.add(_i), proj42.Proj.projections.add(yi), proj42.Proj.projections.add(xi), proj42.Proj.projections.add(gi), proj42.Proj.projections.add(vi), proj42.Proj.projections.add(bi), proj42.Proj.projections.add(Ai), proj42.Proj.projections.add(Li), proj42.Proj.projections.add(Ti), proj42.Proj.projections.add(Bi), proj42.Proj.projections.add(zi);
      }(W), W;
    });
  }
});

// node_modules/rbush/rbush.min.js
var require_rbush_min = __commonJS({
  "node_modules/rbush/rbush.min.js"(exports, module) {
    !function(t, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
    }(exports, function() {
      "use strict";
      function t(t2, r2, e2, a2, h2) {
        !function t3(n2, r3, e3, a3, h3) {
          for (; a3 > e3; ) {
            if (a3 - e3 > 600) {
              var o2 = a3 - e3 + 1, s2 = r3 - e3 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e3, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
              t3(n2, r3, m2, c2, h3);
            }
            var p5 = n2[r3], d2 = e3, x = a3;
            for (i(n2, e3, r3), h3(n2[a3], p5) > 0 && i(n2, e3, a3); d2 < x; ) {
              for (i(n2, d2, x), d2++, x--; h3(n2[d2], p5) < 0; )
                d2++;
              for (; h3(n2[x], p5) > 0; )
                x--;
            }
            0 === h3(n2[e3], p5) ? i(n2, e3, x) : i(n2, ++x, a3), x <= r3 && (e3 = x + 1), r3 <= x && (a3 = x - 1);
          }
        }(t2, r2, e2 || 0, a2 || t2.length - 1, h2 || n);
      }
      function i(t2, i2, n2) {
        var r2 = t2[i2];
        t2[i2] = t2[n2], t2[n2] = r2;
      }
      function n(t2, i2) {
        return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
      }
      var r = function(t2) {
        void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function e(t2, i2, n2) {
        if (!n2)
          return i2.indexOf(t2);
        for (var r2 = 0; r2 < i2.length; r2++)
          if (n2(t2, i2[r2]))
            return r2;
        return -1;
      }
      function a(t2, i2) {
        h(t2, 0, t2.children.length, i2, t2);
      }
      function h(t2, i2, n2, r2, e2) {
        e2 || (e2 = p(null)), e2.minX = 1 / 0, e2.minY = 1 / 0, e2.maxX = -1 / 0, e2.maxY = -1 / 0;
        for (var a2 = i2; a2 < n2; a2++) {
          var h2 = t2.children[a2];
          o(e2, t2.leaf ? r2(h2) : h2);
        }
        return e2;
      }
      function o(t2, i2) {
        return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
      }
      function s(t2, i2) {
        return t2.minX - i2.minX;
      }
      function l(t2, i2) {
        return t2.minY - i2.minY;
      }
      function f(t2) {
        return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
      }
      function u(t2) {
        return t2.maxX - t2.minX + (t2.maxY - t2.minY);
      }
      function m(t2, i2) {
        return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
      }
      function c(t2, i2) {
        return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
      }
      function p(t2) {
        return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function d(i2, n2, r2, e2, a2) {
        for (var h2 = [n2, r2]; h2.length; )
          if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e2)) {
            var o2 = n2 + Math.ceil((r2 - n2) / e2 / 2) * e2;
            t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
          }
      }
      return r.prototype.all = function() {
        return this._all(this.data, []);
      }, r.prototype.search = function(t2) {
        var i2 = this.data, n2 = [];
        if (!c(t2, i2))
          return n2;
        for (var r2 = this.toBBox, e2 = []; i2; ) {
          for (var a2 = 0; a2 < i2.children.length; a2++) {
            var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
            c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e2.push(h2));
          }
          i2 = e2.pop();
        }
        return n2;
      }, r.prototype.collides = function(t2) {
        var i2 = this.data;
        if (!c(t2, i2))
          return false;
        for (var n2 = []; i2; ) {
          for (var r2 = 0; r2 < i2.children.length; r2++) {
            var e2 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e2) : e2;
            if (c(t2, a2)) {
              if (i2.leaf || m(t2, a2))
                return true;
              n2.push(e2);
            }
          }
          i2 = n2.pop();
        }
        return false;
      }, r.prototype.load = function(t2) {
        if (!t2 || !t2.length)
          return this;
        if (t2.length < this._minEntries) {
          for (var i2 = 0; i2 < t2.length; i2++)
            this.insert(t2[i2]);
          return this;
        }
        var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
        if (this.data.children.length)
          if (this.data.height === n2.height)
            this._splitRoot(this.data, n2);
          else {
            if (this.data.height < n2.height) {
              var r2 = this.data;
              this.data = n2, n2 = r2;
            }
            this._insert(n2, this.data.height - n2.height - 1, true);
          }
        else
          this.data = n2;
        return this;
      }, r.prototype.insert = function(t2) {
        return t2 && this._insert(t2, this.data.height - 1), this;
      }, r.prototype.clear = function() {
        return this.data = p([]), this;
      }, r.prototype.remove = function(t2, i2) {
        if (!t2)
          return this;
        for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
          if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
            var f2 = e(t2, h2.children, i2);
            if (-1 !== f2)
              return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
          }
          a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
        }
        return this;
      }, r.prototype.toBBox = function(t2) {
        return t2;
      }, r.prototype.compareMinX = function(t2, i2) {
        return t2.minX - i2.minX;
      }, r.prototype.compareMinY = function(t2, i2) {
        return t2.minY - i2.minY;
      }, r.prototype.toJSON = function() {
        return this.data;
      }, r.prototype.fromJSON = function(t2) {
        return this.data = t2, this;
      }, r.prototype._all = function(t2, i2) {
        for (var n2 = []; t2; )
          t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
        return i2;
      }, r.prototype._build = function(t2, i2, n2, r2) {
        var e2, h2 = n2 - i2 + 1, o2 = this._maxEntries;
        if (h2 <= o2)
          return a(e2 = p(t2.slice(i2, n2 + 1)), this.toBBox), e2;
        r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e2 = p([])).leaf = false, e2.height = r2;
        var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
        d(t2, i2, n2, l2, this.compareMinX);
        for (var f2 = i2; f2 <= n2; f2 += l2) {
          var u2 = Math.min(f2 + l2 - 1, n2);
          d(t2, f2, u2, s2, this.compareMinY);
          for (var m2 = f2; m2 <= u2; m2 += s2) {
            var c2 = Math.min(m2 + s2 - 1, u2);
            e2.children.push(this._build(t2, m2, c2, r2 - 1));
          }
        }
        return a(e2, this.toBBox), e2;
      }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
        for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
          for (var e2 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
            var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
            u2 < a2 ? (a2 = u2, e2 = l2 < e2 ? l2 : e2, h2 = s2) : u2 === a2 && l2 < e2 && (e2 = l2, h2 = s2);
          }
          i2 = h2 || i2.children[0];
        }
        var m2, c2;
        return i2;
      }, r.prototype._insert = function(t2, i2, n2) {
        var r2 = n2 ? t2 : this.toBBox(t2), e2 = [], a2 = this._chooseSubtree(r2, this.data, i2, e2);
        for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e2[i2].children.length > this._maxEntries; )
          this._split(e2, i2), i2--;
        this._adjustParentBBoxes(r2, e2, i2);
      }, r.prototype._split = function(t2, i2) {
        var n2 = t2[i2], r2 = n2.children.length, e2 = this._minEntries;
        this._chooseSplitAxis(n2, e2, r2);
        var h2 = this._chooseSplitIndex(n2, e2, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
        o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
      }, r.prototype._splitRoot = function(t2, i2) {
        this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
      }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
        for (var r2, e2, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p5 = i2; p5 <= n2 - i2; p5++) {
          var d2 = h(t2, 0, p5, this.toBBox), x = h(t2, p5, n2, this.toBBox), v = (e2 = d2, a2 = x, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e2.minX, a2.minX), s2 = Math.max(e2.minY, a2.minY), l2 = Math.min(e2.maxX, a2.maxX), u2 = Math.min(e2.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x);
          v < m2 ? (m2 = v, r2 = p5, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p5);
        }
        return r2 || n2 - i2;
      }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
        var r2 = t2.leaf ? this.compareMinX : s, e2 = t2.leaf ? this.compareMinY : l;
        this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e2) && t2.children.sort(r2);
      }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
        t2.children.sort(r2);
        for (var e2 = this.toBBox, a2 = h(t2, 0, i2, e2), s2 = h(t2, n2 - i2, n2, e2), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
          var m2 = t2.children[f2];
          o(a2, t2.leaf ? e2(m2) : m2), l2 += u(a2);
        }
        for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
          var p5 = t2.children[c2];
          o(s2, t2.leaf ? e2(p5) : p5), l2 += u(s2);
        }
        return l2;
      }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
        for (var r2 = n2; r2 >= 0; r2--)
          o(i2[r2], t2);
      }, r.prototype._condense = function(t2) {
        for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
          0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
      }, r;
    });
  }
});

// node_modules/ol/events/Event.js
var BaseEvent = class {
  constructor(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
};
function stopPropagation(evt) {
  evt.stopPropagation();
}
var Event_default = BaseEvent;

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default = {
  PROPERTYCHANGE: "propertychange"
};

// node_modules/ol/Disposable.js
var Disposable = class {
  constructor() {
    this.disposed = false;
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }
  disposeInternal() {
  }
};
var Disposable_default = Disposable;

// node_modules/ol/array.js
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}

// node_modules/ol/events/Target.js
var Target = class extends Disposable_default {
  constructor(target) {
    super();
    this.eventTarget_ = target;
    this.pendingRemovals_ = null;
    this.dispatching_ = null;
    this.listeners_ = null;
  }
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }
  dispatchEvent(event) {
    const isString = typeof event === "string";
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    const evt = isString ? new Event_default(event) : event;
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ("handleEvent" in listeners[i]) {
        propagate = listeners[i].handleEvent(evt);
      } else {
        propagate = listeners[i].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }
  disposeInternal() {
    this.listeners_ && clear(this.listeners_);
  }
  getListeners(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  }
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  }
  removeEventListener(type, listener) {
    const listeners = this.listeners_ && this.listeners_[type];
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          listeners[index] = VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index, 1);
          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  }
};
var Target_default = Target;

// node_modules/ol/events/EventType.js
var EventType_default = {
  CHANGE: "change",
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}

// node_modules/ol/Observable.js
var Observable = class extends Target_default {
  constructor() {
    super();
    this.on = this.onInternal;
    this.once = this.onceInternal;
    this.un = this.unInternal;
    this.revision_ = 0;
  }
  changed() {
    ++this.revision_;
    this.dispatchEvent(EventType_default.CHANGE);
  }
  getRevision() {
    return this.revision_;
  }
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = listen(this, type[i], listener);
      }
      return keys;
    }
    return listen(this, type, listener);
  }
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = listenOnce(this, type[i], listener);
      }
    } else {
      key = listenOnce(this, type, listener);
    }
    listener.ol_key = key;
    return key;
  }
  unInternal(type, listener) {
    const key = listener.ol_key;
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
};
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(key);
  }
}
var Observable_default = Observable;

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
var uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

// node_modules/ol/Object.js
var ObjectEvent = class extends Event_default {
  constructor(type, key, oldValue) {
    super(type);
    this.key = key;
    this.oldValue = oldValue;
  }
};
var BaseObject = class extends Observable_default {
  constructor(values) {
    super();
    this.on;
    this.once;
    this.un;
    getUid(this);
    this.values_ = null;
    if (values !== void 0) {
      this.setProperties(values);
    }
  }
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  hasProperties() {
    return !!this.values_;
  }
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType_default.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
};
var Object_default = BaseObject;

// node_modules/ol/AssertionError.js
var messages = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection",
  69: "`width` or `height` cannot be provided together with `scale`"
};
var AssertionError = class extends Error {
  constructor(code) {
    const message = messages[code];
    super(message);
    this.code = code;
    this.name = "AssertionError";
    this.message = message;
  }
};
var AssertionError_default = AssertionError;

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default = {
  ADD: "add",
  REMOVE: "remove"
};

// node_modules/ol/Collection.js
var Property = {
  LENGTH: "length"
};
var CollectionEvent = class extends Event_default {
  constructor(type, element, index) {
    super(type);
    this.element = element;
    this.index = index;
  }
};
var Collection = class extends Object_default {
  constructor(array, options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options || {};
    this.unique_ = !!options.unique;
    this.array_ = array ? array : [];
    if (this.unique_) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }
    this.updateLength_();
  }
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }
  extend(arr) {
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  }
  forEach(f) {
    const array = this.array_;
    for (let i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  }
  getArray() {
    return this.array_;
  }
  item(index) {
    return this.array_[index];
  }
  getLength() {
    return this.get(Property.LENGTH);
  }
  insertAt(index, elem) {
    if (index < 0 || index > this.getLength()) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType_default.ADD, elem, index)
    );
  }
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  }
  remove(elem) {
    const arr = this.array_;
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return void 0;
  }
  removeAt(index) {
    if (index < 0 || index >= this.getLength()) {
      return void 0;
    }
    const prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
    );
    return prev;
  }
  setAt(index, elem) {
    const n = this.getLength();
    if (index >= n) {
      this.insertAt(index, elem);
      return;
    }
    if (index < 0) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    const prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
    );
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType_default.ADD, elem, index)
    );
  }
  updateLength_() {
    this.set(Property.LENGTH, this.array_.length);
  }
  assertUnique_(elem, except) {
    for (let i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== except) {
        throw new AssertionError_default(58);
      }
    }
  }
};
var Collection_default = Collection;

// node_modules/ol/has.js
var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
var FIREFOX = ua.includes("firefox");
var SAFARI = ua.includes("safari") && !ua.includes("chrom");
var SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
var WEBKIT = ua.includes("webkit") && !ua.includes("edge");
var MAC = ua.includes("macintosh");
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
var PASSIVE_EVENT_LISTENERS = function() {
  let passive = false;
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
}();

// node_modules/ol/asserts.js
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new AssertionError_default(errorCode);
  }
}

// node_modules/ol/transform.js
var tmp_ = new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function set(transform2, a, b, c, d, e, f) {
  transform2[0] = a;
  transform2[1] = b;
  transform2[2] = c;
  transform2[3] = d;
  transform2[4] = e;
  transform2[5] = f;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, 32);
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
var transformStringDiv;
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  const node = transformStringDiv || (transformStringDiv = document.createElement("div"));
  node.style.transform = transformString;
  return node.style.transform;
}

// node_modules/ol/extent/Relationship.js
var Relationship_default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value
  ];
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    assert(false, 13);
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start, end) {
  let intersects2 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects2 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
  }
  return intersects2;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}

// node_modules/ol/color.js
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function fromNamed(color) {
  const el = document.createElement("div");
  el.style.color = color;
  if (el.style.color !== "") {
    document.body.appendChild(el);
    const rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  }
  return "";
}
var fromString = function() {
  const MAX_CACHE_SIZE = 1024;
  const cache2 = {};
  let cacheSize = 0;
  return function(s) {
    let color;
    if (cache2.hasOwnProperty(s)) {
      color = cache2[s];
    } else {
      if (cacheSize >= MAX_CACHE_SIZE) {
        let i = 0;
        for (const key in cache2) {
          if ((i++ & 3) === 0) {
            delete cache2[key];
            --cacheSize;
          }
        }
      }
      color = fromStringInternal_(s);
      cache2[s] = color;
      ++cacheSize;
    }
    return color;
  };
}();
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function fromStringInternal_(s) {
  let r, g, b, a, color;
  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }
  if (HEX_COLOR_RE_.exec(s)) {
    const n = s.length - 1;
    let d;
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    const hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.startsWith("rgba(")) {
    color = s.slice(5, -1).split(",").map(Number);
    normalize(color);
  } else if (s.startsWith("rgb(")) {
    color = s.slice(4, -1).split(",").map(Number);
    color.push(1);
    normalize(color);
  } else {
    assert(false, 14);
  }
  return color;
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString2(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

// node_modules/ol/style/IconImageCache.js
var IconImageCache = class {
  constructor() {
    this.cache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 32;
  }
  clear() {
    this.cache_ = {};
    this.cacheSize_ = 0;
  }
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  }
  get(src, crossOrigin, color) {
    const key = getKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }
  set(src, crossOrigin, color, iconImage) {
    const key = getKey(src, crossOrigin, color);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  }
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
};
function getKey(src, crossOrigin, color) {
  const colorString = color ? asString(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var shared = new IconImageCache();

// node_modules/ol/layer/Property.js
var Property_default = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};

// node_modules/ol/layer/Base.js
var BaseLayer = class extends Object_default {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.background_ = options.background;
    const properties = Object.assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(typeof properties[Property_default.OPACITY] === "number", 64);
    properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[Property_default.Z_INDEX] = options.zIndex;
    properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    this.setProperties(properties);
    this.state_ = null;
  }
  getBackground() {
    return this.background_;
  }
  getClassName() {
    return this.className_;
  }
  getLayerState(managed) {
    const state = this.state_ || {
      layer: this,
      managed: managed === void 0 ? true : managed
    };
    const zIndex = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  }
  getLayersArray(array) {
    return abstract();
  }
  getLayerStatesArray(states) {
    return abstract();
  }
  getExtent() {
    return this.get(Property_default.EXTENT);
  }
  getMaxResolution() {
    return this.get(Property_default.MAX_RESOLUTION);
  }
  getMinResolution() {
    return this.get(Property_default.MIN_RESOLUTION);
  }
  getMinZoom() {
    return this.get(Property_default.MIN_ZOOM);
  }
  getMaxZoom() {
    return this.get(Property_default.MAX_ZOOM);
  }
  getOpacity() {
    return this.get(Property_default.OPACITY);
  }
  getSourceState() {
    return abstract();
  }
  getVisible() {
    return this.get(Property_default.VISIBLE);
  }
  getZIndex() {
    return this.get(Property_default.Z_INDEX);
  }
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }
  setExtent(extent) {
    this.set(Property_default.EXTENT, extent);
  }
  setMaxResolution(maxResolution) {
    this.set(Property_default.MAX_RESOLUTION, maxResolution);
  }
  setMinResolution(minResolution) {
    this.set(Property_default.MIN_RESOLUTION, minResolution);
  }
  setMaxZoom(maxZoom) {
    this.set(Property_default.MAX_ZOOM, maxZoom);
  }
  setMinZoom(minZoom) {
    this.set(Property_default.MIN_ZOOM, minZoom);
  }
  setOpacity(opacity) {
    assert(typeof opacity === "number", 64);
    this.set(Property_default.OPACITY, opacity);
  }
  setVisible(visible) {
    this.set(Property_default.VISIBLE, visible);
  }
  setZIndex(zindex) {
    this.set(Property_default.Z_INDEX, zindex);
  }
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
};
var Base_default = BaseLayer;

// node_modules/ol/render/EventType.js
var EventType_default2 = {
  PRERENDER: "prerender",
  POSTRENDER: "postrender",
  PRECOMPOSE: "precompose",
  POSTCOMPOSE: "postcompose",
  RENDERCOMPLETE: "rendercomplete"
};

// node_modules/ol/ViewHint.js
var ViewHint_default = {
  ANIMATING: 0,
  INTERACTING: 1
};

// node_modules/ol/ViewProperty.js
var ViewProperty_default = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM = 42;
var DEFAULT_TILE_SIZE = 256;

// node_modules/ol/proj/Units.js
var METERS_PER_UNIT = {
  "radians": 6370997 / (2 * Math.PI),
  "degrees": 2 * Math.PI * 6370997 / 360,
  "ft": 0.3048,
  "m": 1,
  "us-ft": 1200 / 3937
};

// node_modules/ol/proj/Projection.js
var Projection = class {
  constructor(options) {
    this.code_ = options.code;
    this.units_ = options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  canWrapX() {
    return this.canWrapX_;
  }
  getCode() {
    return this.code_;
  }
  getExtent() {
    return this.extent_;
  }
  getUnits() {
    return this.units_;
  }
  getMetersPerUnit() {
    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
  }
  getWorldExtent() {
    return this.worldExtent_;
  }
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  isGlobal() {
    return this.global_;
  }
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
var Projection_default = Projection;

// node_modules/ol/proj/epsg3857.js
var RADIUS = 6378137;
var HALF_SIZE = Math.PI * RADIUS;
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
var WORLD_EXTENT = [-180, -85, 180, 85];
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
var EPSG3857Projection = class extends Projection_default {
  constructor(code) {
    super({
      code,
      units: "m",
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      }
    });
  }
};
var PROJECTIONS = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

// node_modules/ol/proj/epsg4326.js
var RADIUS2 = 6378137;
var EXTENT2 = [-180, -90, 180, 90];
var METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
var EPSG4326Projection = class extends Projection_default {
  constructor(code, axisOrientation) {
    super({
      code,
      units: "degrees",
      extent: EXTENT2,
      axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT2,
      worldExtent: EXTENT2
    });
  }
};
var PROJECTIONS2 = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];

// node_modules/ol/proj/projections.js
var cache = {};
function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
  cache[code] = projection;
}

// node_modules/ol/proj/transforms.js
var transforms = {};
function add2(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get2(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}

// node_modules/ol/string.js
function compareVersions(v1, v2) {
  const s1 = ("" + v1).split(".");
  const s2 = ("" + v2).split(".");
  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || "0", 10);
    const n2 = parseInt(s2[i] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}

// node_modules/ol/coordinate.js
function add3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale(coordinate, scale4) {
  coordinate[0] *= scale4;
  coordinate[1] *= scale4;
  return coordinate;
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}

// node_modules/ol/sphere.js
var DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

// node_modules/ol/console.js
var levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
var level = levels.info;
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}

// node_modules/ol/proj.js
var showCoordinateWarning = true;
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add(projection.getCode(), projection);
  add2(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  return typeof projectionLike === "string" ? get(projectionLike) : projectionLike || null;
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add2(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add2(projection1, projection2, forwardTransform);
      add2(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
  return function(input, output, dimension) {
    const length = input.length;
    dimension = dimension !== void 0 ? dimension : 2;
    output = output !== void 0 ? output : new Array(length);
    for (let i = 0; i < length; i += dimension) {
      const point = coordTransform(input.slice(i, i + dimension));
      const pointLength = point.length;
      for (let j = 0, jj = dimension; j < jj; ++j) {
        output[i + j] = j >= pointLength ? input[i + j] : point[j];
      }
    }
    return output;
  };
}
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get3(source);
  const destProj = get3(destination);
  add2(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  add2(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
var userProjection = null;
function getUserProjection() {
  return userProjection;
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceUnits = get3(sourceProjection).getUnits();
  const userUnits = userProjection.getUnits();
  return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[sourceUnits] / METERS_PER_UNIT[userUnits] : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
addCommon();

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return function(center, resolution, size, isMoving, centerShift) {
    if (!center) {
      return void 0;
    }
    if (!resolution && !onlyCenter) {
      return center;
    }
    const viewWidth = onlyCenter ? 0 : size[0] * resolution;
    const viewHeight = onlyCenter ? 0 : size[1] * resolution;
    const shiftX = centerShift ? centerShift[0] : 0;
    const shiftY = centerShift ? centerShift[1] : 0;
    let minX = extent[0] + viewWidth / 2 + shiftX;
    let maxX = extent[2] - viewWidth / 2 + shiftX;
    let minY = extent[1] + viewHeight / 2 + shiftY;
    let maxY = extent[3] - viewHeight / 2 + shiftY;
    if (minX > maxX) {
      minX = (maxX + minX) / 2;
      maxX = minX;
    }
    if (minY > maxY) {
      minY = (maxY + minY) / 2;
      maxY = minY;
    }
    let x = clamp(center[0], minX, maxX);
    let y = clamp(center[1], minY, maxY);
    if (isMoving && smooth && resolution) {
      const ratio = 30 * resolution;
      x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
      y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
    }
    return [x, y];
  };
}
function none(center) {
  return center;
}

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return function(resolution, direction, size, isMoving) {
    if (resolution !== void 0) {
      const maxResolution = resolutions[0];
      const minResolution = resolutions[resolutions.length - 1];
      const cappedMaxRes = maxExtent ? getViewportClampedResolution(
        maxResolution,
        maxExtent,
        size,
        showFullExtent
      ) : maxResolution;
      if (isMoving) {
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      const capped = Math.min(cappedMaxRes, resolution);
      const z = Math.floor(linearFindNearest(resolutions, capped, direction));
      if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
        return resolutions[z + 1];
      }
      return resolutions[z];
    }
    return void 0;
  };
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return function(resolution, direction, size, isMoving) {
    if (resolution !== void 0) {
      const cappedMaxRes = maxExtent ? getViewportClampedResolution(
        maxResolution,
        maxExtent,
        size,
        showFullExtent
      ) : maxResolution;
      if (isMoving) {
        if (!smooth) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      const tolerance = 1e-9;
      const minZoomLevel = Math.ceil(
        Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
      );
      const offset = -direction * (0.5 - tolerance) + 0.5;
      const capped = Math.min(cappedMaxRes, resolution);
      const cappedZoomLevel = Math.floor(
        Math.log(maxResolution / capped) / Math.log(power) + offset
      );
      const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
      const newResolution = maxResolution / Math.pow(power, zoomLevel);
      return clamp(newResolution, minResolution, cappedMaxRes);
    }
    return void 0;
  };
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return function(resolution, direction, size, isMoving) {
    if (resolution !== void 0) {
      const cappedMaxRes = maxExtent ? getViewportClampedResolution(
        maxResolution,
        maxExtent,
        size,
        showFullExtent
      ) : maxResolution;
      if (!smooth || !isMoving) {
        return clamp(resolution, minResolution, cappedMaxRes);
      }
      return getSmoothClampedResolution(
        resolution,
        cappedMaxRes,
        minResolution
      );
    }
    return void 0;
  };
}

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return function(rotation, isMoving) {
    if (isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      rotation = Math.floor(rotation / theta + 0.5) * theta;
      return rotation;
    }
    return void 0;
  };
}
function createSnapToZero(tolerance) {
  tolerance = tolerance || toRadians(5);
  return function(rotation, isMoving) {
    if (isMoving) {
      return rotation;
    }
    if (rotation !== void 0) {
      if (Math.abs(rotation) <= tolerance) {
        return 0;
      }
      return rotation;
    }
    return void 0;
  };
}

// node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset, end, stride, transform2, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate2(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale2(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

// node_modules/ol/geom/Geometry.js
var tmpTransform = create();
var Geometry = class extends Object_default {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, transform2) {
      if (!transform2) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }
      const clone2 = this.clone();
      clone2.applyTransform(transform2);
      return clone2.getSimplifiedGeometry(squaredTolerance);
    });
  }
  simplifyTransformed(squaredTolerance, transform2) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform2
    );
  }
  clone() {
    return abstract();
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return abstract();
  }
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  computeExtent(extent) {
    return abstract();
  }
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent);
  }
  rotate(angle, anchor) {
    abstract();
  }
  scale(sx, sy, anchor) {
    abstract();
  }
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  getType() {
    return abstract();
  }
  applyTransform(transformFn) {
    abstract();
  }
  intersectsExtent(extent) {
    return abstract();
  }
  translate(deltaX, deltaY) {
    abstract();
  }
  transform(source, destination) {
    const sourceProj = get3(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale4 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale4,
        -scale4,
        0,
        0,
        0
      );
      transform2D(
        inCoordinates,
        0,
        inCoordinates.length,
        stride,
        tmpTransform,
        outCoordinates
      );
      return getTransform(sourceProj, destination)(
        inCoordinates,
        outCoordinates,
        stride
      );
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
};
var Geometry_default = Geometry;

// node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = class extends Geometry_default {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates = null;
  }
  computeExtent(extent) {
    return createOrUpdateFromFlatCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  getCoordinates() {
    return abstract();
  }
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  getLayout() {
    return this.layout;
  }
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  getStride() {
    return this.stride;
  }
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  }
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale2(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
};
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return layout;
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return stride;
}
function transformGeom2D(simpleGeometry, transform2, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform2,
    dest
  );
}
var SimpleGeometry_default = SimpleGeometry;

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = end;
  }
  return minSquaredDistance;
}

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance2 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      coordinatesss[i]
    );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

// node_modules/ol/geom/LinearRing.js
var LinearRing = class extends SimpleGeometry_default {
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  getArea() {
    return linearRing(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LinearRing(simplifiedFlatCoordinates, "XY");
  }
  getType() {
    return "LinearRing";
  }
  intersectsExtent(extent) {
    return false;
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var LinearRing_default = LinearRing;

// node_modules/ol/geom/Point.js
var Point = class extends SimpleGeometry_default {
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  clone() {
    const point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  getCoordinates() {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  }
  computeExtent(extent) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
  }
  getType() {
    return "Point";
  }
  intersectsExtent(extent) {
    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var Point_default = Point;

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset,
    end,
    stride
  );
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}

// node_modules/ol/geom/Polygon.js
var Polygon = class extends SimpleGeometry_default {
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  clone() {
    const polygon = new Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  containsXY(x, y) {
    return linearRingsContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }
  getArea() {
    return linearRings(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  getEnds() {
    return this.ends_;
  }
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  getInteriorPoint() {
    return new Point_default(this.getFlatInteriorPoint(), "XYM");
  }
  getLinearRingCount() {
    return this.ends_.length;
  }
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LinearRing_default(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing2 = new LinearRing_default(
        flatCoordinates.slice(offset, end),
        layout
      );
      linearRings2.push(linearRing2);
      offset = end;
    }
    return linearRings2;
  }
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  getType() {
    return "Polygon";
  }
  intersectsExtent(extent) {
    return intersectsLinearRingArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
var Polygon_default = Polygon;
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}

// node_modules/ol/View.js
var DEFAULT_MIN_ZOOM = 0;
var View = class extends Object_default {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = Object.assign({}, options);
    this.hints_ = [0, 0];
    this.animations_ = [];
    this.updateAnimationKey_;
    this.projection_ = createProjection(options.projection, "EPSG:3857");
    this.viewportSize_ = [100, 100];
    this.targetCenter_ = null;
    this.targetResolution_;
    this.targetRotation_;
    this.nextCenter_ = null;
    this.nextResolution_;
    this.nextRotation_;
    this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, this.projection_);
    }
    this.applyOptions_(options);
  }
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in ViewProperty_default) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    const resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== void 0 ? options.center : null
    );
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  }
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return Object.assign({}, options, newOptions);
  }
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = fromUserCoordinate(
          options.center,
          this.getProjection()
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = fromUserCoordinate(
          options.anchor,
          this.getProjection()
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    let start = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = arguments[i];
      const animation = {
        start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint_default.ANIMATING, 1);
    this.updateAnimations_();
  }
  getAnimating() {
    return this.hints_[ViewHint_default.ANIMATING] > 0;
  }
  getInteracting() {
    return this.hints_[ViewHint_default.INTERACTING] > 0;
  }
  cancelAnimations() {
    this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now - animation.start;
        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size,
              true
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(ViewHint_default.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      );
    }
  }
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate(center, rotation - this.getRotation());
      add3(center, anchor);
    }
    return center;
  }
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  }
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w = size[0];
      const h = size[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
      ];
    }
    return size;
  }
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  }
  getCenterInternal() {
    return this.get(ViewProperty_default.CENTER);
  }
  getConstraints() {
    return this.constraints_;
  }
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  getHints(hints) {
    if (hints !== void 0) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }
  calculateExtent(size) {
    const extent = this.calculateExtentInternal(size);
    return toUserExtent(extent, this.getProjection());
  }
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = this.getCenterInternal();
    assert(center, 1);
    const resolution = this.getResolution();
    assert(resolution !== void 0, 2);
    const rotation = this.getRotation();
    assert(rotation !== void 0, 3);
    return getForViewAndSize(center, resolution, rotation, size);
  }
  getMaxResolution() {
    return this.maxResolution_;
  }
  getMinResolution() {
    return this.minResolution_;
  }
  getMaxZoom() {
    return this.getZoomForResolution(this.minResolution_);
  }
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  }
  getMinZoom() {
    return this.getZoomForResolution(this.maxResolution_);
  }
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  }
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  }
  getProjection() {
    return this.projection_;
  }
  getResolution() {
    return this.get(ViewProperty_default.RESOLUTION);
  }
  getResolutions() {
    return this.resolutions_;
  }
  getResolutionForExtent(extent, size) {
    return this.getResolutionForExtentInternal(
      fromUserExtent(extent, this.getProjection()),
      size
    );
  }
  getResolutionForExtentInternal(extent, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = getWidth(extent) / size[0];
    const yResolution = getHeight(extent) / size[1];
    return Math.max(xResolution, yResolution);
  }
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / Math.log(power);
    return function(value) {
      const resolution = maxResolution / Math.pow(power, value * max);
      return resolution;
    };
  }
  getRotation() {
    return this.get(ViewProperty_default.ROTATION);
  }
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / logPower;
    return function(resolution) {
      const value = Math.log(maxResolution / resolution) / logPower / max;
      return value;
    };
  }
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  }
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = this.getCenterInternal();
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  }
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }
  getZoomForResolution(resolution) {
    let offset = this.minZoom_ || 0;
    let max, zoomFactor;
    if (this.resolutions_) {
      const nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }
  getResolutionForZoom(zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }
      const baseLevel = clamp(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2
      );
      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
  }
  fit(geometryOrExtent, options) {
    let geometry;
    assert(
      Array.isArray(geometryOrExtent) || typeof geometryOrExtent.getSimplifiedGeometry === "function",
      24
    );
    if (Array.isArray(geometryOrExtent)) {
      assert(!isEmpty2(geometryOrExtent), 25);
      const extent = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent);
    } else if (geometryOrExtent.getType() === "Circle") {
      const extent = fromUserExtent(
        geometryOrExtent.getExtent(),
        this.getProjection()
      );
      geometry = fromExtent(extent);
      geometry.rotate(this.getRotation(), getCenter(extent));
    } else {
      const userProjection2 = getUserProjection();
      if (userProjection2) {
        geometry = geometryOrExtent.clone().transform(userProjection2, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, options);
  }
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = Infinity;
    let minRotY = Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== void 0 ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    const rotatedExtent = this.rotatedExtentForGeometry(geometry);
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal(
        {
          resolution,
          center,
          duration: options.duration,
          easing: options.easing
        },
        callback
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }
  centerOn(coordinate, size, position) {
    this.centerOnInternal(
      fromUserCoordinate(coordinate, this.getProjection()),
      size,
      position
    );
  }
  centerOnInternal(coordinate, size, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size,
        position,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  }
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  adjustCenter(deltaCoordinates) {
    const center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  adjustResolution(ratio, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = fromUserCoordinate(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }
  setCenter(center) {
    this.setCenterInternal(
      center ? fromUserCoordinate(center, this.getProjection()) : center
    );
  }
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving
    );
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size,
      isMoving
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
      this.set(ViewProperty_default.ROTATION, newRotation);
    }
    if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
      this.set(ViewProperty_default.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
      this.set(ViewProperty_default.CENTER, newCenter);
    }
    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  }
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== void 0 ? duration : 200;
    const direction = resolutionDirection || 0;
    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration,
        easing: easeOut,
        anchor
      });
    }
  }
  beginInteraction() {
    this.resolveConstraints(0);
    this.setHint(ViewHint_default.INTERACTING, 1);
  }
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(ViewHint_default.INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size
    );
  }
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction)
    );
  }
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  }
};
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? 360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var View_default = View;

// node_modules/ol/layer/Layer.js
var Layer = class extends Base_default {
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.mapPrecomposeKey_ = null;
    this.mapRenderKey_ = null;
    this.sourceChangeKey_ = null;
    this.renderer_ = null;
    this.sourceReady_ = false;
    this.rendered = false;
    if (options.render) {
      this.render = options.render;
    }
    if (options.map) {
      this.setMap(options.map);
    }
    this.addChangeListener(
      Property_default.SOURCE,
      this.handleSourcePropertyChange_
    );
    const source = options.source ? options.source : null;
    this.setSource(source);
  }
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }
  getSource() {
    return this.get(Property_default.SOURCE) || null;
  }
  getRenderSource() {
    return this.getSource();
  }
  getSourceState() {
    const source = this.getSource();
    return !source ? "undefined" : source.getState();
  }
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== "ready") {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent("sourceready");
  }
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(
        source,
        EventType_default.CHANGE,
        this.handleSourceChange_,
        this
      );
      if (source.getState() === "ready") {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent("sourceready");
        }, 0);
      }
    }
    this.changed();
  }
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }
  isVisible(view) {
    let frameState;
    const map = this.getMapInternal();
    if (!view && map) {
      view = map.getView();
    }
    if (view instanceof View_default) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent()
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map) {
      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState2) => layerState2.layer === this
      );
    } else {
      layerState = this.getLayerState();
    }
    const layerExtent = this.getExtent();
    return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
  }
  getAttributions(view) {
    if (!this.isVisible(view)) {
      return [];
    }
    let getAttributions;
    const source = this.getSource();
    if (source) {
      getAttributions = source.getAttributions();
    }
    if (!getAttributions) {
      return [];
    }
    const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }
  render(frameState, target) {
    const layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }
  unrender() {
    this.rendered = false;
  }
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(Property_default.MAP, map);
  }
  getMapInternal() {
    return this.get(Property_default.MAP);
  }
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = listen(
        map,
        EventType_default2.PRECOMPOSE,
        function(evt) {
          const renderEvent = evt;
          const layerStatesArray = renderEvent.frameState.layerStatesArray;
          const layerState = this.getLayerState(false);
          assert(
            !layerStatesArray.some(function(arrayLayerState) {
              return arrayLayerState.layer === layerState.layer;
            }),
            67
          );
          layerStatesArray.push(layerState);
        },
        this
      );
      this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
      this.changed();
    }
  }
  setSource(source) {
    this.set(Property_default.SOURCE, source);
  }
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }
  hasRenderer() {
    return !!this.renderer_;
  }
  createRenderer() {
    return null;
  }
  disposeInternal() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
    this.setSource(null);
    super.disposeInternal();
  }
};
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer_default = Layer;

// node_modules/ol/renderer/Map.js
var MapRenderer = class extends Disposable_default {
  constructor(map) {
    super();
    this.map_ = map;
  }
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX2(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = [];
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  getMap() {
    return this.map_;
  }
  renderFrame(frameState) {
    abstract();
  }
  flushDeclutterItems(frameState) {
  }
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
};
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/render/Event.js
var RenderEvent = class extends Event_default {
  constructor(type, inversePixelTransform, frameState, context) {
    super(type);
    this.inversePixelTransform = inversePixelTransform;
    this.frameState = frameState;
    this.context = context;
  }
};
var Event_default2 = RenderEvent;

// node_modules/ol/css.js
var CLASS_HIDDEN = "ol-hidden";
var CLASS_SELECTABLE = "ol-selectable";
var CLASS_UNSELECTABLE = "ol-unselectable";
var CLASS_UNSUPPORTED = "ol-unsupported";
var CLASS_CONTROL = "ol-control";
var CLASS_COLLAPSED = "ol-collapsed";
var fontRegEx = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
);
var fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
var getFontParameters = function(fontSpec) {
  const match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  const style = {
    lineHeight: "normal",
    size: "1.2em",
    style: "normal",
    weight: "normal",
    variant: "normal"
  };
  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    const value = match[i + 1];
    if (value !== void 0) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool3, settings) {
  let canvas;
  if (canvasPool3 && canvasPool3.length) {
    canvas = canvasPool3.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return canvas.getContext("2d", settings);
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
  let width = element.offsetWidth;
  const style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
function outerHeight(element) {
  let height = element.offsetHeight;
  const style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}

// node_modules/ol/render/canvas.js
var defaultFont = "10px sans-serif";
var defaultFillStyle = "#000";
var defaultLineCap = "round";
var defaultLineDash = [];
var defaultLineDashOffset = 0;
var defaultLineJoin = "round";
var defaultMiterLimit = 10;
var defaultStrokeStyle = "#000";
var defaultTextAlign = "center";
var defaultTextBaseline = "middle";
var defaultPadding = [0, 0, 0, 0];
var defaultLineWidth = 1;
var checkedFonts = new Object_default();
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  const retries = 100;
  const size = "32px ";
  const referenceFonts = ["monospace", "serif"];
  const len = referenceFonts.length;
  const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  let interval, referenceWidth;
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    let available = true;
    for (let i = 0; i < len; ++i) {
      const referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(
        fontStyle + " " + fontWeight + " " + size + referenceFont,
        text
      );
      if (fontFamily != referenceFont) {
        const width = measureTextWidth(
          fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
          text
        );
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
      const font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split("\n"))) {
          clear(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    const font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i = 0, ii = families.length; i < ii; ++i) {
      const family = families[i];
      const key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
var measureTextHeight = function() {
  let measureElement;
  return function(fontSpec) {
    let height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        const font = getFontParameters(fontSpec);
        const metrics = measureText(fontSpec, "\u017Dg");
        const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache2) {
  if (text in cache2) {
    return cache2[text];
  }
  const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache2[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale4) {
  context.save();
  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform2) {
    context.setTransform.apply(context, transform2);
  }
  if (labelOrImage.contextInstructions) {
    context.translate(x, y);
    context.scale(scale4[0], scale4[1]);
    executeLabelInstructions(labelOrImage, context);
  } else if (scale4[0] < 0 || scale4[1] < 0) {
    context.translate(x, y);
    context.scale(scale4[0], scale4[1]);
    context.drawImage(
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale4[0],
      h * scale4[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1]
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}

// node_modules/ol/renderer/Composite.js
var CompositeMapRenderer = class extends Map_default {
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType_default.PROPERTYCHANGE,
      map.redrawText.bind(map)
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
    this.declutterLayers_ = [];
  }
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    super.disposeInternal();
  }
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
      return a.zIndex - b.zIndex;
    });
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const declutterLayers = this.declutterLayers_;
    declutterLayers.length = 0;
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ("getDeclutter" in layer) {
        declutterLayers.push(
          layer
        );
      }
    }
    this.flushDeclutterItems(frameState);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  flushDeclutterItems(frameState) {
    const layers = this.declutterLayers_;
    for (let i = layers.length - 1; i >= 0; --i) {
      layers[i].renderDeclutter(frameState);
    }
    layers.length = 0;
  }
};
var Composite_default = CompositeMapRenderer;

// node_modules/ol/layer/Group.js
var GroupEvent = class extends Event_default {
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
};
var Property2 = {
  LAYERS: "layers"
};
var LayerGroup = class extends Base_default {
  constructor(options) {
    options = options || {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property2.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection_default(layers.slice(), { unique: true });
      } else {
        assert(typeof layers.getArray === "function", 43);
      }
    } else {
      layers = new Collection_default(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  handleLayerChange_() {
    this.changed();
  }
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
      listen(layers, CollectionEventType_default.REMOVE, this.handleLayersRemove_, this)
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  getLayers() {
    return this.get(Property2.LAYERS);
  }
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property2.LAYERS, layers);
  }
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  getSourceState() {
    return "ready";
  }
};
var Group_default = LayerGroup;

// node_modules/ol/MapEvent.js
var MapEvent = class extends Event_default {
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
};
var MapEvent_default = MapEvent;

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = class extends MapEvent_default {
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};
var MapBrowserEvent_default = MapBrowserEvent;

// node_modules/ol/MapBrowserEventType.js
var MapBrowserEventType_default = {
  SINGLECLICK: "singleclick",
  CLICK: EventType_default.CLICK,
  DBLCLICK: EventType_default.DBLCLICK,
  POINTERDRAG: "pointerdrag",
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/pointer/EventType.js
var EventType_default3 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
var MapBrowserEventHandler = class extends Target_default {
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      EventType_default3.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      EventType_default3.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent_default(
          MapBrowserEventType_default.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType_default.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        listen(
          this.element_,
          MapBrowserEventType_default.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType_default.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
};
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/MapEventType.js
var MapEventType_default = {
  POSTRENDER: "postrender",
  MOVESTART: "movestart",
  MOVEEND: "moveend",
  LOADSTART: "loadstart",
  LOADEND: "loadend"
};

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/structs/PriorityQueue.js
var DROP = Infinity;
var PriorityQueue = class {
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = elements.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  enqueue(element) {
    assert(!(this.keyFunction_(element) in this.queuedElements_), 31);
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  getCount() {
    return this.elements_.length;
  }
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  isEmpty() {
    return this.elements_.length === 0;
  }
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
};
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileState.js
var TileState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/TileQueue.js
var TileQueue = class extends PriorityQueue_default {
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      function(element) {
        return element[0].getKey();
      }
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  getTilesLoading() {
    return this.tilesLoading_;
  }
  handleTileChange(event) {
    const tile = event.target;
    const state = tile.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      if (state !== TileState_default.ERROR) {
        tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    let state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile = this.dequeue()[0];
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
};
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/control/Control.js
var Control = class extends Object_default {
  constructor(options) {
    super();
    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    this.element = element ? element : null;
    this.target_ = null;
    this.map_ = null;
    this.listenerKeys = [];
    if (options.render) {
      this.render = options.render;
    }
    if (options.target) {
      this.setTarget(options.target);
    }
  }
  disposeInternal() {
    removeNode(this.element);
    super.disposeInternal();
  }
  getMap() {
    return this.map_;
  }
  setMap(map) {
    if (this.map_) {
      removeNode(this.element);
    }
    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      unlistenByKey(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== VOID) {
        this.listenerKeys.push(
          listen(map, MapEventType_default.POSTRENDER, this.render, this)
        );
      }
      map.render();
    }
  }
  render(mapEvent) {
  }
  setTarget(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  }
};
var Control_default = Control;

// node_modules/ol/control/Attribution.js
var Attribution = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  collectSourceAttributions_(frameState) {
    const visibleAttributions = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((layer) => layer.getAttributions(frameState))
      )
    );
    const collapsible = !this.getMap().getAllLayers().some(
      (layer) => layer.getSource() && layer.getSource().getAttributionsCollapsible() === false
    );
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  }
  updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = this.collectSourceAttributions_(frameState);
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  getCollapsible() {
    return this.collapsible_;
  }
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  getCollapsed() {
    return this.collapsed_;
  }
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
};
var Attribution_default = Attribution;

// node_modules/ol/control/Rotate.js
var Rotate = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
};
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
var Zoom = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
};
var Zoom_default = Zoom;

// node_modules/ol/control/defaults.js
function defaults(options) {
  options = options ? options : {};
  const controls = new Collection_default();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/interaction/Property.js
var Property_default2 = {
  ACTIVE: "active"
};

// node_modules/ol/interaction/Interaction.js
var Interaction = class extends Object_default {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  getActive() {
    return this.get(Property_default2.ACTIVE);
  }
  getMap() {
    return this.map_;
  }
  handleEvent(mapBrowserEvent) {
    return true;
  }
  setActive(active) {
    this.set(Property_default2.ACTIVE, active);
  }
  setMap(map) {
    this.map_ = map;
  }
};
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
var Interaction_default = Interaction;

// node_modules/ol/interaction/DoubleClickZoom.js
var DoubleClickZoom = class extends Interaction_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      const browserEvent = mapBrowserEvent.originalEvent;
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
};
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/interaction/Pointer.js
var PointerInteraction = class extends Interaction_default {
  constructor(options) {
    options = options ? options : {};
    super(
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  getPointerCount() {
    return this.targetPointers.length;
  }
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  handleDragEvent(mapBrowserEvent) {
  }
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  handleMoveEvent(mapBrowserEvent) {
  }
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  stopDown(handled) {
    return handled;
  }
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
};
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
var Pointer_default = PointerInteraction;

// node_modules/ol/events/condition.js
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
var always = TRUE;
var mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = mapBrowserEvent.originalEvent;
  const tagName = originalEvent.target.tagName;
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && !originalEvent.target.isContentEditable;
};
var mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = mapBrowserEvent.originalEvent;
  assert(pointerEvent !== void 0, 56);
  return pointerEvent.pointerType == "mouse";
};
var primaryAction = function(mapBrowserEvent) {
  const pointerEvent = mapBrowserEvent.originalEvent;
  assert(pointerEvent !== void 0, 56);
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

// node_modules/ol/interaction/DragPan.js
var DragPan = class extends Pointer_default {
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid2 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale(delta, view.getResolution());
        rotate(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
};
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
var DragRotate = class extends Pointer_default {
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
};
var DragRotate_default = DragRotate;

// node_modules/ol/render/Box.js
var RenderBox = class extends Disposable_default {
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  disposeInternal() {
    this.setMap(null);
  }
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  createOrUpdateGeometry() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  getGeometry() {
    return this.geometry_;
  }
};
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
var DragBoxEventType = {
  BOXSTART: "boxstart",
  BOXDRAG: "boxdrag",
  BOXEND: "boxend",
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = class extends Event_default {
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
};
var DragBox = class extends Pointer_default {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ? options : {};
    this.box_ = new Box_default(options.className || "ol-dragbox");
    this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ? options.condition : mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
  }
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  getGeometry() {
    return this.box_.getGeometry();
  }
  handleDragEvent(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  handleUpEvent(mapBrowserEvent) {
    this.box_.setMap(null);
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    return false;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  onBoxEnd(event) {
  }
};
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
var DragZoom = class extends DragBox_default {
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  onBoxEnd(event) {
    const map = this.getMap();
    const view = map.getView();
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
};
var DragZoom_default = DragZoom;

// node_modules/ol/events/Key.js
var Key_default = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};

// node_modules/ol/interaction/KeyboardPan.js
var KeyboardPan = class extends Interaction_default {
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      const keyEvent = mapBrowserEvent.originalEvent;
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
var KeyboardZoom = class extends Interaction_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      const keyEvent = mapBrowserEvent.originalEvent;
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/Kinetic.js
var Kinetic = class {
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  getAngle() {
    return this.angle_;
  }
};
var Kinetic_default = Kinetic;

// node_modules/ol/interaction/MouseWheelZoom.js
var MouseWheelZoom = class extends Interaction_default {
  constructor(options) {
    options = options ? options : {};
    super(
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = mapBrowserEvent.originalEvent;
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    let delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
};
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
var PinchRotate = class extends Pointer_default {
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
var PinchZoom = class extends Pointer_default {
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = options;
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/defaults.js
function defaults2(options) {
  options = options ? options : {};
  const interactions = new Collection_default();
  const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan_default({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(
      new KeyboardZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom_default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}

// node_modules/ol/size.js
function buffer2(size, num, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale3(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}

// node_modules/ol/Map.js
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var Map = class extends Object_default {
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults();
    this.interactions = optionsInternal.interactions || defaults2({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue_default(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty_default.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType_default.ADD,
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  addControl(control) {
    this.getControls().push(control);
  }
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = "changedTouches" in event ? event.changedTouches[0] : event;
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  getTarget() {
    return this.get(MapProperty_default.TARGET);
  }
  getTargetElement() {
    return this.targetElement_;
  }
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  getControls() {
    return this.controls;
  }
  getOverlays() {
    return this.overlays_;
  }
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  getInteractions() {
    return this.interactions;
  }
  getLayerGroup() {
    return this.get(MapProperty_default.LAYERGROUP);
  }
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  getRenderer() {
    return this.renderer_;
  }
  getSize() {
    return this.get(MapProperty_default.SIZE);
  }
  getView() {
    return this.get(MapProperty_default.VIEW);
  }
  getViewport() {
    return this.viewport_;
  }
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = mapBrowserEvent.originalEvent;
    const eventType = originalEvent.type;
    if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = originalEvent.target;
      if (this.overlayContainerStopEvent_.contains(target) || !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            EventType_default2.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new Composite_default(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType_default[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType_default.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType_default.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  handleTileChange_() {
    this.render();
  }
  handleViewPropertyChanged_() {
    this.render();
  }
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType_default.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  isRendered() {
    return !!this.frameState_;
  }
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  flushDeclutterItems() {
    const frameState = this.frameState_;
    if (!frameState) {
      return;
    }
    this.renderer_.flushDeclutterItems(frameState);
  }
  removeControl(control) {
    return this.getControls().remove(control);
  }
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  }
  setSize(size) {
    this.set(MapProperty_default.SIZE, size);
  }
  setTarget(target) {
    this.set(MapProperty_default.TARGET, target);
  }
  setView(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  }
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_();
    }
  }
  updateViewportSize_() {
    const view = this.getView();
    if (view) {
      let size = void 0;
      const computedStyle = getComputedStyle(this.viewport_);
      if (computedStyle.width && computedStyle.height) {
        size = [
          parseInt(computedStyle.width, 10),
          parseInt(computedStyle.height, 10)
        ];
      }
      view.setViewportSize(size);
    }
  }
};
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof options.layers.getLayers === "function" ? options.layers : new Group_default({
    layers: options.layers
  });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(
        typeof options.controls.getArray === "function",
        47
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(
        typeof options.interactions.getArray === "function",
        48
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(
        typeof options.overlays.getArray === "function",
        49
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var Map_default2 = Map;

// node_modules/ol/TileRange.js
var TileRange = class {
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
};
function createOrUpdate2(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange_default = TileRange;

// node_modules/ol/tilecoord.js
function createOrUpdate3(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function getKey2(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}

// node_modules/ol/tilegrid/TileGrid.js
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = class {
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        function(a, b) {
          return b - a;
        },
        true
      ),
      17
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(this.origins_.length == this.resolutions_.length, 20);
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      18
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(this.tileSizes_.length == this.resolutions_.length, 19);
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      22
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map(function(size, z) {
        const tileRange = new TileRange_default(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate2(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  getExtent() {
    return this.extent_;
  }
  getMaxZoom() {
    return this.maxZoom;
  }
  getMinZoom() {
    return this.minZoom;
  }
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  getResolution(z) {
    return this.resolutions_[z];
  }
  getResolutions() {
    return this.resolutions_;
  }
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate2(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate2(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate2(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate2(minX, maxX, minY, maxY, tempTileRange);
  }
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
  }
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale4 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale4 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale4 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate3(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
};
var TileGrid_default = TileGrid;

// node_modules/ol/tilegrid/WMTS.js
var WMTSTileGrid = class extends TileGrid_default {
  constructor(options) {
    super({
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    });
    this.matrixIds_ = options.matrixIds;
  }
  getMatrixId(z) {
    return this.matrixIds_[z];
  }
  getMatrixIds() {
    return this.matrixIds_;
  }
};
var WMTS_default = WMTSTileGrid;

// src/Map.js
var import_proj42 = __toESM(require_proj4());

// node_modules/ol/proj/proj4.js
var registered = null;
function register(proj42) {
  registered = proj42;
  const projCodes = Object.keys(proj42.defs);
  const len = projCodes.length;
  let i, j;
  for (i = 0; i < len; ++i) {
    const code = projCodes[i];
    if (!get3(code)) {
      const def = proj42.defs(code);
      let units = def.units;
      if (!units && def.projName === "longlat") {
        units = "degrees";
      }
      addProjection(
        new Projection_default({
          code,
          axisOrientation: def.axis,
          metersPerUnit: def.to_meter,
          units
        })
      );
    }
  }
  for (i = 0; i < len; ++i) {
    const code1 = projCodes[i];
    const proj1 = get3(code1);
    for (j = 0; j < len; ++j) {
      const code2 = projCodes[j];
      const proj2 = get3(code2);
      if (!get2(code1, code2)) {
        if (proj42.defs[code1] === proj42.defs[code2]) {
          addEquivalentProjections([proj1, proj2]);
        } else {
          const transform2 = proj42(code1, code2);
          addCoordinateTransforms(
            proj1,
            proj2,
            createSafeCoordinateTransform(proj1, proj2, transform2.forward),
            createSafeCoordinateTransform(proj2, proj1, transform2.inverse)
          );
        }
      }
    }
  }
}

// node_modules/ol/control/FullScreen.js
var events = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
];
var FullScreenEventType = {
  ENTERFULLSCREEN: "enterfullscreen",
  LEAVEFULLSCREEN: "leavefullscreen"
};
var FullScreen = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.keys_ = options.keys !== void 0 ? options.keys : false;
    this.source_ = options.source;
    this.isInFullscreen_ = false;
    this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this);
    this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
    this.documentListeners_ = [];
    this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [this.cssClassName_ + "-true"];
    this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const label = options.label !== void 0 ? options.label : "\u2922";
    this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    const labelActive = options.labelActive !== void 0 ? options.labelActive : "\xD7";
    this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
    const tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button");
    this.button_.title = tipLabel;
    this.button_.setAttribute("type", "button");
    this.button_.appendChild(this.labelNode_);
    this.button_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    this.setClassName_(this.button_, this.isInFullscreen_);
    this.element.className = `${this.cssClassName_} ${CLASS_UNSELECTABLE} ${CLASS_CONTROL}`;
    this.element.appendChild(this.button_);
  }
  handleClick_(event) {
    event.preventDefault();
    this.handleFullScreen_();
  }
  handleFullScreen_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const doc = map.getOwnerDocument();
    if (!isFullScreenSupported(doc)) {
      return;
    }
    if (isFullScreen(doc)) {
      exitFullScreen(doc);
    } else {
      let element;
      if (this.source_) {
        element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }
      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  }
  handleFullScreenChange_() {
    const map = this.getMap();
    if (!map) {
      return;
    }
    const wasInFullscreen = this.isInFullscreen_;
    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
    if (wasInFullscreen !== this.isInFullscreen_) {
      this.setClassName_(this.button_, this.isInFullscreen_);
      if (this.isInFullscreen_) {
        replaceNode(this.labelActiveNode_, this.labelNode_);
        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
      } else {
        replaceNode(this.labelNode_, this.labelActiveNode_);
        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
      }
      map.updateSize();
    }
  }
  setClassName_(element, fullscreen) {
    if (fullscreen) {
      element.classList.remove(...this.inactiveClassName_);
      element.classList.add(...this.activeClassName_);
    } else {
      element.classList.remove(...this.activeClassName_);
      element.classList.add(...this.inactiveClassName_);
    }
  }
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      oldMap.removeChangeListener(
        MapProperty_default.TARGET,
        this.boundHandleMapTargetChange_
      );
    }
    super.setMap(map);
    this.handleMapTargetChange_();
    if (map) {
      map.addChangeListener(
        MapProperty_default.TARGET,
        this.boundHandleMapTargetChange_
      );
    }
  }
  handleMapTargetChange_() {
    const listeners = this.documentListeners_;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      unlistenByKey(listeners[i]);
    }
    listeners.length = 0;
    const map = this.getMap();
    if (map) {
      const doc = map.getOwnerDocument();
      if (isFullScreenSupported(doc)) {
        this.element.classList.remove(CLASS_UNSUPPORTED);
      } else {
        this.element.classList.add(CLASS_UNSUPPORTED);
      }
      for (let i = 0, ii = events.length; i < ii; ++i) {
        listeners.push(
          listen(doc, events[i], this.handleFullScreenChange_, this)
        );
      }
      this.handleFullScreenChange_();
    }
  }
};
function isFullScreenSupported(doc) {
  const body = doc.body;
  return !!(body["webkitRequestFullscreen"] || body.requestFullscreen && doc.fullscreenEnabled);
}
function isFullScreen(doc) {
  return !!(doc["webkitIsFullScreen"] || doc.fullscreenElement);
}
function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  }
}
function requestFullScreenWithKeys(element) {
  if (element["webkitRequestFullscreen"]) {
    element["webkitRequestFullscreen"]();
  } else {
    requestFullScreen(element);
  }
}
function exitFullScreen(doc) {
  if (doc.exitFullscreen) {
    doc.exitFullscreen();
  } else if (doc["webkitExitFullscreen"]) {
    doc["webkitExitFullscreen"]();
  }
}
var FullScreen_default = FullScreen;

// node_modules/ol/Overlay.js
var Property3 = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
var Overlay = class extends Object_default {
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.options = options;
    this.id = options.id;
    this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
    this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
    this.element = document.createElement("div");
    this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
    this.element.style.position = "absolute";
    this.element.style.pointerEvents = "auto";
    this.autoPan = options.autoPan === true ? {} : options.autoPan || void 0;
    this.rendered = {
      transform_: "",
      visible: true
    };
    this.mapPostrenderListenerKey = null;
    this.addChangeListener(Property3.ELEMENT, this.handleElementChanged);
    this.addChangeListener(Property3.MAP, this.handleMapChanged);
    this.addChangeListener(Property3.OFFSET, this.handleOffsetChanged);
    this.addChangeListener(Property3.POSITION, this.handlePositionChanged);
    this.addChangeListener(Property3.POSITIONING, this.handlePositioningChanged);
    if (options.element !== void 0) {
      this.setElement(options.element);
    }
    this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
    this.setPositioning(options.positioning || "top-left");
    if (options.position !== void 0) {
      this.setPosition(options.position);
    }
  }
  getElement() {
    return this.get(Property3.ELEMENT);
  }
  getId() {
    return this.id;
  }
  getMap() {
    return this.get(Property3.MAP) || null;
  }
  getOffset() {
    return this.get(Property3.OFFSET);
  }
  getPosition() {
    return this.get(Property3.POSITION);
  }
  getPositioning() {
    return this.get(Property3.POSITIONING);
  }
  handleElementChanged() {
    removeChildren(this.element);
    const element = this.getElement();
    if (element) {
      this.element.appendChild(element);
    }
  }
  handleMapChanged() {
    if (this.mapPostrenderListenerKey) {
      removeNode(this.element);
      unlistenByKey(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }
    const map = this.getMap();
    if (map) {
      this.mapPostrenderListenerKey = listen(
        map,
        MapEventType_default.POSTRENDER,
        this.render,
        this
      );
      this.updatePixelPosition();
      const container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }
      this.performAutoPan();
    }
  }
  render() {
    this.updatePixelPosition();
  }
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  handlePositionChanged() {
    this.updatePixelPosition();
    this.performAutoPan();
  }
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  setElement(element) {
    this.set(Property3.ELEMENT, element);
  }
  setMap(map) {
    this.set(Property3.MAP, map);
  }
  setOffset(offset) {
    this.set(Property3.OFFSET, offset);
  }
  setPosition(position) {
    this.set(Property3.POSITION, position);
  }
  performAutoPan() {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  }
  panIntoView(panIntoViewOptions) {
    const map = this.getMap();
    if (!map || !map.getTargetElement() || !this.get(Property3.POSITION)) {
      return;
    }
    const mapRect = this.getRect(map.getTargetElement(), map.getSize());
    const element = this.getElement();
    const overlayRect = this.getRect(element, [
      outerWidth(element),
      outerHeight(element)
    ]);
    panIntoViewOptions = panIntoViewOptions || {};
    const myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
    if (!containsExtent(mapRect, overlayRect)) {
      const offsetLeft = overlayRect[0] - mapRect[0];
      const offsetRight = mapRect[2] - overlayRect[2];
      const offsetTop = overlayRect[1] - mapRect[1];
      const offsetBottom = mapRect[3] - overlayRect[3];
      const delta = [0, 0];
      if (offsetLeft < 0) {
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + myMargin;
      }
      if (offsetTop < 0) {
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }
      if (delta[0] !== 0 || delta[1] !== 0) {
        const center = map.getView().getCenterInternal();
        const centerPx = map.getPixelFromCoordinateInternal(center);
        if (!centerPx) {
          return;
        }
        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        const panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  }
  getRect(element, size) {
    const box = element.getBoundingClientRect();
    const offsetX = box.left + window.pageXOffset;
    const offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  }
  setPositioning(positioning) {
    this.set(Property3.POSITIONING, positioning);
  }
  setVisible(visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? "" : "none";
      this.rendered.visible = visible;
    }
  }
  updatePixelPosition() {
    const map = this.getMap();
    const position = this.getPosition();
    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }
    const pixel = map.getPixelFromCoordinate(position);
    const mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  }
  updateRenderedPosition(pixel, mapSize) {
    const style = this.element.style;
    const offset = this.getOffset();
    const positioning = this.getPositioning();
    this.setVisible(true);
    const x = Math.round(pixel[0] + offset[0]) + "px";
    const y = Math.round(pixel[1] + offset[1]) + "px";
    let posX = "0%";
    let posY = "0%";
    if (positioning == "bottom-right" || positioning == "center-right" || positioning == "top-right") {
      posX = "-100%";
    } else if (positioning == "bottom-center" || positioning == "center-center" || positioning == "top-center") {
      posX = "-50%";
    }
    if (positioning == "bottom-left" || positioning == "bottom-center" || positioning == "bottom-right") {
      posY = "-100%";
    } else if (positioning == "center-left" || positioning == "center-center" || positioning == "center-right") {
      posY = "-50%";
    }
    const transform2 = `translate(${posX}, ${posY}) translate(${x}, ${y})`;
    if (this.rendered.transform_ != transform2) {
      this.rendered.transform_ = transform2;
      style.transform = transform2;
    }
  }
  getOptions() {
    return this.options;
  }
};
var Overlay_default = Overlay;

// node_modules/ol/control/ScaleLine.js
var UNITS_PROP = "units";
var LEADING_DIGITS = [1, 2, 5];
var DEFAULT_DPI = 25.4 / 0.28;
var ScaleLine = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.style.pointerEvents = "none";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    const className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div");
    this.innerElement_.className = className + "-inner";
    this.element.className = className + " " + CLASS_UNSELECTABLE;
    this.element.appendChild(this.innerElement_);
    this.viewState_ = null;
    this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
    this.maxWidth_ = options.maxWidth;
    this.renderedVisible_ = false;
    this.renderedWidth_ = void 0;
    this.renderedHTML_ = "";
    this.addChangeListener(UNITS_PROP, this.handleUnitsChanged_);
    this.setUnits(options.units || "metric");
    this.scaleBar_ = options.bar || false;
    this.scaleBarSteps_ = options.steps || 4;
    this.scaleBarText_ = options.text || false;
    this.dpi_ = options.dpi || void 0;
  }
  getUnits() {
    return this.get(UNITS_PROP);
  }
  handleUnitsChanged_() {
    this.updateElement_();
  }
  setUnits(units) {
    this.set(UNITS_PROP, units);
  }
  setDpi(dpi) {
    this.dpi_ = dpi;
  }
  updateElement_() {
    const viewState = this.viewState_;
    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const center = viewState.center;
    const projection = viewState.projection;
    const units = this.getUnits();
    const pointResolutionUnits = units == "degrees" ? "degrees" : "m";
    let pointResolution = getPointResolution(
      projection,
      viewState.resolution,
      center,
      pointResolutionUnits
    );
    const minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    const maxWidth = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI : void 0;
    let nominalCount = minWidth * pointResolution;
    let suffix = "";
    if (units == "degrees") {
      const metersPerDegree = METERS_PER_UNIT.degrees;
      nominalCount *= metersPerDegree;
      if (nominalCount < metersPerDegree / 60) {
        suffix = "\u2033";
        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = "\u2032";
        pointResolution *= 60;
      } else {
        suffix = "\xB0";
      }
    } else if (units == "imperial") {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = "ft";
        pointResolution /= 0.3048;
      } else {
        suffix = "mi";
        pointResolution /= 1609.344;
      }
    } else if (units == "nautical") {
      pointResolution /= 1852;
      suffix = "NM";
    } else if (units == "metric") {
      if (nominalCount < 1e-3) {
        suffix = "\u03BCm";
        pointResolution *= 1e6;
      } else if (nominalCount < 1) {
        suffix = "mm";
        pointResolution *= 1e3;
      } else if (nominalCount < 1e3) {
        suffix = "m";
      } else {
        suffix = "km";
        pointResolution /= 1e3;
      }
    } else if (units == "us") {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = "ft";
        pointResolution /= 0.30480061;
      } else {
        suffix = "mi";
        pointResolution /= 1609.3472;
      }
    } else {
      assert(false, 33);
    }
    let i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    let count, width, decimalCount;
    let previousCount, previousWidth, previousDecimalCount;
    while (true) {
      decimalCount = Math.floor(i / 3);
      const decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);
      if (isNaN(width)) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
        return;
      }
      if (maxWidth !== void 0 && width >= maxWidth) {
        count = previousCount;
        width = previousWidth;
        decimalCount = previousDecimalCount;
        break;
      } else if (width >= minWidth) {
        break;
      }
      previousCount = count;
      previousWidth = width;
      previousDecimalCount = decimalCount;
      ++i;
    }
    const html = this.scaleBar_ ? this.createScaleBar(width, count, suffix) : count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix;
    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }
    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + "px";
      this.renderedWidth_ = width;
    }
    if (!this.renderedVisible_) {
      this.element.style.display = "";
      this.renderedVisible_ = true;
    }
  }
  createScaleBar(width, scale4, suffix) {
    const resolutionScale = this.getScaleForResolution();
    const mapScale = resolutionScale < 1 ? Math.round(1 / resolutionScale).toLocaleString() + " : 1" : "1 : " + Math.round(resolutionScale).toLocaleString();
    const steps = this.scaleBarSteps_;
    const stepWidth = width / steps;
    const scaleSteps = [this.createMarker("absolute")];
    for (let i = 0; i < steps; ++i) {
      const cls = i % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      scaleSteps.push(
        `<div><div class="ol-scale-singlebar ${cls}" style="width: ${stepWidth}px;"></div>` + this.createMarker("relative") + (i % 2 === 0 || steps === 2 ? this.createStepText(i, width, false, scale4, suffix) : "") + "</div>"
      );
    }
    scaleSteps.push(this.createStepText(steps, width, true, scale4, suffix));
    const scaleBarText = this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${width}px;">` + mapScale + "</div>" : "";
    return scaleBarText + scaleSteps.join("");
  }
  createMarker(position) {
    const top = position === "absolute" ? 3 : -10;
    return `<div class="ol-scale-step-marker" style="position: ${position}; top: ${top}px;"></div>`;
  }
  createStepText(i, width, isLast, scale4, suffix) {
    const length = i === 0 ? 0 : Math.round(scale4 / this.scaleBarSteps_ * i * 100) / 100;
    const lengthString = length + (i === 0 ? "" : " " + suffix);
    const margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    const minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${margin}px;text-align: ${i === 0 ? "left" : "center"};min-width: ${minWidth}px;left: ${isLast ? width + "px" : "unset"};">` + lengthString + "</div>";
  }
  getScaleForResolution() {
    const resolution = getPointResolution(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    );
    const dpi = this.dpi_ || DEFAULT_DPI;
    const inchesPerMeter = 1e3 / 25.4;
    return resolution * inchesPerMeter * dpi;
  }
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
  }
};
var ScaleLine_default = ScaleLine;

// node_modules/ol/control/ZoomSlider.js
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
var ZoomSlider = class extends Control_default {
  constructor(options) {
    options = options ? options : {};
    super({
      target: options.target,
      element: document.createElement("div"),
      render: options.render
    });
    this.dragListenerKeys_ = [];
    this.currentResolution_ = void 0;
    this.direction_ = Direction.VERTICAL;
    this.dragging_;
    this.heightLimit_ = 0;
    this.widthLimit_ = 0;
    this.startX_;
    this.startY_;
    this.thumbSize_ = null;
    this.sliderInitialized_ = false;
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    const className = options.className !== void 0 ? options.className : "ol-zoomslider";
    const thumbElement = document.createElement("button");
    thumbElement.setAttribute("type", "button");
    thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
    const containerElement = this.element;
    containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(
      EventType_default3.POINTERDOWN,
      this.handleDraggerStart_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default3.POINTERMOVE,
      this.handleDraggerDrag_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default3.POINTERUP,
      this.handleDraggerEnd_.bind(this),
      false
    );
    containerElement.addEventListener(
      EventType_default.CLICK,
      this.handleContainerClick_.bind(this),
      false
    );
    thumbElement.addEventListener(EventType_default.CLICK, stopPropagation, false);
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      map.render();
    }
  }
  initSlider_() {
    const container = this.element;
    let containerWidth = container.offsetWidth;
    let containerHeight = container.offsetHeight;
    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }
    const containerStyle = getComputedStyle(container);
    containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
    containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
    const thumb = container.firstElementChild;
    const thumbStyle = getComputedStyle(thumb);
    const thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
    const thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
    this.thumbSize_ = [thumbWidth, thumbHeight];
    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }
    return this.sliderInitialized_ = true;
  }
  handleContainerClick_(event) {
    const view = this.getMap().getView();
    const relativePosition = this.getRelativePosition_(
      event.offsetX - this.thumbSize_[0] / 2,
      event.offsetY - this.thumbSize_[1] / 2
    );
    const resolution = this.getResolutionForPosition_(relativePosition);
    const zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom,
      duration: this.duration_,
      easing: easeOut
    });
  }
  handleDraggerStart_(event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      const element = this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;
      if (this.dragListenerKeys_.length === 0) {
        const drag = this.handleDraggerDrag_;
        const end = this.handleDraggerEnd_;
        const doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(
          listen(doc, EventType_default3.POINTERMOVE, drag, this),
          listen(doc, EventType_default3.POINTERUP, end, this)
        );
      }
    }
  }
  handleDraggerDrag_(event) {
    if (this.dragging_) {
      const deltaX = event.clientX - this.startX_;
      const deltaY = event.clientY - this.startY_;
      const relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  handleDraggerEnd_(event) {
    if (this.dragging_) {
      const view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = void 0;
      this.startY_ = void 0;
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  }
  setThumbPosition_(res) {
    const position = this.getPositionForResolution_(res);
    const thumb = this.element.firstElementChild;
    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + "px";
    } else {
      thumb.style.top = this.heightLimit_ * position + "px";
    }
  }
  getRelativePosition_(x, y) {
    let amount;
    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }
    return clamp(amount, 0, 1);
  }
  getResolutionForPosition_(position) {
    const fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  }
  getPositionForResolution_(res) {
    const fn = this.getMap().getView().getValueForResolutionFunction();
    return clamp(1 - fn(res), 0, 1);
  }
  render(mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }
    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }
    const res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  }
};
var ZoomSlider_default = ZoomSlider;

// node_modules/ol/ImageState.js
var ImageState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/style/Image.js
var ImageStyle = class {
  constructor(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
    this.declutterMode_ = options.declutterMode;
  }
  clone() {
    const scale4 = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  getOpacity() {
    return this.opacity_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  getRotation() {
    return this.rotation_;
  }
  getScale() {
    return this.scale_;
  }
  getScaleArray() {
    return this.scaleArray_;
  }
  getDisplacement() {
    return this.displacement_;
  }
  getDeclutterMode() {
    return this.declutterMode_;
  }
  getAnchor() {
    return abstract();
  }
  getImage(pixelRatio) {
    return abstract();
  }
  getHitDetectionImage() {
    return abstract();
  }
  getPixelRatio(pixelRatio) {
    return 1;
  }
  getImageState() {
    return abstract();
  }
  getImageSize() {
    return abstract();
  }
  getOrigin() {
    return abstract();
  }
  getSize() {
    return abstract();
  }
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  setScale(scale4) {
    this.scale_ = scale4;
    this.scaleArray_ = toSize(scale4);
  }
  listenImageChange(listener) {
    abstract();
  }
  load() {
    abstract();
  }
  unlistenImageChange(listener) {
    abstract();
  }
};
var Image_default = ImageStyle;

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (Array.isArray(color)) {
    return toString2(color);
  }
  return color;
}

// node_modules/ol/style/RegularShape.js
var RegularShape = class extends Image_default {
  constructor(options) {
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity: 1,
      rotateWithView,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      scale: options.scale !== void 0 ? options.scale : 1,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
    this.canvas_ = void 0;
    this.hitDetectionCanvas_ = null;
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.origin_ = [0, 0];
    this.points_ = options.points;
    this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
    this.radius2_ = options.radius2;
    this.angle_ = options.angle !== void 0 ? options.angle : 0;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.size_ = null;
    this.renderOptions_ = null;
    this.render();
  }
  clone() {
    const scale4 = this.getScale();
    const style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  getAnchor() {
    const size = this.size_;
    if (!size) {
      return null;
    }
    const displacement = this.getDisplacement();
    const scale4 = this.getScaleArray();
    return [
      size[0] / 2 - displacement[0] / scale4[0],
      size[1] / 2 + displacement[1] / scale4[1]
    ];
  }
  getAngle() {
    return this.angle_;
  }
  getFill() {
    return this.fill_;
  }
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.createHitDetectionCanvas_(this.renderOptions_);
    }
    return this.hitDetectionCanvas_;
  }
  getImage(pixelRatio) {
    let image = this.canvas_[pixelRatio];
    if (!image) {
      const renderOptions = this.renderOptions_;
      const context = createCanvasContext2D(
        renderOptions.size * pixelRatio,
        renderOptions.size * pixelRatio
      );
      this.draw_(renderOptions, context, pixelRatio);
      image = context.canvas;
      this.canvas_[pixelRatio] = image;
    }
    return image;
  }
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }
  getImageSize() {
    return this.size_;
  }
  getImageState() {
    return ImageState_default.LOADED;
  }
  getOrigin() {
    return this.origin_;
  }
  getPoints() {
    return this.points_;
  }
  getRadius() {
    return this.radius_;
  }
  getRadius2() {
    return this.radius2_;
  }
  getSize() {
    return this.size_;
  }
  getStroke() {
    return this.stroke_;
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }
  listenImageChange(listener) {
  }
  load() {
  }
  unlistenImageChange(listener) {
  }
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
      return strokeWidth;
    }
    let r1 = this.radius_;
    let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
    const alpha = 2 * Math.PI / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === "miter" && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    const k = strokeWidth / 2 / miterRatio;
    const l = strokeWidth / 2 * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === void 0 || lineJoin === "bevel") {
      return bevelAdd * 2;
    }
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }
  createRenderOptions() {
    let lineJoin = defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;
    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = defaultStrokeStyle;
      }
      strokeStyle = asColorLike(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === void 0) {
        strokeWidth = defaultLineWidth;
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === void 0) {
        lineJoin = defaultLineJoin;
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === void 0) {
        miterLimit = defaultMiterLimit;
      }
    }
    const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add4);
    return {
      strokeStyle,
      strokeWidth,
      size,
      lineDash,
      lineDashOffset,
      lineJoin,
      miterLimit
    };
  }
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.canvas_ = {};
    this.size_ = [size, size];
  }
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = defaultFillStyle;
      }
      context.fillStyle = asColorLike(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  createHitDetectionCanvas_(renderOptions) {
    if (this.fill_) {
      let color = this.fill_.getColor();
      let opacity = 0;
      if (typeof color === "string") {
        color = asArray(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        const context = createCanvasContext2D(
          renderOptions.size,
          renderOptions.size
        );
        this.hitDetectionCanvas_ = context.canvas;
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.getImage(1);
    }
  }
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius_;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
      if (this.radius2_ !== void 0) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = 2 * Math.PI / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }
  drawHitDetectionCanvas_(renderOptions, context) {
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    context.fillStyle = defaultFillStyle;
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
};
var RegularShape_default = RegularShape;

// node_modules/ol/style/Circle.js
var CircleStyle = class extends RegularShape_default {
  constructor(options) {
    options = options ? options : { radius: 5 };
    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== void 0 ? options.scale : 1,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }
  clone() {
    const scale4 = this.getScale();
    const style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  setRadius(radius) {
    this.radius_ = radius;
    this.render();
  }
};
var Circle_default = CircleStyle;

// node_modules/ol/style/Fill.js
var Fill = class {
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
  }
  clone() {
    const color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || void 0
    });
  }
  getColor() {
    return this.color_;
  }
  setColor(color) {
    this.color_ = color;
  }
};
var Fill_default = Fill;

// node_modules/ol/style/Stroke.js
var Stroke = class {
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  clone() {
    const color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  getColor() {
    return this.color_;
  }
  getLineCap() {
    return this.lineCap_;
  }
  getLineDash() {
    return this.lineDash_;
  }
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  getLineJoin() {
    return this.lineJoin_;
  }
  getMiterLimit() {
    return this.miterLimit_;
  }
  getWidth() {
    return this.width_;
  }
  setColor(color) {
    this.color_ = color;
  }
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }
  setWidth(width) {
    this.width_ = width;
  }
};
var Stroke_default = Stroke;

// node_modules/ol/style/Style.js
var Style = class {
  constructor(options) {
    options = options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = geometry.clone();
    }
    return new Style({
      geometry,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  getRenderer() {
    return this.renderer_;
  }
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  getGeometry() {
    return this.geometry_;
  }
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  getFill() {
    return this.fill_;
  }
  setFill(fill) {
    this.fill_ = fill;
  }
  getImage() {
    return this.image_;
  }
  setImage(image) {
    this.image_ = image;
  }
  getStroke() {
    return this.stroke_;
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  getText() {
    return this.text_;
  }
  setText(text) {
    this.text_ = text;
  }
  getZIndex() {
    return this.zIndex_;
  }
  setGeometry(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return feature.get(geometry);
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return geometry;
      };
    }
    this.geometry_ = geometry;
  }
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
};
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(typeof obj.getZIndex === "function", 41);
      const style = obj;
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
var defaultStyles = null;
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style_default = Style;

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = image;
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}

// node_modules/ol/style/IconImage.js
var taintedTestContext = null;
var IconImage = class extends Target_default {
  constructor(image, src, size, crossOrigin, imageState, color) {
    super();
    this.hitDetectionImage_ = null;
    this.image_ = image;
    this.crossOrigin_ = crossOrigin;
    this.canvas_ = {};
    this.color_ = color;
    this.unlisten_ = null;
    this.imageState_ = imageState;
    this.size_ = size;
    this.src_ = src;
    this.tainted_;
  }
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1, void 0, {
          willReadFrequently: true
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }
  dispatchChangeEvent_() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  handleImageError_() {
    this.imageState_ = ImageState_default.ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }
  handleImageLoad_() {
    this.imageState_ = ImageState_default.LOADED;
    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }
  getImageState() {
    return this.imageState_;
  }
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = createCanvasContext2D(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }
  getSize() {
    return this.size_;
  }
  getSrc() {
    return this.src_;
  }
  load() {
    if (this.imageState_ !== ImageState_default.IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }
    this.imageState_ = ImageState_default.LOADING;
    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
    this.unlisten_ = listenImage(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    );
  }
  replaceColor_(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
      return;
    }
    const image = this.image_;
    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(image.width * pixelRatio);
    canvas.height = Math.ceil(image.height * pixelRatio);
    const ctx = canvas.getContext("2d");
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = asString(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image, 0, 0);
    this.canvas_[pixelRatio] = canvas;
  }
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
};
function get4(image, src, size, crossOrigin, imageState, color) {
  let iconImage = shared.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    shared.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
}

// node_modules/ol/style/Icon.js
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon = class extends Image_default {
  constructor(options) {
    options = options || {};
    const opacity = options.opacity !== void 0 ? options.opacity : 1;
    const rotation = options.rotation !== void 0 ? options.rotation : 0;
    const scale4 = options.scale !== void 0 ? options.scale : 1;
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity,
      rotation,
      scale: scale4,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView,
      declutterMode: options.declutterMode
    });
    this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    this.normalizedAnchor_ = null;
    this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
    this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
    this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const image = options.img !== void 0 ? options.img : null;
    this.imgSize_ = options.imgSize;
    let src = options.src;
    assert(!(src !== void 0 && image), 4);
    assert(!image || image && this.imgSize_, 5);
    if ((src === void 0 || src.length === 0) && image) {
      src = image.src || getUid(image);
    }
    assert(src !== void 0 && src.length > 0, 6);
    assert(
      !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
      69
    );
    const imageState = options.src !== void 0 ? ImageState_default.IDLE : ImageState_default.LOADED;
    this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    this.iconImage_ = get4(
      image,
      src,
      this.imgSize_ !== void 0 ? this.imgSize_ : null,
      this.crossOrigin_,
      imageState,
      this.color_
    );
    this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
    this.origin_ = null;
    this.size_ = options.size !== void 0 ? options.size : null;
    if (options.width !== void 0 || options.height !== void 0) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image2 = this.getImage(1);
        if (image2 instanceof HTMLCanvasElement || image2.src && image2.complete) {
          width = image2.width;
          height = image2.height;
        } else {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height
              )
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== void 0) {
        this.setScale(
          calculateScale(width, height, options.width, options.height)
        );
      }
    }
  }
  clone() {
    let scale4, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale4 = this.getScale();
      scale4 = Array.isArray(scale4) ? scale4.slice() : scale4;
    }
    const clone2 = new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: scale4,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return clone2;
  }
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == "fraction") {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == "fraction") {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale4 = this.getScaleArray();
    return [
      anchor[0] - displacement[0] / scale4[0],
      anchor[1] + displacement[1] / scale4[1]
    ];
  }
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }
  getColor() {
    return this.color_;
  }
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }
  getImageSize() {
    return this.iconImage_.getSize();
  }
  getImageState() {
    return this.iconImage_.getImageState();
  }
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }
  getSrc() {
    return this.iconImage_.getSrc();
  }
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }
  getWidth() {
    const scale4 = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale4[0];
    }
    if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
      return this.iconImage_.getSize()[0] * scale4[0];
    }
    return void 0;
  }
  getHeight() {
    const scale4 = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale4[1];
    }
    if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
      return this.iconImage_.getSize()[1] * scale4[1];
    }
    return void 0;
  }
  setScale(scale4) {
    delete this.initialOptions_;
    super.setScale(scale4);
  }
  listenImageChange(listener) {
    this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
  }
  load() {
    this.iconImage_.load();
  }
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
  }
};
var Icon_default = Icon;

// node_modules/ol/structs/RBush.js
var import_rbush = __toESM(require_rbush_min(), 1);
var RBush = class {
  constructor(maxEntries) {
    this.rbush_ = new import_rbush.default(maxEntries);
    this.items_ = {};
  }
  insert(extent, value) {
    const item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value
    };
    this.rbush_.insert(item);
    this.items_[getUid(value)] = item;
  }
  load(extents, values) {
    const items = new Array(values.length);
    for (let i = 0, l = values.length; i < l; i++) {
      const extent = extents[i];
      const value = values[i];
      const item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value
      };
      items[i] = item;
      this.items_[getUid(value)] = item;
    }
    this.rbush_.load(items);
  }
  remove(value) {
    const uid = getUid(value);
    const item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  }
  update(extent, value) {
    const item = this.items_[getUid(value)];
    const bbox = [item.minX, item.minY, item.maxX, item.maxY];
    if (!equals2(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  }
  getAll() {
    const items = this.rbush_.all();
    return items.map(function(item) {
      return item.value;
    });
  }
  getInExtent(extent) {
    const bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3]
    };
    const items = this.rbush_.search(bbox);
    return items.map(function(item) {
      return item.value;
    });
  }
  forEach(callback) {
    return this.forEach_(this.getAll(), callback);
  }
  forEachInExtent(extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  }
  forEach_(values, callback) {
    let result;
    for (let i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);
      if (result) {
        return result;
      }
    }
    return result;
  }
  isEmpty() {
    return isEmpty(this.items_);
  }
  clear() {
    this.rbush_.clear();
    this.items_ = {};
  }
  getExtent(extent) {
    const data = this.rbush_.toJSON();
    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
  }
  concat(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (const i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  }
};
var RBush_default = RBush;

// node_modules/ol/source/Source.js
var Source = class extends Object_default {
  constructor(options) {
    super();
    this.projection = get3(options.projection);
    this.attributions_ = adaptAttributions(options.attributions);
    this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
    this.loading = false;
    this.state_ = options.state !== void 0 ? options.state : "ready";
    this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
    this.interpolate_ = !!options.interpolate;
    this.viewResolver = null;
    this.viewRejector = null;
    const self2 = this;
    this.viewPromise_ = new Promise(function(resolve, reject) {
      self2.viewResolver = resolve;
      self2.viewRejector = reject;
    });
  }
  getAttributions() {
    return this.attributions_;
  }
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  getProjection() {
    return this.projection;
  }
  getResolutions(projection) {
    return null;
  }
  getView() {
    return this.viewPromise_;
  }
  getState() {
    return this.state_;
  }
  getWrapX() {
    return this.wrapX_;
  }
  getInterpolate() {
    return this.interpolate_;
  }
  refresh() {
    this.changed();
  }
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }
  setState(state) {
    this.state_ = state;
    this.changed();
  }
};
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
var Source_default = Source;

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default = {
  ADDFEATURE: "addfeature",
  CHANGEFEATURE: "changefeature",
  CLEAR: "clear",
  REMOVEFEATURE: "removefeature",
  FEATURESLOADSTART: "featuresloadstart",
  FEATURESLOADEND: "featuresloadend",
  FEATURESLOADERROR: "featuresloaderror"
};

// node_modules/ol/loadingstrategy.js
function all2(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}

// node_modules/ol/featureloader.js
var withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open(
    "GET",
    typeof url === "function" ? url(extent, resolution, projection) : url,
    true
  );
  if (format.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format.getType();
      let source;
      if (type == "json" || type == "text") {
        source = xhr2.responseText;
      } else if (type == "xml") {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(
            xhr2.responseText,
            "application/xml"
          );
        }
      } else if (type == "arraybuffer") {
        source = xhr2.response;
      }
      if (source) {
        success(
          format.readFeatures(source, {
            extent,
            featureProjection: projection
          }),
          format.readProjection(source)
        );
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format) {
  return function(extent, resolution, projection, success, failure) {
    const source = this;
    loadFeaturesXhr(
      url,
      format,
      extent,
      resolution,
      projection,
      function(features, dataProjection) {
        source.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      failure ? failure : VOID
    );
  };
}

// node_modules/ol/source/Vector.js
var VectorSourceEvent = class extends Event_default {
  constructor(type, feature, features) {
    super(type);
    this.feature = feature;
    this.features = features;
  }
};
var VectorSource = class extends Source_default {
  constructor(options) {
    options = options || {};
    super({
      attributions: options.attributions,
      interpolate: true,
      projection: void 0,
      state: "ready",
      wrapX: options.wrapX !== void 0 ? options.wrapX : true
    });
    this.on;
    this.once;
    this.un;
    this.loader_ = VOID;
    this.format_ = options.format;
    this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
    this.url_ = options.url;
    if (options.loader !== void 0) {
      this.loader_ = options.loader;
    } else if (this.url_ !== void 0) {
      assert(this.format_, 7);
      this.loader_ = xhr(
        this.url_,
        this.format_
      );
    }
    this.strategy_ = options.strategy !== void 0 ? options.strategy : all2;
    const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
    this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
    this.loadedExtentsRtree_ = new RBush_default();
    this.loadingExtentsCount_ = 0;
    this.nullGeometryFeatures_ = {};
    this.idIndex_ = {};
    this.uidIndex_ = {};
    this.featureChangeKeys_ = {};
    this.featuresCollection_ = null;
    let collection;
    let features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === void 0) {
      collection = new Collection_default(features);
    }
    if (features !== void 0) {
      this.addFeaturesInternal(features);
    }
    if (collection !== void 0) {
      this.bindFeaturesCollection_(collection);
    }
  }
  addFeature(feature) {
    this.addFeatureInternal(feature);
    this.changed();
  }
  addFeatureInternal(feature) {
    const featureKey = getUid(feature);
    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }
      return;
    }
    this.setupChangeEvents_(featureKey, feature);
    const geometry = feature.getGeometry();
    if (geometry) {
      const extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
    this.dispatchEvent(
      new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
    );
  }
  setupChangeEvents_(featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
      listen(
        feature,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ];
  }
  addToIndex_(featureKey, feature) {
    let valid = true;
    const id = feature.getId();
    if (id !== void 0) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }
    if (valid) {
      assert(!(featureKey in this.uidIndex_), 30);
      this.uidIndex_[featureKey] = feature;
    }
    return valid;
  }
  addFeatures(features) {
    this.addFeaturesInternal(features);
    this.changed();
  }
  addFeaturesInternal(features) {
    const extents = [];
    const newFeatures = [];
    const geometryFeatures = [];
    for (let i = 0, length = features.length; i < length; i++) {
      const feature = features[i];
      const featureKey = getUid(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }
    for (let i = 0, length = newFeatures.length; i < length; i++) {
      const feature = newFeatures[i];
      const featureKey = getUid(feature);
      this.setupChangeEvents_(featureKey, feature);
      const geometry = feature.getGeometry();
      if (geometry) {
        const extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }
    if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
      for (let i = 0, length = newFeatures.length; i < length; i++) {
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i])
        );
      }
    }
  }
  bindFeaturesCollection_(collection) {
    let modifyingCollection = false;
    this.addEventListener(
      VectorEventType_default.ADDFEATURE,
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    this.addEventListener(
      VectorEventType_default.REMOVEFEATURE,
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      CollectionEventType_default.ADD,
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    collection.addEventListener(
      CollectionEventType_default.REMOVE,
      (evt) => {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(evt.element);
          modifyingCollection = false;
        }
      }
    );
    this.featuresCollection_ = collection;
  }
  clear(fast) {
    if (fast) {
      for (const featureId in this.featureChangeKeys_) {
        const keys = this.featureChangeKeys_[featureId];
        keys.forEach(unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        const removeAndIgnoreReturn = (feature) => {
          this.removeFeatureInternal(feature);
        };
        this.featuresRtree_.forEach(removeAndIgnoreReturn);
        for (const id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};
    const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  }
  forEachFeature(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }
  forEachFeatureAtCoordinateDirect(coordinate, callback) {
    const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function(feature) {
      const geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      }
      return void 0;
    });
  }
  forEachFeatureInExtent(extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  }
  forEachFeatureIntersectingExtent(extent, callback) {
    return this.forEachFeatureInExtent(
      extent,
      function(feature) {
        const geometry = feature.getGeometry();
        if (geometry.intersectsExtent(extent)) {
          const result = callback(feature);
          if (result) {
            return result;
          }
        }
      }
    );
  }
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  getFeatures() {
    let features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!isEmpty(this.nullGeometryFeatures_)) {
        extend(features, Object.values(this.nullGeometryFeatures_));
      }
    }
    return features;
  }
  getFeaturesAtCoordinate(coordinate) {
    const features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  }
  getFeaturesInExtent(extent, projection) {
    if (this.featuresRtree_) {
      const multiWorld = projection && projection.canWrapX() && this.getWrapX();
      if (!multiWorld) {
        return this.featuresRtree_.getInExtent(extent);
      }
      const extents = wrapAndSliceX(extent, projection);
      return [].concat(
        ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
      );
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    }
    return [];
  }
  getClosestFeatureToCoordinate(coordinate, filter) {
    const x = coordinate[0];
    const y = coordinate[1];
    let closestFeature = null;
    const closestPoint = [NaN, NaN];
    let minSquaredDistance = Infinity;
    const extent = [-Infinity, -Infinity, Infinity, Infinity];
    filter = filter ? filter : TRUE;
    this.featuresRtree_.forEachInExtent(
      extent,
      function(feature) {
        if (filter(feature)) {
          const geometry = feature.getGeometry();
          const previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(
            x,
            y,
            closestPoint,
            minSquaredDistance
          );
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            const minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      }
    );
    return closestFeature;
  }
  getExtent(extent) {
    return this.featuresRtree_.getExtent(extent);
  }
  getFeatureById(id) {
    const feature = this.idIndex_[id.toString()];
    return feature !== void 0 ? feature : null;
  }
  getFeatureByUid(uid) {
    const feature = this.uidIndex_[uid];
    return feature !== void 0 ? feature : null;
  }
  getFormat() {
    return this.format_;
  }
  getOverlaps() {
    return this.overlaps_;
  }
  getUrl() {
    return this.url_;
  }
  handleFeatureChange_(event) {
    const feature = event.target;
    const featureKey = getUid(feature);
    const geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      const extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    const id = feature.getId();
    if (id !== void 0) {
      const sid = id.toString();
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }
    this.changed();
    this.dispatchEvent(
      new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
    );
  }
  hasFeature(feature) {
    const id = feature.getId();
    if (id !== void 0) {
      return id in this.idIndex_;
    }
    return getUid(feature) in this.uidIndex_;
  }
  isEmpty() {
    if (this.featuresRtree_) {
      return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
    }
    if (this.featuresCollection_) {
      return this.featuresCollection_.getLength() === 0;
    }
    return true;
  }
  loadFeatures(extent, resolution, projection) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    const extentsToLoad = this.strategy_(extent, resolution, projection);
    for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      const extentToLoad = extentsToLoad[i];
      const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
        extentToLoad,
        function(object) {
          return containsExtent(object.extent, extentToLoad);
        }
      );
      if (!alreadyLoaded) {
        ++this.loadingExtentsCount_;
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
        );
        this.loader_.call(
          this,
          extentToLoad,
          resolution,
          projection,
          (features) => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(
                VectorEventType_default.FEATURESLOADEND,
                void 0,
                features
              )
            );
          },
          () => {
            --this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
            );
          }
        );
        loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
      }
    }
    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    super.refresh();
  }
  removeLoadedExtent(extent) {
    const loadedExtentsRtree = this.loadedExtentsRtree_;
    let obj;
    loadedExtentsRtree.forEachInExtent(extent, function(object) {
      if (equals2(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  }
  removeFeature(feature) {
    if (!feature) {
      return;
    }
    const featureKey = getUid(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    const result = this.removeFeatureInternal(feature);
    if (result) {
      this.changed();
    }
  }
  removeFeatureInternal(feature) {
    const featureKey = getUid(feature);
    const featureChangeKeys = this.featureChangeKeys_[featureKey];
    if (!featureChangeKeys) {
      return;
    }
    featureChangeKeys.forEach(unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    const id = feature.getId();
    if (id !== void 0) {
      delete this.idIndex_[id.toString()];
    }
    delete this.uidIndex_[featureKey];
    this.dispatchEvent(
      new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
    );
    return feature;
  }
  removeFromIdIndex_(feature) {
    let removed = false;
    for (const id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  }
  setLoader(loader) {
    this.loader_ = loader;
  }
  setUrl(url) {
    assert(this.format_, 7);
    this.url_ = url;
    this.setLoader(xhr(url, this.format_));
  }
};
var Vector_default = VectorSource;

// node_modules/ol/layer/BaseVector.js
var import_rbush2 = __toESM(require_rbush_min(), 1);

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR = "#333";
var Text = class {
  constructor(options) {
    options = options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.justify_ = options.justify;
    this.repeat_ = options.repeat;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : "point";
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
  }
  clone() {
    const scale4 = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale4) ? scale4.slice() : scale4,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  getOverflow() {
    return this.overflow_;
  }
  getFont() {
    return this.font_;
  }
  getMaxAngle() {
    return this.maxAngle_;
  }
  getPlacement() {
    return this.placement_;
  }
  getRepeat() {
    return this.repeat_;
  }
  getOffsetX() {
    return this.offsetX_;
  }
  getOffsetY() {
    return this.offsetY_;
  }
  getFill() {
    return this.fill_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  getRotation() {
    return this.rotation_;
  }
  getScale() {
    return this.scale_;
  }
  getScaleArray() {
    return this.scaleArray_;
  }
  getStroke() {
    return this.stroke_;
  }
  getText() {
    return this.text_;
  }
  getTextAlign() {
    return this.textAlign_;
  }
  getJustify() {
    return this.justify_;
  }
  getTextBaseline() {
    return this.textBaseline_;
  }
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  getPadding() {
    return this.padding_;
  }
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }
  setFont(font) {
    this.font_ = font;
  }
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }
  setPlacement(placement) {
    this.placement_ = placement;
  }
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  setFill(fill) {
    this.fill_ = fill;
  }
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  setScale(scale4) {
    this.scale_ = scale4;
    this.scaleArray_ = toSize(scale4 !== void 0 ? scale4 : 1);
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  setText(text) {
    this.text_ = text;
  }
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }
  setJustify(justify) {
    this.justify_ = justify;
  }
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }
  setPadding(padding) {
    this.padding_ = padding;
  }
};
var Text_default = Text;

// node_modules/ol/style/flat.js
function toStyle(flatStyle) {
  const style = new Style_default({
    fill: getFill(flatStyle, ""),
    stroke: getStroke(flatStyle, ""),
    text: getText(flatStyle),
    image: getImage(flatStyle)
  });
  return style;
}
function getFill(flatStyle, prefix) {
  const color = flatStyle[prefix + "fill-color"];
  if (!color) {
    return;
  }
  if (color === "none") {
    return null;
  }
  return new Fill_default({ color });
}
function getStroke(flatStyle, prefix) {
  const width = flatStyle[prefix + "stroke-width"];
  const color = flatStyle[prefix + "stroke-color"];
  if (!width && !color) {
    return;
  }
  return new Stroke_default({
    width,
    color,
    lineCap: flatStyle[prefix + "stroke-line-cap"],
    lineJoin: flatStyle[prefix + "stroke-line-join"],
    lineDash: flatStyle[prefix + "stroke-line-dash"],
    lineDashOffset: flatStyle[prefix + "stroke-line-dash-offset"],
    miterLimit: flatStyle[prefix + "stroke-miter-limit"]
  });
}
function getText(flatStyle) {
  const value = flatStyle["text-value"];
  if (!value) {
    return;
  }
  const text = new Text_default({
    text: value,
    font: flatStyle["text-font"],
    maxAngle: flatStyle["text-max-angle"],
    offsetX: flatStyle["text-offset-x"],
    offsetY: flatStyle["text-offset-y"],
    overflow: flatStyle["text-overflow"],
    placement: flatStyle["text-placement"],
    repeat: flatStyle["text-repeat"],
    scale: flatStyle["text-scale"],
    rotateWithView: flatStyle["text-rotate-with-view"],
    rotation: flatStyle["text-rotation"],
    textAlign: flatStyle["text-align"],
    justify: flatStyle["text-justify"],
    textBaseline: flatStyle["text-baseline"],
    padding: flatStyle["text-padding"],
    fill: getFill(flatStyle, "text-"),
    backgroundFill: getFill(flatStyle, "text-background-"),
    stroke: getStroke(flatStyle, "text-"),
    backgroundStroke: getStroke(flatStyle, "text-background-")
  });
  return text;
}
function getImage(flatStyle) {
  const iconSrc = flatStyle["icon-src"];
  const iconImg = flatStyle["icon-img"];
  if (iconSrc || iconImg) {
    const icon = new Icon_default({
      src: iconSrc,
      img: iconImg,
      imgSize: flatStyle["icon-img-size"],
      anchor: flatStyle["icon-anchor"],
      anchorOrigin: flatStyle["icon-anchor-origin"],
      anchorXUnits: flatStyle["icon-anchor-x-units"],
      anchorYUnits: flatStyle["icon-anchor-y-units"],
      color: flatStyle["icon-color"],
      crossOrigin: flatStyle["icon-cross-origin"],
      offset: flatStyle["icon-offset"],
      displacement: flatStyle["icon-displacement"],
      opacity: flatStyle["icon-opacity"],
      scale: flatStyle["icon-scale"],
      width: flatStyle["icon-width"],
      height: flatStyle["icon-height"],
      rotation: flatStyle["icon-rotation"],
      rotateWithView: flatStyle["icon-rotate-with-view"],
      size: flatStyle["icon-size"],
      declutterMode: flatStyle["icon-declutter-mode"]
    });
    return icon;
  }
  const shapePoints = flatStyle["shape-points"];
  if (shapePoints) {
    const prefix = "shape-";
    const shape = new RegularShape_default({
      points: shapePoints,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      radius: flatStyle["shape-radius"],
      radius1: flatStyle["shape-radius1"],
      radius2: flatStyle["shape-radius2"],
      angle: flatStyle["shape-angle"],
      displacement: flatStyle["shape-displacement"],
      rotation: flatStyle["shape-rotation"],
      rotateWithView: flatStyle["shape-rotate-with-view"],
      scale: flatStyle["shape-scale"],
      declutterMode: flatStyle["shape-declutter-mode"]
    });
    return shape;
  }
  const circleRadius = flatStyle["circle-radius"];
  if (circleRadius) {
    const prefix = "circle-";
    const circle = new Circle_default({
      radius: circleRadius,
      fill: getFill(flatStyle, prefix),
      stroke: getStroke(flatStyle, prefix),
      displacement: flatStyle["circle-displacement"],
      scale: flatStyle["circle-scale"],
      rotation: flatStyle["circle-rotation"],
      rotateWithView: flatStyle["circle-rotate-with-view"],
      declutterMode: flatStyle["circle-declutter-mode"]
    });
    return circle;
  }
  return;
}

// node_modules/ol/layer/BaseVector.js
var Property4 = {
  RENDER_ORDER: "renderOrder"
};
var BaseVectorLayer = class extends Layer_default {
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);
    this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
    this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.setStyle(options.style);
    this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
    this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
  }
  getDeclutter() {
    return this.declutter_;
  }
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  getRenderOrder() {
    return this.get(Property4.RENDER_ORDER);
  }
  getStyle() {
    return this.style_;
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  renderDeclutter(frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new import_rbush2.default(9);
    }
    this.getRenderer().renderDeclutter(frameState);
  }
  setRenderOrder(renderOrder) {
    this.set(Property4.RENDER_ORDER, renderOrder);
  }
  setStyle(style) {
    let styleLike;
    if (style === void 0) {
      styleLike = createDefaultStyle;
    } else if (style === null) {
      styleLike = null;
    } else if (typeof style === "function") {
      styleLike = style;
    } else if (style instanceof Style_default) {
      styleLike = style;
    } else if (Array.isArray(style)) {
      const len = style.length;
      const styles = new Array(len);
      for (let i = 0; i < len; ++i) {
        const s = style[i];
        if (s instanceof Style_default) {
          styles[i] = s;
        } else {
          styles[i] = toStyle(s);
        }
      }
      styleLike = styles;
    } else {
      styleLike = toStyle(style);
    }
    this.style_ = styleLike;
    this.styleFunction_ = style === null ? void 0 : toFunction(this.style_);
    this.changed();
  }
};
var BaseVector_default = BaseVectorLayer;

// node_modules/ol/render/canvas/Instruction.js
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
var fillInstruction = [Instruction.FILL];
var strokeInstruction = [Instruction.STROKE];
var beginPathInstruction = [Instruction.BEGIN_PATH];
var closePathInstruction = [Instruction.CLOSE_PATH];
var Instruction_default = Instruction;

// node_modules/ol/render/VectorContext.js
var VectorContext = class {
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
  }
  drawGeometry(geometry) {
  }
  setStyle(style) {
  }
  drawCircle(circleGeometry, feature) {
  }
  drawFeature(feature, style) {
  }
  drawGeometryCollection(geometryCollectionGeometry, feature) {
  }
  drawLineString(lineStringGeometry, feature) {
  }
  drawMultiLineString(multiLineStringGeometry, feature) {
  }
  drawMultiPoint(multiPointGeometry, feature) {
  }
  drawMultiPolygon(multiPolygonGeometry, feature) {
  }
  drawPoint(pointGeometry, feature) {
  }
  drawPolygon(polygonGeometry, feature) {
  }
  drawText(geometry, feature) {
  }
  setFillStrokeStyle(fillStyle, strokeStyle) {
  }
  setImageStyle(imageStyle, declutterImageWithText) {
  }
  setTextStyle(textStyle, declutterImageWithText) {
  }
};
var VectorContext_default = VectorContext;

// node_modules/ol/render/canvas/Builder.js
var CanvasBuilder = class extends VectorContext_default {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super();
    this.tolerance = tolerance;
    this.maxExtent = maxExtent;
    this.pixelRatio = pixelRatio;
    this.maxLineWidth = 0;
    this.resolution = resolution;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_ = null;
    this.bufferedMaxExtent_ = null;
    this.instructions = [];
    this.coordinates = [];
    this.tmpCoordinate_ = [];
    this.hitDetectionInstructions = [];
    this.state = {};
  }
  applyPixelRatio(dashArray) {
    const pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  }
  appendFlatPointCoordinates(flatCoordinates, stride) {
    const extent = this.getBufferedMaxExtent();
    const tmpCoord = this.tmpCoordinate_;
    const coordinates2 = this.coordinates;
    let myEnd = coordinates2.length;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      tmpCoord[0] = flatCoordinates[i];
      tmpCoord[1] = flatCoordinates[i + 1];
      if (containsCoordinate(extent, tmpCoord)) {
        coordinates2[myEnd++] = tmpCoord[0];
        coordinates2[myEnd++] = tmpCoord[1];
      }
    }
    return myEnd;
  }
  appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
    const coordinates2 = this.coordinates;
    let myEnd = coordinates2.length;
    const extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    let lastXCoord = flatCoordinates[offset];
    let lastYCoord = flatCoordinates[offset + 1];
    const nextCoord = this.tmpCoordinate_;
    let skipped = true;
    let i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = coordinateRelationship(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
          skipped = false;
        }
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
      } else if (nextRel === Relationship_default.INTERSECTING) {
        coordinates2[myEnd++] = nextCoord[0];
        coordinates2[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    }
    if (closed && skipped || i === offset + stride) {
      coordinates2[myEnd++] = lastXCoord;
      coordinates2[myEnd++] = lastYCoord;
    }
    return myEnd;
  }
  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const builderEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        false,
        false
      );
      builderEnds.push(builderEnd);
      offset = end;
    }
    return offset;
  }
  drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
    this.beginGeometry(geometry, feature);
    const type = geometry.getType();
    const stride = geometry.getStride();
    const builderBegin = this.coordinates.length;
    let flatCoordinates, builderEnd, builderEnds, builderEndss;
    let offset;
    switch (type) {
      case "MultiPolygon":
        flatCoordinates = geometry.getOrientedFlatCoordinates();
        builderEndss = [];
        const endss = geometry.getEndss();
        offset = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const myEnds = [];
          offset = this.drawCustomCoordinates_(
            flatCoordinates,
            offset,
            endss[i],
            stride,
            myEnds
          );
          builderEndss.push(myEnds);
        }
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          renderer,
          inflateMultiCoordinatesArray
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEndss,
          geometry,
          hitDetectionRenderer || renderer,
          inflateMultiCoordinatesArray
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        builderEnds = [];
        flatCoordinates = type == "Polygon" ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
        offset = this.drawCustomCoordinates_(
          flatCoordinates,
          0,
          geometry.getEnds(),
          stride,
          builderEnds
        );
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          renderer,
          inflateCoordinatesArray
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnds,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinatesArray
        ]);
        break;
      case "LineString":
      case "Circle":
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer,
          inflateCoordinates
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer,
          inflateCoordinates
        ]);
        break;
      case "MultiPoint":
        flatCoordinates = geometry.getFlatCoordinates();
        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (builderEnd > builderBegin) {
          this.instructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            inflateCoordinates
          ]);
          this.hitDetectionInstructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinates
          ]);
        }
        break;
      case "Point":
        flatCoordinates = geometry.getFlatCoordinates();
        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
        builderEnd = this.coordinates.length;
        this.instructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          renderer
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.CUSTOM,
          builderBegin,
          builderEnd,
          geometry,
          hitDetectionRenderer || renderer
        ]);
        break;
      default:
    }
    this.endGeometry(feature);
  }
  beginGeometry(geometry, feature) {
    this.beginGeometryInstruction1_ = [
      Instruction_default.BEGIN_GEOMETRY,
      feature,
      0,
      geometry
    ];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [
      Instruction_default.BEGIN_GEOMETRY,
      feature,
      0,
      geometry
    ];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  reverseHitDetectionInstructions() {
    const hitDetectionInstructions = this.hitDetectionInstructions;
    hitDetectionInstructions.reverse();
    let i;
    const n = hitDetectionInstructions.length;
    let instruction;
    let type;
    let begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = instruction[0];
      if (type == Instruction_default.END_GEOMETRY) {
        begin = i;
      } else if (type == Instruction_default.BEGIN_GEOMETRY) {
        instruction[2] = i;
        reverseSubArray(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  }
  setFillStrokeStyle(fillStyle, strokeStyle) {
    const state = this.state;
    if (fillStyle) {
      const fillStyleColor = fillStyle.getColor();
      state.fillStyle = asColorLike(
        fillStyleColor ? fillStyleColor : defaultFillStyle
      );
    } else {
      state.fillStyle = void 0;
    }
    if (strokeStyle) {
      const strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = asColorLike(
        strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
      );
      const strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
      const strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
      const strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = void 0;
      state.lineCap = void 0;
      state.lineDash = null;
      state.lineDashOffset = void 0;
      state.lineJoin = void 0;
      state.lineWidth = void 0;
      state.miterLimit = void 0;
    }
  }
  createFill(state) {
    const fillStyle = state.fillStyle;
    const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== "string") {
      fillInstruction2.push(true);
    }
    return fillInstruction2;
  }
  applyStroke(state) {
    this.instructions.push(this.createStroke(state));
  }
  createStroke(state) {
    return [
      Instruction_default.SET_STROKE_STYLE,
      state.strokeStyle,
      state.lineWidth * this.pixelRatio,
      state.lineCap,
      state.lineJoin,
      state.miterLimit,
      this.applyPixelRatio(state.lineDash),
      state.lineDashOffset * this.pixelRatio
    ];
  }
  updateFillStyle(state, createFill) {
    const fillStyle = state.fillStyle;
    if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
      if (fillStyle !== void 0) {
        this.instructions.push(createFill.call(this, state));
      }
      state.currentFillStyle = fillStyle;
    }
  }
  updateStrokeStyle(state, applyStroke) {
    const strokeStyle = state.strokeStyle;
    const lineCap = state.lineCap;
    const lineDash = state.lineDash;
    const lineDashOffset = state.lineDashOffset;
    const lineJoin = state.lineJoin;
    const lineWidth = state.lineWidth;
    const miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== void 0) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  }
  endGeometry(feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  }
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = clone(this.maxExtent);
      if (this.maxLineWidth > 0) {
        const width = this.resolution * (this.maxLineWidth + 1) / 2;
        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  }
};
var Builder_default = CanvasBuilder;

// node_modules/ol/render/canvas/ImageBuilder.js
var CanvasImageBuilder = class extends Builder_default {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.height_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.scale_ = void 0;
    this.width_ = void 0;
    this.declutterMode_ = void 0;
    this.declutterImageWithText_ = void 0;
  }
  drawPoint(pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    const flatCoordinates = pointGeometry.getFlatCoordinates();
    const stride = pointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature);
  }
  drawMultiPoint(multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    const flatCoordinates = multiPointGeometry.getFlatCoordinates();
    const stride = multiPointGeometry.getStride();
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.image_,
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.hitDetectionInstructions.push([
      Instruction_default.DRAW_IMAGE,
      myBegin,
      myEnd,
      this.hitDetectionImage_,
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]);
    this.endGeometry(feature);
  }
  finish() {
    this.reverseHitDetectionInstructions();
    this.anchorX_ = void 0;
    this.anchorY_ = void 0;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = void 0;
    this.height_ = void 0;
    this.scale_ = void 0;
    this.opacity_ = void 0;
    this.originX_ = void 0;
    this.originY_ = void 0;
    this.rotateWithView_ = void 0;
    this.rotation_ = void 0;
    this.width_ = void 0;
    return super.finish();
  }
  setImageStyle(imageStyle, sharedData) {
    const anchor = imageStyle.getAnchor();
    const size = imageStyle.getSize();
    const origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
    this.image_ = imageStyle.getImage(this.pixelRatio);
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterMode_ = imageStyle.getDeclutterMode();
    this.declutterImageWithText_ = sharedData;
  }
};
var ImageBuilder_default = CanvasImageBuilder;

// node_modules/ol/render/canvas/LineStringBuilder.js
var CanvasLineStringBuilder = class extends Builder_default {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }
  drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
    const myBegin = this.coordinates.length;
    const myEnd = this.appendFlatLineCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      false,
      false
    );
    const moveToLineToInstruction = [
      Instruction_default.MOVE_TO_LINE_TO,
      myBegin,
      myEnd
    ];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  }
  drawLineString(lineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push(
      [
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ],
      beginPathInstruction
    );
    const flatCoordinates = lineStringGeometry.getFlatCoordinates();
    const stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride
    );
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature);
  }
  drawMultiLineString(multiLineStringGeometry, feature) {
    const state = this.state;
    const strokeStyle = state.strokeStyle;
    const lineWidth = state.lineWidth;
    if (strokeStyle === void 0 || lineWidth === void 0) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push(
      [
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ],
      beginPathInstruction
    );
    const ends = multiLineStringGeometry.getEnds();
    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    const stride = multiLineStringGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(
        flatCoordinates,
        offset,
        ends[i],
        stride
      );
    }
    this.hitDetectionInstructions.push(strokeInstruction);
    this.endGeometry(feature);
  }
  finish() {
    const state = this.state;
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
    return super.finish();
  }
  applyStroke(state) {
    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
      this.instructions.push(strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    super.applyStroke(state);
    this.instructions.push(beginPathInstruction);
  }
};
var LineStringBuilder_default = CanvasLineStringBuilder;

// node_modules/ol/render/canvas/PolygonBuilder.js
var CanvasPolygonBuilder = class extends Builder_default {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
  }
  drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
    const state = this.state;
    const fill = state.fillStyle !== void 0;
    const stroke = state.strokeStyle !== void 0;
    const numEnds = ends.length;
    this.instructions.push(beginPathInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction);
    for (let i = 0; i < numEnds; ++i) {
      const end = ends[i];
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset,
        end,
        stride,
        true,
        !stroke
      );
      const moveToLineToInstruction = [
        Instruction_default.MOVE_TO_LINE_TO,
        myBegin,
        myEnd
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        this.instructions.push(closePathInstruction);
        this.hitDetectionInstructions.push(closePathInstruction);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (stroke) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    return offset;
  }
  drawCircle(circleGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ]);
    }
    const flatCoordinates = circleGeometry.getFlatCoordinates();
    const stride = circleGeometry.getStride();
    const myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride,
      false,
      false
    );
    const circleInstruction = [Instruction_default.CIRCLE, myBegin];
    this.instructions.push(beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
    if (state.fillStyle !== void 0) {
      this.instructions.push(fillInstruction);
      this.hitDetectionInstructions.push(fillInstruction);
    }
    if (state.strokeStyle !== void 0) {
      this.instructions.push(strokeInstruction);
      this.hitDetectionInstructions.push(strokeInstruction);
    }
    this.endGeometry(feature);
  }
  drawPolygon(polygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ]);
    }
    const ends = polygonGeometry.getEnds();
    const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    const stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(
      flatCoordinates,
      0,
      ends,
      stride
    );
    this.endGeometry(feature);
  }
  drawMultiPolygon(multiPolygonGeometry, feature) {
    const state = this.state;
    const fillStyle = state.fillStyle;
    const strokeStyle = state.strokeStyle;
    if (fillStyle === void 0 && strokeStyle === void 0) {
      return;
    }
    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_FILL_STYLE,
        defaultFillStyle
      ]);
    }
    if (state.strokeStyle !== void 0) {
      this.hitDetectionInstructions.push([
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        defaultLineDash,
        defaultLineDashOffset
      ]);
    }
    const endss = multiPolygonGeometry.getEndss();
    const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    const stride = multiPolygonGeometry.getStride();
    let offset = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(
        flatCoordinates,
        offset,
        endss[i],
        stride
      );
    }
    this.endGeometry(feature);
  }
  finish() {
    this.reverseHitDetectionInstructions();
    this.state = null;
    const tolerance = this.tolerance;
    if (tolerance !== 0) {
      const coordinates2 = this.coordinates;
      for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
        coordinates2[i] = snap(coordinates2[i], tolerance);
      }
    }
    return super.finish();
  }
  setFillStrokeStyles_() {
    const state = this.state;
    const fillStyle = state.fillStyle;
    if (fillStyle !== void 0) {
      this.updateFillStyle(state, this.createFill);
    }
    if (state.strokeStyle !== void 0) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  }
};
var PolygonBuilder_default = CanvasPolygonBuilder;

// node_modules/ol/geom/flat/linechunk.js
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
  const chunks = [];
  let cursor = offset;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = lerp(x1, x2, m);
      const y = lerp(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = lerp(x1, x2, missing / segmentLength);
      const y = lerp(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}

// node_modules/ol/geom/flat/straightchunk.js
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  let chunkStart = offset;
  let chunkEnd = offset;
  let chunkM = 0;
  let m = 0;
  let start = offset;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}

// node_modules/ol/render/canvas/TextBuilder.js
var TEXT_ALIGN = {
  "left": 0,
  "center": 0.5,
  "right": 1,
  "top": 0,
  "middle": 0.5,
  "hanging": 0.2,
  "alphabetic": 0.8,
  "ideographic": 0.8,
  "bottom": 1
};
var CanvasTextBuilder = class extends Builder_default {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    super(tolerance, maxExtent, resolution, pixelRatio);
    this.labels_ = null;
    this.text_ = "";
    this.textOffsetX_ = 0;
    this.textOffsetY_ = 0;
    this.textRotateWithView_ = void 0;
    this.textRotation_ = 0;
    this.textFillState_ = null;
    this.fillStates = {};
    this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
    this.textStrokeState_ = null;
    this.strokeStates = {};
    this.textState_ = {};
    this.textStates = {};
    this.textKey_ = "";
    this.fillKey_ = "";
    this.strokeKey_ = "";
    this.declutterImageWithText_ = void 0;
  }
  finish() {
    const instructions = super.finish();
    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  }
  drawText(geometry, feature) {
    const fillState = this.textFillState_;
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    if (this.text_ === "" || !textState || !fillState && !strokeState) {
      return;
    }
    const coordinates2 = this.coordinates;
    let begin = coordinates2.length;
    const geometryType = geometry.getType();
    let flatCoordinates = null;
    let stride = geometry.getStride();
    if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      let ends;
      flatCoordinates = geometry.getFlatCoordinates();
      if (geometryType == "LineString") {
        ends = [flatCoordinates.length];
      } else if (geometryType == "MultiLineString") {
        ends = geometry.getEnds();
      } else if (geometryType == "Polygon") {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == "MultiPolygon") {
        const endss = geometry.getEndss();
        ends = [];
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      const repeat = textState.repeat;
      const textAlign = repeat ? void 0 : textState.textAlign;
      let flatOffset = 0;
      for (let o = 0, oo = ends.length; o < oo; ++o) {
        let chunks;
        if (repeat) {
          chunks = lineChunk(
            repeat * this.resolution,
            flatCoordinates,
            flatOffset,
            ends[o],
            stride
          );
        } else {
          chunks = [flatCoordinates.slice(flatOffset, ends[o])];
        }
        for (let c = 0, cc = chunks.length; c < cc; ++c) {
          const chunk = chunks[c];
          let chunkBegin = 0;
          let chunkEnd = chunk.length;
          if (textAlign == void 0) {
            const range = matchingChunk(
              textState.maxAngle,
              chunk,
              0,
              chunk.length,
              2
            );
            chunkBegin = range[0];
            chunkEnd = range[1];
          }
          for (let i = chunkBegin; i < chunkEnd; i += stride) {
            coordinates2.push(chunk[i], chunk[i + 1]);
          }
          const end = coordinates2.length;
          flatOffset = ends[o];
          this.drawChars_(begin, end);
          begin = end;
        }
      }
      this.endGeometry(feature);
    } else {
      let geometryWidths = textState.overflow ? null : [];
      switch (geometryType) {
        case "Point":
        case "MultiPoint":
          flatCoordinates = geometry.getFlatCoordinates();
          break;
        case "LineString":
          flatCoordinates = geometry.getFlatMidpoint();
          break;
        case "Circle":
          flatCoordinates = geometry.getCenter();
          break;
        case "MultiLineString":
          flatCoordinates = geometry.getFlatMidpoints();
          stride = 2;
          break;
        case "Polygon":
          flatCoordinates = geometry.getFlatInteriorPoint();
          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }
          stride = 3;
          break;
        case "MultiPolygon":
          const interiorPoints = geometry.getFlatInteriorPoints();
          flatCoordinates = [];
          for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
          if (flatCoordinates.length === 0) {
            return;
          }
          stride = 2;
          break;
        default:
      }
      const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
      if (end === begin) {
        return;
      }
      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
        let beg = begin / 2;
        geometryWidths = geometryWidths.filter((w, i) => {
          const keep = coordinates2[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates2[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
          if (!keep) {
            --beg;
          }
          return keep;
        });
      }
      this.saveTextStates_();
      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(
          textState.backgroundFill,
          textState.backgroundStroke
        );
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }
      this.beginGeometry(geometry, feature);
      let padding = textState.padding;
      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
        let p0 = textState.padding[0];
        let p12 = textState.padding[1];
        let p22 = textState.padding[2];
        let p32 = textState.padding[3];
        if (textState.scale[0] < 0) {
          p12 = -p12;
          p32 = -p32;
        }
        if (textState.scale[1] < 0) {
          p0 = -p0;
          p22 = -p22;
        }
        padding = [p0, p12, p22, p32];
      }
      const pixelRatio = this.pixelRatio;
      this.instructions.push([
        Instruction_default.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        void 0,
        this.declutterImageWithText_,
        padding == defaultPadding ? defaultPadding : padding.map(function(p) {
          return p * pixelRatio;
        }),
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      const scale4 = 1 / pixelRatio;
      const currentFillStyle = this.state.fillStyle;
      if (textState.backgroundFill) {
        this.state.fillStyle = defaultFillStyle;
        this.hitDetectionInstructions.push(this.createFill(this.state));
      }
      this.hitDetectionInstructions.push([
        Instruction_default.DRAW_IMAGE,
        begin,
        end,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [scale4, scale4],
        NaN,
        void 0,
        this.declutterImageWithText_,
        padding,
        !!textState.backgroundFill,
        !!textState.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? defaultFillStyle : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        geometryWidths
      ]);
      if (textState.backgroundFill) {
        this.state.fillStyle = currentFillStyle;
        this.hitDetectionInstructions.push(this.createFill(this.state));
      }
      this.endGeometry(feature);
    }
  }
  saveTextStates_() {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const fillState = this.textFillState_;
    const strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }
    const textKey = this.textKey_;
    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || defaultTextAlign,
        justify: textState.justify,
        textBaseline: textState.textBaseline || defaultTextBaseline,
        scale: textState.scale
      };
    }
    const fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  }
  drawChars_(begin, end) {
    const strokeState = this.textStrokeState_;
    const textState = this.textState_;
    const strokeKey = this.strokeKey_;
    const textKey = this.textKey_;
    const fillKey = this.fillKey_;
    this.saveTextStates_();
    const pixelRatio = this.pixelRatio;
    const baseline = TEXT_ALIGN[textState.textBaseline];
    const offsetY = this.textOffsetY_ * pixelRatio;
    const text = this.text_;
    const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
    this.instructions.push([
      Instruction_default.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey,
      textState.maxAngle,
      pixelRatio,
      offsetY,
      strokeKey,
      strokeWidth * pixelRatio,
      text,
      textKey,
      1
    ]);
    this.hitDetectionInstructions.push([
      Instruction_default.DRAW_CHARS,
      begin,
      end,
      baseline,
      textState.overflow,
      fillKey ? defaultFillStyle : fillKey,
      textState.maxAngle,
      1,
      offsetY,
      strokeKey,
      strokeWidth,
      text,
      textKey,
      1 / pixelRatio
    ]);
  }
  setTextStyle(textStyle, sharedData) {
    let textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = "";
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = {};
          this.textFillState_ = fillState;
        }
        fillState.fillStyle = asColorLike(
          textFillStyle.getColor() || defaultFillStyle
        );
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = {};
          this.textStrokeState_ = strokeState;
        }
        const lineDash = textStrokeStyle.getLineDash();
        const lineDashOffset = textStrokeStyle.getLineDashOffset();
        const lineWidth = textStrokeStyle.getWidth();
        const miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
        strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = asColorLike(
          textStrokeStyle.getColor() || defaultStrokeStyle
        );
      }
      textState = this.textState_;
      const font = textStyle.getFont() || defaultFont;
      registerFont(font);
      const textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.repeat = textStyle.getRepeat();
      textState.justify = textStyle.getJustify();
      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || defaultPadding;
      textState.scale = textScale === void 0 ? [1, 1] : textScale;
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || "";
      this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
      this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
      this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
    }
    this.declutterImageWithText_ = sharedData;
  }
};
var TextBuilder_default = CanvasTextBuilder;

// node_modules/ol/render/canvas/BuilderGroup.js
var BATCH_CONSTRUCTORS = {
  "Circle": PolygonBuilder_default,
  "Default": Builder_default,
  "Image": ImageBuilder_default,
  "LineString": LineStringBuilder_default,
  "Polygon": PolygonBuilder_default,
  "Text": TextBuilder_default
};
var BuilderGroup = class {
  constructor(tolerance, maxExtent, resolution, pixelRatio) {
    this.tolerance_ = tolerance;
    this.maxExtent_ = maxExtent;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.buildersByZIndex_ = {};
  }
  finish() {
    const builderInstructions = {};
    for (const zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      const builders = this.buildersByZIndex_[zKey];
      for (const builderKey in builders) {
        const builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }
    return builderInstructions;
  }
  getBuilder(zIndex, builderType) {
    const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
    let replays = this.buildersByZIndex_[zIndexKey];
    if (replays === void 0) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }
    let replay = replays[builderType];
    if (replay === void 0) {
      const Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      );
      replays[builderType] = replay;
    }
    return replay;
  }
};
var BuilderGroup_default = BuilderGroup;

// node_modules/ol/renderer/Layer.js
var LayerRenderer = class extends Observable_default {
  constructor(layer) {
    super();
    this.ready = true;
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
    this.layer_ = layer;
    this.declutterExecutorGroup = null;
  }
  getFeatures(pixel) {
    return abstract();
  }
  getData(pixel) {
    return null;
  }
  prepareFrame(frameState) {
    return abstract();
  }
  renderFrame(frameState, target) {
    return abstract();
  }
  loadedTileCallback(tiles, zoom, tile) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }
    tiles[zoom][tile.tileCoord.toString()] = tile;
    return void 0;
  }
  createLoadedTileFinder(source, projection, tiles) {
    return (zoom, tileRange) => {
      const callback = this.loadedTileCallback.bind(this, tiles, zoom);
      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    };
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    return void 0;
  }
  getLayer() {
    return this.layer_;
  }
  handleFontsChanged() {
  }
  handleImageChange_(event) {
    const image = event.target;
    if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
      this.renderIfReadyAndVisible();
    }
  }
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
      image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == ImageState_default.IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == ImageState_default.LOADED;
  }
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
      layer.changed();
    }
  }
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
};
var Layer_default2 = LayerRenderer;

// node_modules/ol/renderer/canvas/Layer.js
var canvasPool = [];
var pixelContext = null;
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var CanvasLayerRenderer = class extends Layer_default2 {
  constructor(layer) {
    super(layer);
    this.container = null;
    this.renderedResolution;
    this.tempTransform = create();
    this.pixelTransform = create();
    this.inversePixelTransform = create();
    this.context = null;
    this.containerReused = false;
    this.pixelContext_ = null;
    this.frameState = null;
  }
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      pixelContext = null;
      return null;
    }
    return data;
  }
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === "function") {
      background = background(frameState.viewState.resolution);
    }
    return background || void 0;
  }
  useContainer(target, transform2, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
      asArray(target.style.backgroundColor),
      asArray(backgroundColor)
    ))) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext("2d");
      }
    }
    if (context && context.canvas.style.transform === transform2) {
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      this.container = null;
      this.context = null;
      this.containerReused = false;
    } else if (this.container) {
      this.container.style.backgroundColor = null;
    }
    if (!this.container) {
      container = document.createElement("div");
      container.className = layerClassName;
      let style = container.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      context = createCanvasContext2D();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = "absolute";
      style.left = "0";
      style.transformOrigin = "top left";
      this.container = container;
      this.context = context;
    }
    if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }
  clipUnrotated(context, frameState, extent) {
    const topLeft = getTopLeft(extent);
    const topRight = getTopRight(extent);
    const bottomRight = getBottomRight(extent);
    const bottomLeft = getBottomLeft(extent);
    apply(frameState.coordinateToPixelTransform, topLeft);
    apply(frameState.coordinateToPixelTransform, topRight);
    apply(frameState.coordinateToPixelTransform, bottomRight);
    apply(frameState.coordinateToPixelTransform, bottomLeft);
    const inverted = this.inversePixelTransform;
    apply(inverted, topLeft);
    apply(inverted, topRight);
    apply(inverted, bottomRight);
    apply(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new Event_default2(
        type,
        this.inversePixelTransform,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }
  preRender(context, frameState) {
    this.frameState = frameState;
    this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
  }
  postRender(context, frameState) {
    this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
  }
  getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return compose(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2
    );
  }
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
};
var Layer_default3 = CanvasLayerRenderer;

// node_modules/ol/geom/flat/textpath.js
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale4, measureAndCacheTextWidth2, font, cache2, rotation) {
  let x2 = flatCoordinates[offset];
  let y2 = flatCoordinates[offset + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp(x1, x2, interpolate);
  const beginY = lerp(y1, y2, interpolate);
  const startOffset = offset - stride;
  const startLength = segmentM;
  const endM = startM + scale4 * measureAndCacheTextWidth2(font, text, cache2);
  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp(x1, x2, interpolate);
  const endY = lerp(y1, y2, interpolate);
  let reverse;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    rotate2(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }
  text = text.replace(/\n/g, " ");
  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale4 * measureAndCacheTextWidth2(font, text[index], cache2);
      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = lerp(x1, x2, interpolate);
    const y = lerp(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i = offset + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}

// node_modules/ol/render/canvas/Executor.js
var tmpExtent = createEmpty();
var p1 = [];
var p2 = [];
var p3 = [];
var p4 = [];
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp(
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
);
function horizontalTextAlign(text, align) {
  if (align === "start") {
    align = rtlRegEx.test(text) ? "right" : "left";
  } else if (align === "end") {
    align = rtlRegEx.test(text) ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
var Executor = class {
  constructor(resolution, pixelRatio, overlaps, instructions) {
    this.overlaps = overlaps;
    this.pixelRatio = pixelRatio;
    this.resolution = resolution;
    this.alignFill_;
    this.instructions = instructions.instructions;
    this.coordinates = instructions.coordinates;
    this.coordinateCache_ = {};
    this.renderedTransform_ = create();
    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    this.pixelCoordinates_ = null;
    this.viewRotation_ = 0;
    this.fillStates = instructions.fillStates || {};
    this.strokeStates = instructions.strokeStates || {};
    this.textStates = instructions.textStates || {};
    this.widths_ = {};
    this.labels_ = {};
  }
  createLabel(text, textKey, fillKey, strokeKey) {
    const key = text + textKey + fillKey + strokeKey;
    if (this.labels_[key]) {
      return this.labels_[key];
    }
    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    const fillState = fillKey ? this.fillStates[fillKey] : null;
    const textState = this.textStates[textKey];
    const pixelRatio = this.pixelRatio;
    const scale4 = [
      textState.scale[0] * pixelRatio,
      textState.scale[1] * pixelRatio
    ];
    const textIsArray = Array.isArray(text);
    const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
      Array.isArray(text) ? text[0] : text,
      textState.textAlign || defaultTextAlign
    );
    const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    const chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
    const { width, height, widths, heights, lineWidths } = getTextDimensions(
      textState,
      chunks
    );
    const renderWidth = width + strokeWidth;
    const contextInstructions = [];
    const w = (renderWidth + 2) * scale4[0];
    const h = (height + strokeWidth) * scale4[1];
    const label = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: h < 0 ? Math.floor(h) : Math.ceil(h),
      contextInstructions
    };
    if (scale4[0] != 1 || scale4[1] != 1) {
      contextInstructions.push("scale", scale4);
    }
    if (strokeKey) {
      contextInstructions.push("strokeStyle", strokeState.strokeStyle);
      contextInstructions.push("lineWidth", strokeWidth);
      contextInstructions.push("lineCap", strokeState.lineCap);
      contextInstructions.push("lineJoin", strokeState.lineJoin);
      contextInstructions.push("miterLimit", strokeState.miterLimit);
      contextInstructions.push("setLineDash", [strokeState.lineDash]);
      contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
    }
    if (fillKey) {
      contextInstructions.push("fillStyle", fillState.fillStyle);
    }
    contextInstructions.push("textBaseline", "middle");
    contextInstructions.push("textAlign", "center");
    const leftRight = 0.5 - align;
    let x = align * renderWidth + leftRight * strokeWidth;
    const strokeInstructions = [];
    const fillInstructions = [];
    let lineHeight = 0;
    let lineOffset = 0;
    let widthHeightIndex = 0;
    let lineWidthIndex = 0;
    let previousFont;
    for (let i = 0, ii = chunks.length; i < ii; i += 2) {
      const text2 = chunks[i];
      if (text2 === "\n") {
        lineOffset += lineHeight;
        lineHeight = 0;
        x = align * renderWidth + leftRight * strokeWidth;
        ++lineWidthIndex;
        continue;
      }
      const font = chunks[i + 1] || textState.font;
      if (font !== previousFont) {
        if (strokeKey) {
          strokeInstructions.push("font", font);
        }
        if (fillKey) {
          fillInstructions.push("font", font);
        }
        previousFont = font;
      }
      lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
      const fillStrokeArgs = [
        text2,
        x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
        0.5 * (strokeWidth + lineHeight) + lineOffset
      ];
      x += widths[widthHeightIndex];
      if (strokeKey) {
        strokeInstructions.push("strokeText", fillStrokeArgs);
      }
      if (fillKey) {
        fillInstructions.push("fillText", fillStrokeArgs);
      }
      ++widthHeightIndex;
    }
    Array.prototype.push.apply(contextInstructions, strokeInstructions);
    Array.prototype.push.apply(contextInstructions, fillInstructions);
    this.labels_[key] = label;
    return label;
  }
  replayTextBackground_(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
    context.beginPath();
    context.moveTo.apply(context, p12);
    context.lineTo.apply(context, p22);
    context.lineTo.apply(context, p32);
    context.lineTo.apply(context, p42);
    context.lineTo.apply(context, p12);
    if (fillInstruction2) {
      this.alignFill_ = fillInstruction2[2];
      this.fill_(context);
    }
    if (strokeInstruction2) {
      this.setStrokeStyle_(
        context,
        strokeInstruction2
      );
      context.stroke();
    }
  }
  calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale4, snapToPixel, padding, fillStroke, feature) {
    anchorX *= scale4[0];
    anchorY *= scale4[1];
    let x = centerX - anchorX;
    let y = centerY - anchorY;
    const w = width + originX > sheetWidth ? sheetWidth - originX : width;
    const h = height + originY > sheetHeight ? sheetHeight - originY : height;
    const boxW = padding[3] + w * scale4[0] + padding[1];
    const boxH = padding[0] + h * scale4[1] + padding[2];
    const boxX = x - padding[3];
    const boxY = y - padding[0];
    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }
    let transform2;
    if (rotation !== 0) {
      transform2 = compose(
        create(),
        centerX,
        centerY,
        1,
        1,
        rotation,
        -centerX,
        -centerY
      );
      apply(transform2, p1);
      apply(transform2, p2);
      apply(transform2, p3);
      apply(transform2, p4);
      createOrUpdate(
        Math.min(p1[0], p2[0], p3[0], p4[0]),
        Math.min(p1[1], p2[1], p3[1], p4[1]),
        Math.max(p1[0], p2[0], p3[0], p4[0]),
        Math.max(p1[1], p2[1], p3[1], p4[1]),
        tmpExtent
      );
    } else {
      createOrUpdate(
        Math.min(boxX, boxX + boxW),
        Math.min(boxY, boxY + boxH),
        Math.max(boxX, boxX + boxW),
        Math.max(boxY, boxY + boxH),
        tmpExtent
      );
    }
    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }
    return {
      drawImageX: x,
      drawImageY: y,
      drawImageW: w,
      drawImageH: h,
      originX,
      originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature
      },
      canvasTransform: transform2,
      scale: scale4
    };
  }
  replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
    const fillStroke = !!(fillInstruction2 || strokeInstruction2);
    const box = dimensions.declutterBox;
    const canvas = context.canvas;
    const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
    const intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
    if (intersects2) {
      if (fillStroke) {
        this.replayTextBackground_(
          context,
          p1,
          p2,
          p3,
          p4,
          fillInstruction2,
          strokeInstruction2
        );
      }
      drawImageOrLabel(
        context,
        dimensions.canvasTransform,
        opacity,
        imageOrLabel,
        dimensions.originX,
        dimensions.originY,
        dimensions.drawImageW,
        dimensions.drawImageH,
        dimensions.drawImageX,
        dimensions.drawImageY,
        dimensions.scale
      );
    }
    return true;
  }
  fill_(context) {
    if (this.alignFill_) {
      const origin = apply(this.renderedTransform_, [0, 0]);
      const repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.restore();
    }
  }
  setStrokeStyle_(context, instruction) {
    context["strokeStyle"] = instruction[1];
    context.lineWidth = instruction[2];
    context.lineCap = instruction[3];
    context.lineJoin = instruction[4];
    context.miterLimit = instruction[5];
    context.lineDashOffset = instruction[7];
    context.setLineDash(instruction[6]);
  }
  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
    const textState = this.textStates[textKey];
    const label = this.createLabel(text, textKey, fillKey, strokeKey);
    const strokeState = this.strokeStates[strokeKey];
    const pixelRatio = this.pixelRatio;
    const align = horizontalTextAlign(
      Array.isArray(text) ? text[0] : text,
      textState.textAlign || defaultTextAlign
    );
    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
    const width = label.width / pixelRatio - 2 * textState.scale[0];
    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label,
      anchorX,
      anchorY
    };
  }
  execute_(context, contextScale, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
    let pixelCoordinates;
    if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = transform2D(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        transform2,
        this.pixelCoordinates_
      );
      setFromArray(this.renderedTransform_, transform2);
    }
    let i = 0;
    const ii = instructions.length;
    let d = 0;
    let dd;
    let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
    let pendingFill = 0;
    let pendingStroke = 0;
    let lastFillInstruction = null;
    let lastStrokeInstruction = null;
    const coordinateCache = this.coordinateCache_;
    const viewRotation = this.viewRotation_;
    const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
    const state = {
      context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    };
    const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    let feature;
    let x, y, currentGeometry;
    while (i < ii) {
      const instruction = instructions[i];
      const type = instruction[0];
      switch (type) {
        case Instruction_default.BEGIN_GEOMETRY:
          feature = instruction[1];
          currentGeometry = instruction[3];
          if (!feature.getGeometry()) {
            i = instruction[2];
          } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
            i = instruction[2] + 1;
          } else {
            ++i;
          }
          break;
        case Instruction_default.BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }
          ++i;
          break;
        case Instruction_default.CIRCLE:
          d = instruction[1];
          const x1 = pixelCoordinates[d];
          const y1 = pixelCoordinates[d + 1];
          const x2 = pixelCoordinates[d + 2];
          const y2 = pixelCoordinates[d + 3];
          const dx = x2 - x1;
          const dy = y2 - y1;
          const r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case Instruction_default.CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case Instruction_default.CUSTOM:
          d = instruction[1];
          dd = instruction[2];
          const geometry = instruction[3];
          const renderer = instruction[4];
          const fn = instruction.length == 6 ? instruction[5] : void 0;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          const coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i;
          break;
        case Instruction_default.DRAW_IMAGE:
          d = instruction[1];
          dd = instruction[2];
          image = instruction[3];
          anchorX = instruction[4];
          anchorY = instruction[5];
          let height = instruction[6];
          const opacity = instruction[7];
          const originX = instruction[8];
          const originY = instruction[9];
          const rotateWithView = instruction[10];
          let rotation = instruction[11];
          const scale4 = instruction[12];
          let width = instruction[13];
          const declutterMode = instruction[14];
          const declutterImageWithText = instruction[15];
          if (!image && instruction.length >= 20) {
            text = instruction[19];
            textKey = instruction[20];
            strokeKey = instruction[21];
            fillKey = instruction[22];
            const labelWithAnchor = this.drawLabelWithPointPlacement_(
              text,
              textKey,
              strokeKey,
              fillKey
            );
            image = labelWithAnchor.label;
            instruction[3] = image;
            const textOffsetX = instruction[23];
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            const textOffsetY = instruction[24];
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[6] = height;
            width = image.width;
            instruction[13] = width;
          }
          let geometryWidths;
          if (instruction.length > 25) {
            geometryWidths = instruction[25];
          }
          let padding, backgroundFill, backgroundStroke;
          if (instruction.length > 17) {
            padding = instruction[16];
            backgroundFill = instruction[17];
            backgroundStroke = instruction[18];
          } else {
            padding = defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }
          if (rotateWithView && viewRotationFromTransform) {
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            rotation -= viewRotation;
          }
          let widthIndex = 0;
          for (; d < dd; d += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }
            const dimensions = this.calculateImageOrLabelDimensions_(
              image.width,
              image.height,
              pixelCoordinates[d],
              pixelCoordinates[d + 1],
              width,
              height,
              anchorX,
              anchorY,
              originX,
              originY,
              rotation,
              scale4,
              snapToPixel,
              padding,
              backgroundFill || backgroundStroke,
              feature
            );
            const args = [
              context,
              contextScale,
              image,
              dimensions,
              opacity,
              backgroundFill ? lastFillInstruction : null,
              backgroundStroke ? lastStrokeInstruction : null
            ];
            if (declutterTree) {
              if (declutterMode === "none") {
                continue;
              } else if (declutterMode === "obstacle") {
                declutterTree.insert(dimensions.declutterBox);
                continue;
              } else {
                let imageArgs;
                let imageDeclutterBox;
                if (declutterImageWithText) {
                  const index = dd - d;
                  if (!declutterImageWithText[index]) {
                    declutterImageWithText[index] = args;
                    continue;
                  }
                  imageArgs = declutterImageWithText[index];
                  delete declutterImageWithText[index];
                  imageDeclutterBox = getDeclutterBox(imageArgs);
                  if (declutterTree.collides(imageDeclutterBox)) {
                    continue;
                  }
                }
                if (declutterTree.collides(dimensions.declutterBox)) {
                  continue;
                }
                if (imageArgs) {
                  declutterTree.insert(imageDeclutterBox);
                  this.replayImageOrLabel_.apply(this, imageArgs);
                }
                declutterTree.insert(dimensions.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, args);
          }
          ++i;
          break;
        case Instruction_default.DRAW_CHARS:
          const begin = instruction[1];
          const end = instruction[2];
          const baseline = instruction[3];
          const overflow = instruction[4];
          fillKey = instruction[5];
          const maxAngle = instruction[6];
          const measurePixelRatio = instruction[7];
          const offsetY = instruction[8];
          strokeKey = instruction[9];
          const strokeWidth = instruction[10];
          text = instruction[11];
          textKey = instruction[12];
          const pixelRatioScale = [
            instruction[13],
            instruction[13]
          ];
          const textState = this.textStates[textKey];
          const font = textState.font;
          const textScale = [
            textState.scale[0] * measurePixelRatio,
            textState.scale[1] * measurePixelRatio
          ];
          let cachedWidths;
          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }
          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
          const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
          if (overflow || textLength <= pathLength) {
            const textAlign = this.textStates[textKey].textAlign;
            const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
            const parts = drawTextOnPath(
              pixelCoordinates,
              begin,
              end,
              2,
              text,
              startM,
              maxAngle,
              Math.abs(textScale[0]),
              measureAndCacheTextWidth,
              font,
              cachedWidths,
              viewRotationFromTransform ? 0 : this.viewRotation_
            );
            drawChars:
              if (parts) {
                const replayImageOrLabelArgs = [];
                let c, cc, chars, label, part;
                if (strokeKey) {
                  for (c = 0, cc = parts.length; c < cc; ++c) {
                    part = parts[c];
                    chars = part[4];
                    label = this.createLabel(chars, textKey, "", strokeKey);
                    anchorX = part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                    const dimensions = this.calculateImageOrLabelDimensions_(
                      label.width,
                      label.height,
                      part[0],
                      part[1],
                      label.width,
                      label.height,
                      anchorX,
                      anchorY,
                      0,
                      0,
                      part[3],
                      pixelRatioScale,
                      false,
                      defaultPadding,
                      false,
                      feature
                    );
                    if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([
                      context,
                      contextScale,
                      label,
                      dimensions,
                      1,
                      null,
                      null
                    ]);
                  }
                }
                if (fillKey) {
                  for (c = 0, cc = parts.length; c < cc; ++c) {
                    part = parts[c];
                    chars = part[4];
                    label = this.createLabel(chars, textKey, fillKey, "");
                    anchorX = part[2];
                    anchorY = baseline * label.height - offsetY;
                    const dimensions = this.calculateImageOrLabelDimensions_(
                      label.width,
                      label.height,
                      part[0],
                      part[1],
                      label.width,
                      label.height,
                      anchorX,
                      anchorY,
                      0,
                      0,
                      part[3],
                      pixelRatioScale,
                      false,
                      defaultPadding,
                      false,
                      feature
                    );
                    if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                      break drawChars;
                    }
                    replayImageOrLabelArgs.push([
                      context,
                      contextScale,
                      label,
                      dimensions,
                      1,
                      null,
                      null
                    ]);
                  }
                }
                if (declutterTree) {
                  declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                }
                for (let i2 = 0, ii2 = replayImageOrLabelArgs.length; i2 < ii2; ++i2) {
                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i2]);
                }
              }
          }
          ++i;
          break;
        case Instruction_default.END_GEOMETRY:
          if (featureCallback !== void 0) {
            feature = instruction[1];
            const result = featureCallback(feature, currentGeometry);
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case Instruction_default.FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i;
          break;
        case Instruction_default.MOVE_TO_LINE_TO:
          d = instruction[1];
          dd = instruction[2];
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case Instruction_default.SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];
          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }
          context.fillStyle = instruction[1];
          ++i;
          break;
        case Instruction_default.SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context, instruction);
          ++i;
          break;
        case Instruction_default.STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default:
          ++i;
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return void 0;
  }
  execute(context, contextScale, transform2, viewRotation, snapToPixel, declutterTree) {
    this.viewRotation_ = viewRotation;
    this.execute_(
      context,
      contextScale,
      transform2,
      this.instructions,
      snapToPixel,
      void 0,
      void 0,
      declutterTree
    );
  }
  executeHitDetection(context, transform2, viewRotation, featureCallback, hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(
      context,
      1,
      transform2,
      this.hitDetectionInstructions,
      true,
      featureCallback,
      hitExtent
    );
  }
};
var Executor_default = Executor;

// node_modules/ol/render/canvas/ExecutorGroup.js
var ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
var ExecutorGroup = class {
  constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
    this.maxExtent_ = maxExtent;
    this.overlaps_ = overlaps;
    this.pixelRatio_ = pixelRatio;
    this.resolution_ = resolution;
    this.renderBuffer_ = renderBuffer;
    this.executorsByZIndex_ = {};
    this.hitDetectionContext_ = null;
    this.hitDetectionTransform_ = create();
    this.createExecutors_(allInstructions);
  }
  clip(context, transform2) {
    const flatClipCoords = this.getClipCoords(transform2);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  }
  createExecutors_(allInstructions) {
    for (const zIndex in allInstructions) {
      let executors = this.executorsByZIndex_[zIndex];
      if (executors === void 0) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }
      const instructionByZindex = allInstructions[zIndex];
      for (const builderType in instructionByZindex) {
        const instructions = instructionByZindex[builderType];
        executors[builderType] = new Executor_default(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          instructions
        );
      }
    }
  }
  hasExecutors(executors) {
    for (const zIndex in this.executorsByZIndex_) {
      const candidates = this.executorsByZIndex_[zIndex];
      for (let i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  }
  forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    const contextSize = hitTolerance * 2 + 1;
    const transform2 = compose(
      this.hitDetectionTransform_,
      hitTolerance + 0.5,
      hitTolerance + 0.5,
      1 / resolution,
      -1 / resolution,
      -rotation,
      -coordinate[0],
      -coordinate[1]
    );
    const newContext = !this.hitDetectionContext_;
    if (newContext) {
      this.hitDetectionContext_ = createCanvasContext2D(
        contextSize,
        contextSize,
        void 0,
        { willReadFrequently: true }
      );
    }
    const context = this.hitDetectionContext_;
    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }
    let hitExtent;
    if (this.renderBuffer_ !== void 0) {
      hitExtent = createEmpty();
      extendCoordinate(hitExtent, coordinate);
      buffer(
        hitExtent,
        resolution * (this.renderBuffer_ + hitTolerance),
        hitExtent
      );
    }
    const indexes = getPixelIndexArray(hitTolerance);
    let builderType;
    function featureCallback(feature, geometry) {
      const imageData = context.getImageData(
        0,
        0,
        contextSize,
        contextSize
      ).data;
      for (let i2 = 0, ii = indexes.length; i2 < ii; i2++) {
        if (imageData[indexes[i2]] > 0) {
          if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
            const idx = (indexes[i2] - 3) / 4;
            const x = hitTolerance - idx % contextSize;
            const y = hitTolerance - (idx / contextSize | 0);
            const result2 = callback(feature, geometry, x * x + y * y);
            if (result2) {
              return result2;
            }
          }
          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }
      return void 0;
    }
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(ascending);
    let i, j, executors, executor, result;
    for (i = zs.length - 1; i >= 0; --i) {
      const zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];
      for (j = ORDER.length - 1; j >= 0; --j) {
        builderType = ORDER[j];
        executor = executors[builderType];
        if (executor !== void 0) {
          result = executor.executeHitDetection(
            context,
            transform2,
            rotation,
            featureCallback,
            hitExtent
          );
          if (result) {
            return result;
          }
        }
      }
    }
    return void 0;
  }
  getClipCoords(transform2) {
    const maxExtent = this.maxExtent_;
    if (!maxExtent) {
      return null;
    }
    const minX = maxExtent[0];
    const minY = maxExtent[1];
    const maxX = maxExtent[2];
    const maxY = maxExtent[3];
    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
    return flatClipCoords;
  }
  isEmpty() {
    return isEmpty(this.executorsByZIndex_);
  }
  execute(context, contextScale, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
    const zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(ascending);
    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform2);
    }
    builderTypes = builderTypes ? builderTypes : ORDER;
    let i, ii, j, jj, replays, replay;
    if (declutterTree) {
      zs.reverse();
    }
    for (i = 0, ii = zs.length; i < ii; ++i) {
      const zIndexKey = zs[i].toString();
      replays = this.executorsByZIndex_[zIndexKey];
      for (j = 0, jj = builderTypes.length; j < jj; ++j) {
        const builderType = builderTypes[j];
        replay = replays[builderType];
        if (replay !== void 0) {
          replay.execute(
            context,
            contextScale,
            transform2,
            viewRotation,
            snapToPixel,
            declutterTree
          );
        }
      }
    }
    if (this.maxExtent_) {
      context.restore();
    }
  }
};
var circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance = distances[distanceSq];
      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }
      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var ExecutorGroup_default = ExecutorGroup;

// node_modules/ol/render/canvas/Immediate.js
var CanvasImmediateRenderer = class extends VectorContext_default {
  constructor(context, pixelRatio, extent, transform2, viewRotation, squaredTolerance, userTransform) {
    super();
    this.context_ = context;
    this.pixelRatio_ = pixelRatio;
    this.extent_ = extent;
    this.transform_ = transform2;
    this.transformRotation_ = transform2 ? toFixed(Math.atan2(transform2[1], transform2[0]), 10) : 0;
    this.viewRotation_ = viewRotation;
    this.squaredTolerance_ = squaredTolerance;
    this.userTransform_ = userTransform;
    this.contextFillState_ = null;
    this.contextStrokeState_ = null;
    this.contextTextState_ = null;
    this.fillState_ = null;
    this.strokeState_ = null;
    this.image_ = null;
    this.imageAnchorX_ = 0;
    this.imageAnchorY_ = 0;
    this.imageHeight_ = 0;
    this.imageOpacity_ = 0;
    this.imageOriginX_ = 0;
    this.imageOriginY_ = 0;
    this.imageRotateWithView_ = false;
    this.imageRotation_ = 0;
    this.imageScale_ = [0, 0];
    this.imageWidth_ = 0;
    this.text_ = "";
    this.textOffsetX_ = 0;
    this.textOffsetY_ = 0;
    this.textRotateWithView_ = false;
    this.textRotation_ = 0;
    this.textScale_ = [0, 0];
    this.textFillState_ = null;
    this.textStrokeState_ = null;
    this.textState_ = null;
    this.pixelCoordinates_ = [];
    this.tmpLocalTransform_ = create();
  }
  drawImages_(flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    const pixelCoordinates = transform2D(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    const localTransform = this.tmpLocalTransform_;
    const alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    let rotation = this.imageRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      const x = pixelCoordinates[i] - this.imageAnchorX_;
      const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const centerX = x + this.imageAnchorX_;
        const centerY = y + this.imageAnchorY_;
        compose(
          localTransform,
          centerX,
          centerY,
          1,
          1,
          rotation,
          -centerX,
          -centerY
        );
        context.setTransform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        );
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        context.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          x,
          y,
          this.imageWidth_,
          this.imageHeight_
        );
      }
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  }
  drawText_(flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === "") {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    const pixelCoordinates = transform2D(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    const context = this.context_;
    let rotation = this.textRotation_;
    if (this.transformRotation_ === 0) {
      rotation -= this.viewRotation_;
    }
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      const x = pixelCoordinates[offset] + this.textOffsetX_;
      const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
        context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
        context.rotate(rotation);
        context.translate(this.textOffsetX_, this.textOffsetY_);
        context.scale(this.textScale_[0], this.textScale_[1]);
        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x, y);
        }
        if (this.textFillState_) {
          context.fillText(this.text_, x, y);
        }
      }
    }
  }
  moveToLineTo_(flatCoordinates, offset, end, stride, close) {
    const context = this.context_;
    const pixelCoordinates = transform2D(
      flatCoordinates,
      offset,
      end,
      stride,
      this.transform_,
      this.pixelCoordinates_
    );
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    let length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (let i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  }
  drawRings_(flatCoordinates, offset, ends, stride) {
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(
        flatCoordinates,
        offset,
        ends[i],
        stride,
        true
      );
    }
    return offset;
  }
  drawCircle(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const pixelCoordinates = transformGeom2D(
        geometry,
        this.transform_,
        this.pixelCoordinates_
      );
      const dx = pixelCoordinates[2] - pixelCoordinates[0];
      const dy = pixelCoordinates[3] - pixelCoordinates[1];
      const radius = Math.sqrt(dx * dx + dy * dy);
      const context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0],
        pixelCoordinates[1],
        radius,
        0,
        2 * Math.PI
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  }
  setStyle(style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  }
  setTransform(transform2) {
    this.transform_ = transform2;
  }
  drawGeometry(geometry) {
    const type = geometry.getType();
    switch (type) {
      case "Point":
        this.drawPoint(
          geometry
        );
        break;
      case "LineString":
        this.drawLineString(
          geometry
        );
        break;
      case "Polygon":
        this.drawPolygon(
          geometry
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          geometry
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          geometry
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          geometry
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          geometry
        );
        break;
      case "Circle":
        this.drawCircle(
          geometry
        );
        break;
      default:
    }
  }
  drawFeature(feature, style) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  }
  drawGeometryCollection(geometry) {
    const geometries = geometry.getGeometriesArray();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  }
  drawPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }
  drawMultiPoint(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== "") {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  }
  drawLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(
        flatCoordinates,
        0,
        flatCoordinates.length,
        geometry.getStride(),
        false
      );
      context.stroke();
    }
    if (this.text_ !== "") {
      const flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  }
  drawMultiLineString(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    const geometryExtent = geometry.getExtent();
    if (!intersects(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      const context = this.context_;
      const flatCoordinates = geometry.getFlatCoordinates();
      let offset = 0;
      const ends = geometry.getEnds();
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(
          flatCoordinates,
          offset,
          ends[i],
          stride,
          false
        );
      }
      context.stroke();
    }
    if (this.text_ !== "") {
      const flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  }
  drawPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      context.beginPath();
      this.drawRings_(
        geometry.getOrientedFlatCoordinates(),
        0,
        geometry.getEnds(),
        geometry.getStride()
      );
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      const flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  }
  drawMultiPolygon(geometry) {
    if (this.squaredTolerance_) {
      geometry = geometry.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      );
    }
    if (!intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      const context = this.context_;
      const flatCoordinates = geometry.getOrientedFlatCoordinates();
      let offset = 0;
      const endss = geometry.getEndss();
      const stride = geometry.getStride();
      context.beginPath();
      for (let i = 0, ii = endss.length; i < ii; ++i) {
        const ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== "") {
      const flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  }
  setContextFillState_(fillState) {
    const context = this.context_;
    const contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  }
  setContextStrokeState_(strokeState) {
    const context = this.context_;
    const contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }
      if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(
          contextStrokeState.lineDash = strokeState.lineDash
        );
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  }
  setContextTextState_(textState) {
    const context = this.context_;
    const contextTextState = this.contextTextState_;
    const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = textAlign;
      context.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = textAlign;
        context.textAlign = textAlign;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = textState.textBaseline;
        context.textBaseline = textState.textBaseline;
      }
    }
  }
  setFillStrokeStyle(fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      const fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: asColorLike(
          fillStyleColor ? fillStyleColor : defaultFillStyle
        )
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      const strokeStyleColor = strokeStyle.getColor();
      const strokeStyleLineCap = strokeStyle.getLineCap();
      const strokeStyleLineDash = strokeStyle.getLineDash();
      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      const strokeStyleLineJoin = strokeStyle.getLineJoin();
      const strokeStyleWidth = strokeStyle.getWidth();
      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
        lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n) => n * this.pixelRatio_),
        lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
        lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
        lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
        miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
        strokeStyle: asColorLike(
          strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
        )
      };
    }
  }
  setImageStyle(imageStyle) {
    let imageSize;
    if (!imageStyle || !(imageSize = imageStyle.getSize())) {
      this.image_ = null;
      return;
    }
    const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
    const imageAnchor = imageStyle.getAnchor();
    const imageOrigin = imageStyle.getOrigin();
    this.image_ = imageStyle.getImage(this.pixelRatio_);
    this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
    this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
    this.imageHeight_ = imageSize[1] * imagePixelRatio;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    const imageScale = imageStyle.getScaleArray();
    this.imageScale_ = [
      imageScale[0] * this.pixelRatio_ / imagePixelRatio,
      imageScale[1] * this.pixelRatio_ / imagePixelRatio
    ];
    this.imageWidth_ = imageSize[0] * imagePixelRatio;
  }
  setTextStyle(textStyle) {
    if (!textStyle) {
      this.text_ = "";
    } else {
      const textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        const textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: asColorLike(
            textFillStyleColor ? textFillStyleColor : defaultFillStyle
          )
        };
      }
      const textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        const textStrokeStyleColor = textStrokeStyle.getColor();
        const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        const textStrokeStyleWidth = textStrokeStyle.getWidth();
        const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
          strokeStyle: asColorLike(
            textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
          )
        };
      }
      const textFont = textStyle.getFont();
      const textOffsetX = textStyle.getOffsetX();
      const textOffsetY = textStyle.getOffsetY();
      const textRotateWithView = textStyle.getRotateWithView();
      const textRotation = textStyle.getRotation();
      const textScale = textStyle.getScaleArray();
      const textText = textStyle.getText();
      const textTextAlign = textStyle.getTextAlign();
      const textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== void 0 ? textFont : defaultFont,
        textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
        textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
      };
      this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t, i) => acc += i % 2 ? " " : t, "") : textText : "";
      this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
      this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
      this.textScale_ = [
        this.pixelRatio_ * textScale[0],
        this.pixelRatio_ * textScale[1]
      ];
    }
  }
};
var Immediate_default = CanvasImmediateRenderer;

// node_modules/ol/render/canvas/hitdetect.js
var HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation) {
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new Immediate_default(
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation
  );
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, "#00000");
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects(extent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(void 0);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(
          imgSize[0],
          imgSize[1],
          void 0,
          { alpha: false }
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new Icon_default({
            img,
            imgSize,
            anchor: image.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView()
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = geometry.getGeometriesArrayRecursive();
        for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
          const geometry2 = geometries[i2];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(
            geometry2,
            style
          );
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms2.length; k < kk; ++k) {
          renderer.setTransform(transforms2[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  return resultFeatures;
}

// node_modules/ol/renderer/vector.js
var SIMPLIFY_TOLERANCE = 0.5;
var GEOMETRY_RENDERERS = {
  "Point": renderPointGeometry,
  "LineString": renderLineStringGeometry,
  "Polygon": renderPolygonGeometry,
  "MultiPoint": renderMultiPointGeometry,
  "MultiLineString": renderMultiLineStringGeometry,
  "MultiPolygon": renderMultiPolygonGeometry,
  "GeometryCollection": renderGeometryCollectionGeometry,
  "Circle": renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform2, declutterBuilderGroup) {
  let loading = false;
  const imageStyle = style.getImage();
  if (imageStyle) {
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == ImageState_default.IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform2,
    declutterBuilderGroup
  );
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform2, declutterBuilderGroup) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform2
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      declutterBuilderGroup
    );
  }
}
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = geometry.getGeometries();
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
  replay.drawCustom(
    geometry,
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer()
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup
    );
  }
}
function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(
            style.getZIndex(),
            "Image"
          );
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      "Image"
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(
            style.getZIndex(),
            "Image"
          );
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      "Image"
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}

// node_modules/ol/renderer/canvas/VectorLayer.js
var CanvasVectorLayerRenderer = class extends Layer_default3 {
  constructor(vectorLayer) {
    super(vectorLayer);
    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
    this.animatingOrInteracting_;
    this.hitDetectionImageData_ = null;
    this.renderedFeatures_ = null;
    this.renderedRevision_ = -1;
    this.renderedResolution_ = NaN;
    this.renderedExtent_ = createEmpty();
    this.wrappedRenderedExtent_ = createEmpty();
    this.renderedRotation_;
    this.renderedCenter_ = null;
    this.renderedProjection_ = null;
    this.renderedRenderOrder_ = null;
    this.replayGroup_ = null;
    this.replayGroupChanged = true;
    this.declutterExecutorGroup = null;
    this.clipping = true;
    this.compositionContext_ = null;
    this.opacity_ = 1;
  }
  renderWorlds(executorGroup, frameState, declutterTree) {
    const extent = frameState.extent;
    const viewState = frameState.viewState;
    const center = viewState.center;
    const resolution = viewState.resolution;
    const projection = viewState.projection;
    const rotation = viewState.rotation;
    const projectionExtent = projection.getExtent();
    const vectorSource = this.getLayer().getSource();
    const pixelRatio = frameState.pixelRatio;
    const viewHints = frameState.viewHints;
    const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
    const context = this.compositionContext_;
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);
    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
    const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
    do {
      const transform2 = this.getRenderTransform(
        center,
        resolution,
        rotation,
        pixelRatio,
        width,
        height,
        world * worldWidth
      );
      executorGroup.execute(
        context,
        1,
        transform2,
        rotation,
        snapToPixel,
        void 0,
        declutterTree
      );
    } while (++world < endWorld);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const compositionContext = createCanvasContext2D(
        this.context.canvas.width,
        this.context.canvas.height,
        canvasPool
      );
      this.compositionContext_ = compositionContext;
    } else {
      this.compositionContext_ = this.context;
    }
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const alpha = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_;
      this.context.drawImage(this.compositionContext_.canvas, 0, 0);
      this.context.globalAlpha = alpha;
      releaseCanvas(this.compositionContext_);
      canvasPool.push(this.compositionContext_.canvas);
      this.compositionContext_ = null;
    }
  }
  renderDeclutter(frameState) {
    if (this.declutterExecutorGroup) {
      this.setupCompositionContext_();
      this.renderWorlds(
        this.declutterExecutorGroup,
        frameState,
        frameState.declutterTree
      );
      this.releaseCompositionContext_();
    }
  }
  renderFrame(frameState, target) {
    const pixelRatio = frameState.pixelRatio;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    const canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;
    const replayGroup = this.replayGroup_;
    const declutterExecutorGroup = this.declutterExecutorGroup;
    let render2 = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
    if (!render2) {
      const hasRenderListeners = this.getLayer().hasListener(EventType_default2.PRERENDER) || this.getLayer().hasListener(EventType_default2.POSTRENDER);
      if (!hasRenderListeners) {
        return null;
      }
    }
    const width = Math.round(frameState.size[0] * pixelRatio);
    const height = Math.round(frameState.size[1] * pixelRatio);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    this.preRender(context, frameState);
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    this.opacity_ = layerState.opacity;
    this.setupCompositionContext_();
    let clipped = false;
    if (render2 && layerState.extent && this.clipping) {
      const layerExtent = fromUserExtent(layerState.extent, projection);
      render2 = intersects(layerExtent, frameState.extent);
      clipped = render2 && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
      }
    }
    if (render2) {
      this.renderWorlds(replayGroup, frameState);
    }
    if (clipped) {
      this.compositionContext_.restore();
    }
    this.releaseCompositionContext_();
    this.postRender(context, frameState);
    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }
    return this.container;
  }
  getFeatures(pixel) {
    return new Promise((resolve) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const size = [this.context.canvas.width, this.context.canvas.height];
        apply(this.pixelTransform, size);
        const center = this.renderedCenter_;
        const resolution = this.renderedResolution_;
        const rotation = this.renderedRotation_;
        const projection = this.renderedProjection_;
        const extent = this.wrappedRenderedExtent_;
        const layer = this.getLayer();
        const transforms2 = [];
        const width = size[0] * HIT_DETECT_RESOLUTION;
        const height = size[1] * HIT_DETECT_RESOLUTION;
        transforms2.push(
          this.getRenderTransform(
            center,
            resolution,
            rotation,
            HIT_DETECT_RESOLUTION,
            width,
            height,
            0
          ).slice()
        );
        const source = layer.getSource();
        const projectionExtent = projection.getExtent();
        if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
          let startX = extent[0];
          const worldWidth = getWidth(projectionExtent);
          let world = 0;
          let offsetX;
          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX += worldWidth;
          }
          world = 0;
          startX = extent[2];
          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                offsetX
              ).slice()
            );
            startX -= worldWidth;
          }
        }
        this.hitDetectionImageData_ = createHitDetectionImageData(
          size,
          transforms2,
          this.renderedFeatures_,
          layer.getStyleFunction(),
          extent,
          resolution,
          rotation
        );
      }
      resolve(
        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    if (!this.replayGroup_) {
      return void 0;
    }
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const layer = this.getLayer();
    const features = {};
    const featureCallback = function(feature, geometry, distanceSq) {
      const key = getUid(feature);
      const match = features[key];
      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }
        matches.push(
          features[key] = {
            feature,
            layer,
            geometry,
            distanceSq,
            callback
          }
        );
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }
        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }
      return void 0;
    };
    let result;
    const executorGroups = [this.replayGroup_];
    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }
    executorGroups.some((executorGroup) => {
      return result = executorGroup.forEachFeatureAtCoordinate(
        coordinate,
        resolution,
        rotation,
        hitTolerance,
        featureCallback,
        executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item) => item.value) : null
      );
    });
    return result;
  }
  handleFontsChanged() {
    const layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  }
  handleStyleImageChange_(event) {
    this.renderIfReadyAndVisible();
  }
  prepareFrame(frameState) {
    const vectorLayer = this.getLayer();
    const vectorSource = vectorLayer.getSource();
    if (!vectorSource) {
      return false;
    }
    const animating = frameState.viewHints[ViewHint_default.ANIMATING];
    const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
    if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }
    this.animatingOrInteracting_ = false;
    const frameStateExtent = frameState.extent;
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const resolution = viewState.resolution;
    const pixelRatio = frameState.pixelRatio;
    const vectorLayerRevision = vectorLayer.getRevision();
    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
    if (vectorLayerRenderOrder === void 0) {
      vectorLayerRenderOrder = defaultOrder;
    }
    const center = viewState.center.slice();
    const extent = buffer(
      frameStateExtent,
      vectorLayerRenderBuffer * resolution
    );
    const renderedExtent = extent.slice();
    const loadExtents = [extent.slice()];
    const projectionExtent = projection.getExtent();
    if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
      const worldWidth = getWidth(projectionExtent);
      const gutter = Math.max(getWidth(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      wrapX2(center, projection);
      const loadExtent = wrapX(loadExtents[0], projection);
      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] + worldWidth,
          loadExtent[1],
          loadExtent[2] + worldWidth,
          loadExtent[3]
        ]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([
          loadExtent[0] - worldWidth,
          loadExtent[1],
          loadExtent[2] - worldWidth,
          loadExtent[3]
        ]);
      }
    }
    if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
      if (!equals(this.renderedExtent_, renderedExtent)) {
        this.hitDetectionImageData_ = null;
        this.renderedExtent_ = renderedExtent;
      }
      this.renderedCenter_ = center;
      this.replayGroupChanged = false;
      return true;
    }
    this.replayGroup_ = null;
    const replayGroup = new BuilderGroup_default(
      getTolerance(resolution, pixelRatio),
      extent,
      resolution,
      pixelRatio
    );
    let declutterBuilderGroup;
    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new BuilderGroup_default(
        getTolerance(resolution, pixelRatio),
        extent,
        resolution,
        pixelRatio
      );
    }
    const userProjection2 = getUserProjection();
    let userTransform;
    if (userProjection2) {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        const extent2 = loadExtents[i];
        const userExtent2 = toUserExtent(extent2, projection);
        vectorSource.loadFeatures(
          userExtent2,
          toUserResolution(resolution, projection),
          userProjection2
        );
      }
      userTransform = getTransformFromProjections(userProjection2, projection);
    } else {
      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }
    const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
    let ready = true;
    const render2 = (feature) => {
      let styles;
      const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
      if (styles) {
        const dirty = this.renderFeature(
          feature,
          squaredTolerance,
          styles,
          replayGroup,
          userTransform,
          declutterBuilderGroup
        );
        ready = ready && !dirty;
      }
    };
    const userExtent = toUserExtent(extent, projection);
    const features = vectorSource.getFeaturesInExtent(userExtent);
    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      render2(features[i]);
    }
    this.renderedFeatures_ = features;
    this.ready = ready;
    const replayGroupInstructions = replayGroup.finish();
    const executorGroup = new ExecutorGroup_default(
      extent,
      resolution,
      pixelRatio,
      vectorSource.getOverlaps(),
      replayGroupInstructions,
      vectorLayer.getRenderBuffer()
    );
    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new ExecutorGroup_default(
        extent,
        resolution,
        pixelRatio,
        vectorSource.getOverlaps(),
        declutterBuilderGroup.finish(),
        vectorLayer.getRenderBuffer()
      );
    }
    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = renderedExtent;
    this.wrappedRenderedExtent_ = extent;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  }
  renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutterBuilderGroup) {
    if (!styles) {
      return false;
    }
    let loading = false;
    if (Array.isArray(styles)) {
      for (let i = 0, ii = styles.length; i < ii; ++i) {
        loading = renderFeature(
          builderGroup,
          feature,
          styles[i],
          squaredTolerance,
          this.boundHandleStyleImageChange_,
          transform2,
          declutterBuilderGroup
        ) || loading;
      }
    } else {
      loading = renderFeature(
        builderGroup,
        feature,
        styles,
        squaredTolerance,
        this.boundHandleStyleImageChange_,
        transform2,
        declutterBuilderGroup
      );
    }
    return loading;
  }
};
var VectorLayer_default = CanvasVectorLayerRenderer;

// node_modules/ol/layer/Vector.js
var VectorLayer = class extends BaseVector_default {
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new VectorLayer_default(this);
  }
};
var Vector_default2 = VectorLayer;

// node_modules/ol/Feature.js
var Feature = class extends Object_default {
  constructor(geometryOrProperties) {
    super();
    this.on;
    this.once;
    this.un;
    this.id_ = void 0;
    this.geometryName_ = "geometry";
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.geometryChangeKey_ = null;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    if (geometryOrProperties) {
      if (typeof geometryOrProperties.getSimplifiedGeometry === "function") {
        const geometry = geometryOrProperties;
        this.setGeometry(geometry);
      } else {
        const properties = geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }
  clone() {
    const clone2 = new Feature(this.hasProperties() ? this.getProperties() : null);
    clone2.setGeometryName(this.getGeometryName());
    const geometry = this.getGeometry();
    if (geometry) {
      clone2.setGeometry(geometry.clone());
    }
    const style = this.getStyle();
    if (style) {
      clone2.setStyle(style);
    }
    return clone2;
  }
  getGeometry() {
    return this.get(this.geometryName_);
  }
  getId() {
    return this.id_;
  }
  getGeometryName() {
    return this.geometryName_;
  }
  getStyle() {
    return this.style_;
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  handleGeometryChange_() {
    this.changed();
  }
  handleGeometryChanged_() {
    if (this.geometryChangeKey_) {
      unlistenByKey(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    const geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = listen(
        geometry,
        EventType_default.CHANGE,
        this.handleGeometryChange_,
        this
      );
    }
    this.changed();
  }
  setGeometry(geometry) {
    this.set(this.geometryName_, geometry);
  }
  setStyle(style) {
    this.style_ = style;
    this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
    this.changed();
  }
  setId(id) {
    this.id_ = id;
    this.changed();
  }
  setGeometryName(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  }
};
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(typeof obj.getZIndex === "function", 41);
    const style = obj;
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature_default = Feature;

// src/control/images/marker.png
var marker_default = "data:image/png;base64,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";

// src/control/images/location_icon.png
var location_icon_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNBNAaMQAAAGTSURBVDhPpZU9LwRRFIaHEAUNv0BDQqHwLxQajVKhUvgNWrUE3UZHo0Ci0kpEQTQSUYsgEtS+nmc4cnN3Zney3uTJzty99+w957yHoqHu4eXn8f8ahkd4hREXetEALMEpvMPXLz6fwTIMQiONwzlEkFs4hAO4gU9w/RImoKMMdgceOIFZyDUDx+CeB6gNappxsw3ohzr1wTq49woq07dmcbM02BxswhbMg8GUn0fgmRUXctkAv0zT3AbXUnYggk6BNb0o3xJpDTtoA0LeLA8WLEDIlD9gtHxDmlafudFuhkwzDxS0ILQHrj2BscoJ0LQuao2QNUuDpJh2aBdce4O/aXICTFmfhWxAHihYhJB+NOWx8i2RE2CB9Zmy8N4kD2aK0ZRJ8Ix1bJPj5AFNm1rDBlgzg3uz+E7tg2dWy7dMmtPru0HTpgertAbuvYYhF6rkGDlObtS0+iyXacbNnmEaOsqg1sQDUR/rZjfNIP44eLOuwUKm7zg5AXbQAOKzP2DNatPsJidA0+qzNmv0qob/AoriG1IyiuleC7udAAAAAElFTkSuQmCC";

// src/control/MyLocation.js
var MyLocation = class extends Control_default {
  constructor(opt) {
    const options = opt || {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    let cssClassName = options.className !== void 0 ? options.className : "ol-my-location ol-unselectable ol-control";
    cssClassName += options.zoomSlider ? " zoom-slider-exists" : "";
    this.labelNode_ = document.createElement("img");
    this.labelNode_.src = location_icon_default;
    this.button_ = document.createElement("button");
    const tipLabel = options.tipLabel ? options.tipLabel : "Min Lokation";
    this.button_.setAttribute("type", "button");
    this.button_.title = tipLabel;
    this.button_.appendChild(this.labelNode_);
    const _this = this;
    this.button_.onclick = function(e) {
      e.preventDefault();
      _this.showMyPosition();
    };
    const element = this.element;
    element.className = cssClassName;
    element.appendChild(this.button_);
    const myLocationStyle = new Style_default({
      image: new Icon_default({
        anchor: [0.5, 18],
        anchorXUnits: "fraction",
        anchorYUnits: "pixels",
        src: marker_default
      })
    });
    this._myLocationVector = new Vector_default({});
    this._myLocationLayer = new Vector_default2({
      source: this._myLocationVector,
      style: myLocationStyle
    });
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      map.addLayer(this._myLocationLayer);
    }
  }
  handleNoGeolocation(error_msg) {
    const error_str = error_msg.message ? error_msg.message : "";
    console.error(error_str);
    alert(error_str);
  }
  showMyPosition() {
    const _this = this;
    const showPosition = function(position) {
      const lonlat = [position.coords.longitude, position.coords.latitude];
      const xy = fromLonLat(lonlat, "EPSG:25832");
      const feature = new Feature_default({
        geometry: new Point_default(xy),
        title: "Min lokation"
      });
      _this._myLocationVector.clear();
      _this._myLocationVector.addFeature(feature);
      _this.getMap().getView().fit(_this._myLocationVector.getExtent());
    };
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        showPosition,
        (err) => {
          this.handleNoGeolocation(err);
        }
      );
    } else {
      this.handleNoGeolocation({ message: "Geolokation er ikke tilg\xE6ngelig." });
    }
  }
};

// src/control/images/dtk_skaermkort_thumb.png
var dtk_skaermkort_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////e7f+T0aD17PT89Pzs5PTf3OTs7Pzk5PT09Pzs7PTc5Pzc5PTk7Py3ub3T3OvU5PzU5PTc7Pzk7PTFxsfK2OLZ4+rS7Pzc7PTn9Pq44fHB7Pzb9PzU7PS58/yhqqrz/PzO0dGcyLSUxKyM1KyUzKyE1KSM3KycxKyMzKWU1Kyb3LSTwaOoyrSM1KSU3KyczKyM3KSE3J2UzKSc1Kym2bWc5rCm5LakwqyLyZqU1KSM1JyU3KSf3Kxli212oH+Fs4+cxKSkzKyczKSc1KSU3JyU1Jyc3KTz/PSYwJyYzJy417qn1KekxKSV1JSd1JyuwK2Yy5SkzKGuzKyU1Izs9OuUzIytzqBbalW41aitvqOpyJO4y6WZmpja29nJ2be1xZq6vbXI1avZ3r3s9Kj0/Jzs9Jz0/KT0/JTc4Jj8/JT8/Jz8/KTp6Zn8/Kzo56b8+7f8/OT8/Oz09OT8/PT09Ox4eHf8+Yz8+sj08azIxqTZ17T89JzZ1Ir07pz076TZ1qv88pTo4IyvqGzHwH/89KT88qzr5bjQx5Pq5cnm15rz7dL79dr755v86aT03JPz3qT03azp5NmfjGTq1an45Lr07Nz89OT52Jz83KS+p4D83azjyJv03LTq17j87NOTjoaFclX01KTYvZbMtpapmIL03Lz55Mj81KT01Kz83LTZxKr8xozLwbbyvIT0zKP81Kz01LT83Lz03MS5qJbYx7bp2cj05NT87NyIgnz89Oyoo57px6j8vIT0vIz8zKT0tIT8vIzqtYz0vZT6xZv0zKz81LT83MTny7bOuamzr6z8tIT8zKz007z03Mz85NT0tIz8vJTpuJjzw6TZzsfzrIP8tIzep4b0vJz8xKTdsJf4zLT81Lzn3Nb8rIPLknT0tJT8vJz01MT83Mzvon/imXnzrIz8tJT0w638rIz5vKT8xKz81MT05N347Of8pIP0s5zypIz8tJ37rJT85N38o4z01Mz43NX81MzyzMT89PT8/Pz09PTp6en///8Cu069AAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAci9JREFUeJyMvXt82+Z9L/wFSBAAAfAGkhIlSpYl27JkJjadxBZzcxWzDtukTXrJ2jRpz9p1a5113ZqjrZedd+/27l3bbWp6zlnbdD09y87aLOvabeklDevQUZwmoWwnpu3QkmVLsi6UKJEESZEAARAk8P4h27HTJHt/n48/pgiAeL74/Z7nd39A3J7GCOuUax6YAICKzcjirWjUrBnCts+k571ge46UkxGqazVz/SlRV42efPNFnol4Krrl6W2B4Ps+Zby+HChIBIO+aWAIQatwXgDq/o0LFSI0sK07x0EEFG75rFADgGBXZpDpBTlRh0iwh55g0dHV9v5k671JvcTywWVyz6Dnl/s++SHx5TUSEchAjZ5Q9RpJAt6uLQdGoyOIXD/GGJw8NP+BAgCWqeU30HDBg9h1ODxvBj/irBlAKmI8PToLt4aJ8wE0wXD7gntYdmGh0Iawu8tiobLwMNUAKSpNCQokz7AzAL+fnZq/UxQVbQO8qfccAkM056dKNd+Ln/RA2Ccvk8x3HdzkAx/zh9fGSQgRyonMZESWMxMTJEnK4E2XHqWiV0YTAYB6VAYCTlGrWFV0n9K0ESePaiR93bidZOY6hkR1GagmoNn3TESDfbMI7LVQ90MB3PsGVVXv9gfo/mFek/PeCuAAOLZxkVRJSCKGwiX+QG9QBDd/YoCglQgetW9X9jfOXHzovx84yTEn+nvxo692/PjzE/q5c+NNMl3nPZCBbLYTwIQ6IUmrgMvl8oxGN7EIEQBZD+SMm9VWKh1gS4pJg0KDvk4IRzxy9XqGeFxAVkxCGNoSs/Q/ecwQXG0LBKfixAnoAuUt1jpYm2NYh1XxwglozfrqaqlwZgNTwAw7vMzagAsFzLTAEPho45uHI19ZftFo3jgkAcu5wQ7iex/BU6qWwjkykZVNsBEg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";

// src/control/images/dtk_skaermkort_daempet_thumb.png
var dtk_skaermkort_daempet_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////r7OTU5vDp5uf++/3//f/59/n18/Xt6+3d293V09XPzc/Ny83Lycvp5+rl4+bJx8rFw8b9/f/7+/3z8/Xv7/Hb293Nzc/Ly83JycvHx8nDw8W/v8GurrC5ubrq6+3i4+XS09XW2Nr3+Pnf4OHX5fLV5fPV5fHO09fV5/Pq7e/X6PPX5e7S6PXW6vXT5/LV5/HQ4evX5/DO3OTV4+vT3+bK1dvP2d/p8PTR5/LZ6PDa5uzJ0dW+xMe7v8Hy9vjLzc7Jy8zV5+/c6e/EzdHU6fLT5+/c7PPr9fnb4uXCx8nZ3uDj6+6ts7W1u730+/3f5uj6/v79///Nz8/n6OiRkpL9//3Nz83Jy8no7Ofp7+fp+uL5//bz9fLv8e7b3drLzcrDxcLp+9/v+unr9Obr+uLp8OXt+eXr9+Pz/O3o8OPd5df2/fHv/OXq8+Lo7+Hr7+fp7eXt7+vr7enj5eHo8N7m69/r8OPr7+Xp7ePHycT8/vnX2dTr8OHv8evt7+nr7efn6ePp7OHLzcbz9e7j5d7f4drIysLW2NDx8+vv8ent7+fr7eXNzsrz9evx8+nt7+Xr7ePU1dDS087r7eG8vbfKy8XGx8HDxL7q6+Xb3NbAwbrZ2tPQ0crNzsf19u/l5t/h4tvv8Ofx8ufv8OXt7uP19evz8+nz8+vx8ent7eXq6uPx8evv7+nt7ee3t7Oysq729vLy8u7v7+vt7enm5uLi4t7e3trW1tK5ubb+/vv5+fbq6ufZ2dbR0c7Pz8yIiIb///3t7evLy8nJycfAwL69vbuvr63T09KysrGsrKuoqKekpKOgoJ+cnJuYmJfz8env7eXt6+P18+3z8evv7efl493t6+bv7enOy8fv7evx7uz18/Lt6+rl4+Lh397d29rV09LPzczLycjJx8bb2NfFwsL//f39+/vNy8v9/f36+vr29vby8vLu7u7q6urm5ubi4uLe3t7a2trW1tbR0dHPz8/Nzc3Ly8vJycnGxsbCwsK3t7e0tLT////82rDGAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAdTFJREFUeJyMfXlgVEW2969u7/ve6U7IHhISSIAkJCCyKMERcBkV4zIK7uKoY5w3Cbw3D2Jk3nskmRnjqCNuo6BvRiPjjBuogLIoS0gCJBCWpLNAkk5635fbfW99f4QlLPN9X/3V3VW3qn59TtVZ6tS5hAHqrfqeOZpj4qSfc6rzxutwvdIC6IZ1GT0pxnMvxFe2zWtd29gUsiS0g/UXW3z0EOoVilF1rH7SY+vl6jCpRQuAmg1prv/wiF+aJuxnAFj1h51lqPiWf7kJY/fm65F7av9coZ7AeXxzbtmPlqjWjht/Kh95+NH3OdUraYORxJw7D5UdpsuUjLzv10XeOjTqi2i0Kvf44bv7umYRBsDaxvU5UdmIWgi4UnT9YEjtdZDUbDKOJtRchcKYgwNdfm/2yBSiHSE1lxtg/dxzUmZwEpDmoJRE1LUNGgCJUDLyx7zXEh0gijBilhe3jEeFPimhDK2QlpjgPVaWRl3UTF3kwFfTY8F1qFcE0zI+2JLziY1Z3ZQ4s8UtebasWFhqOafztUpXN0XMJfGboVHSrkKbmgFaPmpsVXK+fqFzXDaSxvtUhoh5U1NT81VAapq0fIqylsSKxzIOBTOt1lOEC/S/aLzUwN9SD7vX0aOZ9BBfqSsmtYBAAFAR/miYL+ogBGHA+GLzOMkyTidiAaUMawJ8u59XwcSscN+KOXfGCwiaG0KC4tYPEHzXtRpBZQ4ETl7y5SzxmAUH0j3gK5+AELljg6eNmgQYQHCipWMtb1DkMEEnYxyjSKYkqbmOb2y68K9OMBaCcW4k0qTRKG/oopEugV8jJrEwbJcmrQEVxAyhxkk4mukpepgA9RyHmlDZ4+j9M0IKAMDIC6GxUWOwm1mYHsb53QBOZzwzQMYT858+m8MH234kzbWgCys2mR4Zf5hiw1w87RCMzMmQ9jx4LG44MD62QavMnb0Q7blcwgWDk0Gzx1Kj/x88zZyEKszY6fDYM56wOvJnozZr/fpGNKO2GUAD6hmRT95gDN0fM2fyTqurXiHgWWatpvUSRWpopXiEwWUaQRibJwCAZpZlNzBiFaaJmSUXK4M3LZdWrvwZyV8SAgXG8FMVddFDg0bf2baROTxqG7bkSg6pkfPf+8VA3z4LKRSXOe669yvhw49CaJULjy95GrnkBpaTtEEoRC0AaGObyH1FANBcW78hHkc2C+KzjJqbAo0ktHkN9OClJHdky8DyOsPun3eNa4UIpyTpy/io+uLEoi2JAb88CtdlIKzu5AgBXpHl2WiBN250zqQ37g4RAD5pnG+TrjKS1ZgzTZW7HxDeKP7WoH7/QEqkrolmChR1yB1Roiz7tqr9cgD5q7ZNU+yXPuk9I+PmikbcOj4fD6sxm387KSR6p0gIAFvOI6eNFLUAABo0idp6DFCkkWhaVKHn7PxIk9HV4plLzuu5OW3R3Fndm2OB3C00ek5eP529NGuLjkbixV0Yu/TL2rRzkEeBxNQbF/zYV/Ipnhk6zEYB4L6vLB47mT04Dfhm9nqN7Y8fgpGuFmohKh4XGTAeF1vQMqzLLDOUP2eTigVbztEep2kHM5sv3ZZFUo8pBMxQrHYAuTutUuNRFmKOaQEwphb3vNwwsaRrNKht9llf3sgEfP5fesTgUqwZES7uTj3Tax+OS6vF3drTaUWah+yc18xYqy///4mxgEvW1dBsufSLIan1hqFEijRFP/+Rmf9EZ1b1oZ6SYLBhc9+PLiAUXLkDOLQ4mN4DHHzzRXwqkPqEalN/xC8c+0Snnf64Ht8mYsxYlPqmCYUoZb4kVQd+feJUrkRzzljSakT7+bGBw6V6J1NK/mQUVzcrRJ61uE5pptSy+r8sceJV5ErPsrrITNFCB5iO3WhoUjPUd8VD9VZeJF49+Zf1Uw7Om9KmScQWPMgX9p5W5c7Z17sNFSm/44ICKk9BsUD9xnP0c+28cg2wen7sP8g/zxSWdZ3gGU709Hrxi4WnmSPdCoe7cZPshuCc/MG8dyLSMTz2pifjhGRxT/uDS/VD0rjSZ4n5iIapsVc3qskouS4OV93a1a9M8f/SQ/w/JZO8x8czRtFxYaLf2sqf56LMFa1lRPik9IrH09K5tGG9OyJ8i8fpwQRczxcU+yN2kSYsZiBVz94m3SHF0cVne1yA84H02QRx6c62t0e9w7LBP2fdcDyZnUVG+wlglZyXn/zq2Mei872J9M8pc1aXJpmdtRR9qVkJV8d5hzUJ0mANBqwuCYPa5utIwWbUApuD5jFawrQriJs//b/C4q/IBypXLD8Zu4IgzQFrxK+e3MeWWO4SYBV5Jnl7kno4Gb5f4JEd6Gf2FJ5jZK4c/kbld08PbR+55+hvokbsOzZ1hslof11XPCexVxzZU6V/6/F7CjvuubenDh+pRizKR+cd9LjJIzlLD/BG8/FkWuHNQA67bcUAr5VO6YNQNoqcRMow01B/HRyoBdY2rgGaA32CdC8/T/27bcpvzx7YiC18NCia3LI1ygoNgSv7GC/aLp5pwo+zz4tJ7nF4VIdZa3Lxrjy1kCStsjJtUfqJ89b53IuHlgAlp39S1Y4f0oz2VRzX0rPZNx4LlkY6dnxzRAmMpFQOLf169uCrpvL2HdmdRYMpmhMNewGPkHnkDGEdsoQejLFSHhhzEEwIvqvFOYBGAKCMMNstSAzNcidvQ6cCQJI6I5ObDfWljPVPZtDmJmrZiz22gMu2TbnjidY4JG23xrtonzqnLwkR3H+9P3VYd0tO254j5QDK02+u/prrcZfffGhp6RymrHvet+YyVShdUdvalP3zXPyTEVcRnFLm/9mbPBh69cmHRDAITIk3hUnzL6EHGHaILYhyqfx6GpqgwHVLSiWWk2TK4wpB/Fc9uXasRSJHbZ3EgaBCtk85+ZdanhsTHqrcdqBvtdd555a5FudUQrIERXvGWIgZBgQoJ8lhUFLJAWOvfXxDkOfHU2wMUdHXph/zxzw482+H/XXN1UFjccb/pg2J7/gKoGeXzWtfee5veHMRelPw5Fxr0vE+C4AJGudgipnPmkJkF3WS65SxUXFTwDDSnqlV/Ml1cgp0MeFh1ZpL1bVAihjZeWsmPfKJmxNYN44qDnx7/x9e3bEK6Nn81i3ykHZDgOUToI/NN5Z//TrSY2TZ4TmA6OP5BGZPlu7XJyuG3EgW0jY9aS2Sr22p/XyRmn5f9/up7wAg4exvexSe6aREDzAj45s7xkwZ1ACA/HXcIxHPOMhnc2JeyLgNnhevg6MpyzflUL5T+YLf6NjuY7x2PWd2aYOT6dekSkSiysxLch6b5KIBK0ENmoAiKaF0pgmGD22vjn73Kas+X1BEDzHDOcvTOvvH67Pc8GzLeDRkXFjGyzJXjh+m+0iSH32ix59q0w/P1z7ADx5jXB835irIUNv32WOy0mpXHE4FsfRJ40Y/pwcgHK17U+jpUUHrHTElvcph8SZCSC0ubGEtqEGLv563yw4rOXlyUMUc1hz1v9pkio2JJv39ryR5DRmXW4OXcTTVve3WBzQA6oB6ngyWEX/CuHzskV99wyYU1qKwHOtPtSRsXbmJ2W6Amfp6EN2PDKcGMz/5yM7XHJW8/vuzTze5NMM60bvDP53AzB/fNIGEGrJkSKiPbV0CiEW0L33caGI0AEC+dFDtYF1zbROlUVFUYeSc5edkY5YJ82qdBYDxhEUXTjrVAiU9+59a+a/Va7Fp0RfTrhB92GSC64rduFFLRuUXbbTmEcqQm1tXz8l2/Wdad1ygYBSswf6smdm3iyrnzdMCOWfbqls73DKG1G4Z52fclCoddHa7VgPrK1MQP5768btWCqxMrdoHuUAqsN4JV8lQRBOYbdv95jYAEJ7iUwbWohZ1qKcsEx1NpA4iJBuWbyKexgmyNFN2WO8hIdzgm/HUqvc/GwTy3krrmzzrZhqJe4VXsqOQyrIufq79BOcydmb20o9EZ0VxIqO//MgYdA2cy+t57jVGzAMONSoY2pFrYsa3OOq2z0hNhtrfyXp53aamcCIx9ZMKX+rjyiDwePchSpO66b7lwJrP2IQUNlPFhDrNJHV20ry2FYCVKDdu5Jkxo4AT6KWsFo3mDX/fjKZQYzDFmf1yTqpXU1HzzIEzWdjkfiJdNXnStbwV7BW7cVN2fNxyidE+AjJww8q5rr1bRd0wyEuZSlpxX4VwqLLHaf2BBwT8L7I+JsVxGlYN5O/ajzHiCW3NbZCBn5MiIKtxQP58P7CSTPstGG0RPwdwIS/BExM0iYkhmHnedDcaqwGsaahrwgy1etBnVvb7jCRTFss+PrIhhHqGtQL26b1zhTPG97PVAHdm5CrLPinmlZO/Uy+SnkvfHgKAgtOzzkU0R3hFbIZCLKLH5b8ChCRFepMRyOHf6/3ZO3PTzvlI6qCif337PU8e/Cig1zTO+MkzY/Bs6Y261wlsj3edb6KpDB4xAWveFkwVjsddnRwcACA8S8Yu23R1qAaA5tomoXIgVTIenMLl7tKnWQZHc5vGZsLDTPsozmDLeaH9ChTNZj4hvNLOp+4U6eX97++FOAVbz1pC3UrWHHBmHHeEEY298ZwXS34CABaPP7fiaa8LqY6SgTLZ48J722aeF8DQy97OEL/62IJ5TVh5liSFYILSOX2AS5icyws55C7ddoEi0F2rL9ai7tfjMnHgP27MsWvzNeb9yfTeeNbxOQNTBtvk05vt6kRcdckwbAZqCZe0XUGQpqR6bNLXrnff+cm5nwRORyW8JJbjw+5uQgG8vvvQwZQ7AKfjx9+/9+yb5y2y0WiHbOfDoeOHU+8BdCNpGeWlYonvdSBsLM56Xe3kp8ybFQYgPJ3e5gaH4bcAMwAw+b7ru39q61a/WH/4gNCXEJ6fExoNlsy5N49+vt/CVAvtoVGMXOL/WjQ3rUqIysOTn+Z1AeEk3dhnp/xg3M0KIgArrEGXkqMV+uean6JIm8MBDJEMPRF+5SyjCZtvCJ2KHxjduAaIRv1pf+rO6cShP61inHho6BG1PpaEQAdUCzmn3lVqdIHHBGsx567Uxa8oDUSVdjjTPu406yWfVXvO/U02RRCF3qwVoXByO/oW5c5cQZAYQ0WZF79thszEc14+ShISRJJopoFe0NwIhvoWh9xeI5BG3qIQ/U4qNObknPBFQJRAcw0VLfrZnuWfddiY4x8YCV6g3PExPcrzATxVMCcBph0C3nRhEOaY+l8DQUPdGnKWkY+4HTnvwehf/3YfzUUfFxGQkQu+lWagOQRh0h9umPRcUOLNHB9twWYADQ09deF4LMoFOQ6Iq4yG0RlLCxwlrfNAzx5B5Q0AJG1P53fZ1OnxtJ/E8CdOvCwGapGzcF6kVWw8a5TMMcKInFPfY7q9+C09YCADnUkQCvI4LrAW+b8QZFL545SMvGwP/SrgTpICJ59wC+IKi4egph4+DSrOy8hk+fjJyYSa8abBXFzUgISfDUou1sRVjGRJgeAHgSP8m3zy7255nqZUBxwq5/UNhmHPprZSAdl1Yi1e42qwvucw3hqdfqTi7nzgNL3p6X2ykLEcrjuAoqJj7Vr4LDHNgP4iRf6/cHxkOMtpNO0Hj4TCWlMXl5FMNVn0vJ61b0ZQ97JojI6PT24+WJlhCW8C7itaB5cjzskv4ZCIFQDTM/woKo5hoF1GnBU8YEAW41OwybS2Emb1T0fCAFfT3Kj49d9PsLO+z4sG23E6FM75wB+SyE5G7wCc7J72I0Am8Fd6sWtm8/8PkIfGDFZhT6lAokjlolZyRmXPlhRFk5psK0/S3+FiItRNtmRoB98/s+d5bt2vIq44CMddrJAIABw59T3/QgjlsSPVVow9xwNncUZHb3OnVM7oYXLiAQIkmoyJGcJ7NB8djSZlLsXpaTi99GGAn17IA0hvO/vEUuD8CG68DORKifAvSmOi9Hgi/uDXfP+5sAxG9cBctujtvQ/xjKoSMZdeIF472ZLZkqLPLikEapJiyhLCAohfqOKicT5whKRqlGRsKB4ZT5nzmgnImcXwuhOs6Jsfwy/hnLIBUFGnWffaB501g1JhwgB65LbBaFQ5r79r5tK9gOMp5kvABS6XXAaC/x+S0BtcC2jp2izNxtSgLnxEj/6hROP7iVWrxefFXFwodF3ReizIBBgArYhHOTYYB3BxkcTBJuCvSk+TnRpIiZ2os0l4AJ8ZTQxZyKfcOMAqFXbSDPj13nT6dGl03roHtywHKSS/F+5qR/uTj32PRXClHXjCGXIJ082zL21aYBrw/yrNzc1W3yKD+HWWcrDTE+lZlImfL881CcwPCzwLhSnQcFe09wj9RfcUfVfbGQwhEocE8filyghlgba29Fsq3/YfL2lSnuSBXIXDDbtBsiWpdkwRUSsAjN9lKHxngNQfFxEH0L5jcPcsRcbN2HUnALHatlNUIBSK8bXgUsfMhsDa65rql+eFWsv5X4ikec/tsNaB5pjlg8SWu4wARvwpCfs4J+6/UhgWkvhZtPiplwMngSQel1zatSCBIExocfLD7VsT8bAoUsEBR4opBXFWPkZtTgHjW1PbDPKfRwPqp3ztKZm1X5kV1LmjMzG+NkEOfgDALR3gvhV08yYnziPkvQikImT416Y6ANTWghp85Ifxv8l9rSiLDMQzRpkbk0YXgLXdEV9DYPwKGQKadM7gPhlzBzkOcSAuubBC4gAkghA4NknIk8vRPWeMF1lMAAOGUpF43kLhRjykNjch8orw9eK4SnLUNX3wVRdFYW5/MIf+D+ma2Qo4cnZ+b/Lp9MIRwKhiBYGVTgAgjfKQiGRWb7FbZRNax5XurRbUoH564FffCwv2tfmydTJHzlh6j4gXhJ8hJhfzrjc1WP5NyQCpbb2oszRFUqmmpKgh6OMQl4jZicMRACwgiABKbp5v9Il3bzYkkr1263fbgAHLo9LHE3N/l5G/ZK2VSKWr8XlPVUx897auQlKWHVKQbQgclsfMfOHNANxMskv0TuuoSO2U0FIb3MJT7hUAWZsncaK2KWFhfKaHrqVHC+ANyGO/h2xvKGRXjvBaeb8iuzsteQRvPfVGW+yQQp09ksrF+pi6FqMN9cAmaniqqW5dMu6+yFBEBgBckoMgAomCGTtyZGu0Mtb6uzf/NJ7lxNhJMenK2ZnvVkn8dahNq2k9MWfbuzT3M37xHV+VnyLHe3/I8OrH4kvmBAwAvNya92Mm5B3ReUUc4VPicB+ZqwVjGOlXYVNEw+3NGQWAta1XQalBwc0LgSi/vWONnWhYO9QnyPCY4b5VT4kOJm4sLt7Zf3TUYQh/rnuovh6oj2iif8wCWBaAWBwHgDscI687gnwcAAQJ6epQjsMo+fDN1meI6RRQS954d/jcImss1pOFJlMNhiC8+/4T/ySzmR/KT2Ow912G6O2CJSg0wAEXU/iXWSa4jyYgtLSDOPJchmcZt5pxEpU9FBMBb98V/nx9PRoHJ5xCLS0tLS0A0EIzttwBrPTdcD+oiQSj1jVWbFSXdKX5VtX2nhru1KpiaZG4ZZCicUN9PV9JvMnqFhmlcsRpUiaKMzJJ6z/QmgnEGUgA46+EijtPW1d3HBmkYwWAaWtz8fLk0N9zTa96NpsiaKaMLeWDSPI2Vhk+FSLM2cVxjBnVR2N9gBki6Ze5NkD8qNkjIQskpzI64jttJXMWCIdLKL9IKig/rv/ygKKybb2i7ncTHl8YXQIAqNnw0+NbgMc7hfeABkPpq4FT84FBjTK6+keUhtvFa7Fe4VxwJvLngtihwXwpLyfwg0VEoiJhaHXQLAJECQCSEOJKzehHt8pn5P+457bn3nWybuA9BWKl08RCLvSWP5wq3BBSiCpYsZRuI9PQbtO9ZnCo+gX89FgRHDA7T5VNdwJubHNIQDlyt3O/IhMwegn7e+EM7QyzO/efBU/9lj+SuduoCiFqXQO0AIla4AWh9AUTPndqBuuasnzEva4pa6gWeI1j2d7UdcxW5erWatRTGtJYxy0cQw895ONOh2JxnoM49OSivW+gFSIg8VtXAoBAwJf9fJpMfgPMK96S/jmuA0IFA9j9t0gpze/hs6Nel1pebBkrL/2Ci95KbIlPQjIyYjAJ0m8FAPjlXLoTCDy2zSsy6/ozQw2K23JolUfAHJ1JbDM18dwRqUAxlPeQ8b5bUmcU8yOb6utTjTW1zYBmyeMm4NjgUBaCxzkfg7qJ3dqYmlI55aePRl2oBhpeZtRyn8Qh4pKV+8h90Tj4CAC8gUWtgCiRSOwdmlhy4tDZz/++gPvlSzeLmou7eEB/YoDSBeR9avTwZWy5OQXR3Tue1n3GIwn09obktM5gKolN4HASNukEXORNhyA21MOdU6M4wd4wwIWZ709GxGbkLWzD92vUmuPBG5O//JmpfrFuDt/fWw8RmtBbD1Rb5dbRj1SKrEAUExsthyOg084j/YL91NBQt5YRuULIFxVO7LUAtM8CABIAFk00EyTpTfM7Vp8pG1z4OtpmVACevEAwGA/vfzA/v1ag+04j8FnyZyWPlcbjuPf0UZeMrnvZUlLy/MTjwuTqJADRFJMQRpMmEvE9kFcOpVoMJgFSvl8bqwsOjQfY7+Vl6t+c7gxE3ja1mmRW2R8Mr9Sl5W8FpuT9Fn7OrOXyIrggMMSFw5nRYGLEdWlv+EgkIazgnBiQUQpJHBc0l73A3QAQj8fBIrXwpGXFy/HKoxhcY7IBMBqNRsO25ap584/+0M1Wi9JGHzdto/RVdsvv/mE5YVn73/rpxUo4HACcTMF7CcB1qg9pSQBGrY1K3XPjfAQMDxPJEs8jIsZ+6MDewb7Ffyi7I5DY/fEffplPb45zaTsGhQDcfY0uDQnQtvFLLpfqNTjcLg9OclyfqKmBRezIPoUo+EhcEmd8ANB6gRghAGKVBH+G55XIL1cnm9/rHAOQpcg+JA9u/2qTKSsxVaUCKHPUdUP+0CMi8pn7BF39xqLZfhUm7EAhH0wxAaKfmTxfTVhU1uMJ0IAY3eSlBYuO5hV8g59/EPdi2MpSd8EUIRta2CZ4MMF9PqNrpTuRgKv9cNRqdEqzDmy8OOuG+nrwUziWXnL6tNQ0h6y8QObxwsESDnFD2HLLBIi7P8N3X3glcZRndlG/1hoIlS1Y83xibkwHyPX0FmvGuaxzt25fsl/7IrBlYDm969MfhLqYZJSG7ibEv+zCCIbWSk4DOCVxU9AUm2DVr5YtirYXiLsZBekwnd7O07+/rf7CYjluMot7jrXvTpyQFLb+vbc0fPdn1gRwWMQ31nBywdBl7VADgCTF8UnOpI9q+QyiG4PSmhREAElo+sWazy4q8kM/3ZeqxSl1muggUMHzgPP7j7nob39xo2Xx7CX7lclWtI5nFU3jiRqjHrsiTUrIWxdxoPdhMVnphJCaTOYJHE5/AnIUigEmZ7dwdOY9M2e9WfH6voee26z0cnLhvhk7vSePUOa7bPJpoQ3AwsMAxjiB77Kj1IgGPoeOWfyXgTwEDIS7ibF2kJ+Y98lFb1yqXMSpIFeR+Z8A0ELS2/rc66AUYGaWD37VTVYqNu+OUq12CEPB+DS54OvYOiVkkem3kRlbLvUhGoonP842iBIIjU788gx/h3OASroBRnsPi8JtWeqAbAtomWhBrmTauRxGecDW8d1wxgdHZDyAh983pNY3JYSW8ctq7gnUh86NCFdPDqHZMJcWzqx1NfDgAQDiWy5NAQDijLilq8Tug9Vuy1lDpI+Z8gFGAKPjIeJ7+H2GMdh52hwqP/iPzn/cGd0K6jAzR/3qCb8VALeFY05h9CaTUeLIm+C1v5gwz6gGACbBjc+hosDtNTm73z/yuy+9y59+rIk7viABrXCgm11KeQAPOvxrEBIkDk1yHVlANSblFYbIWsUp5lARgKggAiCuTLvrouKWQDUblEMGdEELO1SYkYWKMQ+QRQAmaNYHn9zGTE+JuFVo3znr9sLh7IEAkYiO5iy74O4BnMLhmEiUyf4lFc6kGwDQh3hueiLAFBAwyvzbT34eHSfgupft7mnrFWRS0a3dgjQBcgzDg0dfSwA7JXkEVmUioJxkd/ihuPGciHkFl5XMYo3Cq/gEfjfLA4ircObCue9eAFMhAUEPQIEGGu5/4j9RSgGcp0ecj9z0zakdz83FXr+pzFc693Tgi7Nep0rFrpies+zyiOl8UnjsrqMMb3ORCYJAeAz5CZ6n0q5ZjJQKby/5Rei5o8PrPnL4lIHhgdj4VOnUQZMrutrk+u5eE9D//UAdRopMXHjSrDUtuQeqgnjxkvWPGo542QgAMQvE48pEGk1eqKqurh4SIgJSREF8dAOB9NnHH6+wACAvvdf+5CMnens6D1Hifuik7OgnCX1BsZv82ruCRCfhcNjL07u4VsJwmMtNEMRLFhrc8SgPpkzA3Fao+GfOiVw6O2NDrybiP/z7prq38/5uWO5O2rAmWbkLQIYcDVDIzrkJTl02itmg6TxBK7nkBG4YC5p5AhRCAAlUjCXAXjr7EZtVIUgQb1RQaEBBde+98V53K2A4icezY0Mj53yS7HOpjS9Q8e1zdTj51Szy3ysqtvO41DvSBe1T7i8vEAgMrqMXzkSELGzgzLo4AcMMf72cPZ2D/EogmGtl9FPlsjylgqCGfxlNc374d8BFEioNciSM0nph1QIA+CAdR8PlgZBlVgiV1vvQGeQ4SIBFt7ReIOAiqBRUgnhSMkM/gyecvLT0cOw5hG8Azszsf+MTjKhdawMBux2vKuxD5T8E5Wc6o0ZCpXTvE5cGSJelH3YzVJhALm8SAYCH1zvmcnHAHItyTGH830HDrrzkvCXKzgErHsqeumgg9Aj9owIAc4MJEEJei0Z/d5QAGkFDy0S/Hq10JPQyUHMJiD0o6MlaiF+FJzQTwbuLLlUlMcwCSugGZutCpp8vEgs3fL2ssYICheavnpv9PYnUNqtVDQ0tIPMWjZ7p+LSQXXSAe9q1F7dcZGbXOEYNYd8z0OeOlAIi0d3wpeApo/7Unj17enqSTF9ByZzHVh5x//f+H7iURlrTJFvEZLmeOyqPAHV9HwP60wVADRLORdSPmufrJ2ZeTwUQXuFvbbZLozPuQxGuV1gVECcGeDiiiR0WmRMdPNTUBPTBWb51hYw01QYbgNQtJ0T6O/s6HhPqUZ3MScvw//YSc3oSj/mchmO56ORsSCDx2cNMUn86ekGgdDHBjAS7/fHka/Ke/g05f4o0zT5dYDz+CA2FGtD0X+MPAbbmD+rQZCamYWNiS+OGplY0A1ASe+zKwzazmRs+AbRKoxPfJ/u6hOIgIIfXWvrn3eUlh1xDMqGL8hSAhZpoqigEQNQCDA6Uz8TXmVP3I43vPOOLTG274WEDsBdwUXXyTUiCnc5chp1YOY/wSZVReurCEEzhjwWH+7J2Z4jWlbdBGOfb3DzwLCjq66H8n1sAoZKihY7x42K/OaJPLeiurwVgye4PXBVUO/cHKQNUX8ABwRWVKoBLCm3ME8uZb+5jxWdeNzu7MwA4XGCWBhha1+wXtLyCBQ8bJYtz3OfOmcI3/cKRtuvWrY/YVjkBCBMrHjNp448m0MGb8DoSWFUphyVxcTQwZ0q4t9jWeQQfdLxOigPhm5eHkIveWSorNTnGANdPNzAtCKuTUk+mQ0SpSmrd1LR27ejYHJZc4W0dF83HJmBdBFwcV5ULjC6h57O629VH9nAr/qLCzUMACJBdfphBa60G8PqpFq5fHj1XNeN035znfpE7Sp+/cc3Mt991uJ8ofA8Bj2mbwcEkJkTk60bLbaJJnsZT2X//oHb2D0zokfs/yGLZnM1zABsJnaq144f5JuCNH0cbQCUiNbN2tcilZTp1vNGs04U1AYrJoSdIaSvGOkAmB644up4oLBCXj4cyBvJTirD8xgHzgBFPTFQNHBFQVAOwV64rQd77mcmU0/vJzB8fmbEF+bfS52TITa9Eb3JbsiLghOhCFKvEPXC3I+G/pFoww7aZePVtq7yyXrSm+yDi9x8pRy40FL7QAzsB9E9VtiDOJR11wFrtoeERJp9lVSVpREca6q+Y66yt7CagHoizwJVrBFAC8ph5+cLS7SODin4JIUaHA4ADJif9sJ8CqNFJGaPJ9PYLCjM1zd3/XjxP1LhZ7TyCAqfMPv6/MEB/nkwzpF2QIY5Z1g4ohJe98db9JkHe+y8pVQvFZUmhcvRHtCvVpXIgTf/jFuDh8hipGY3ffMjSAjSPLktLte81n0kqM7PdoU2KK1jrx8qcLQBIRD7hwLqWLJqfBQXLct1iyf7biasb7wCEqEzGVfcRABide1cM/bGNRmr3nql4GLW5MwETORxLMws9fBIOODi3jRoAAIusUQggSJFMvQhke2/r9y91uGiWOIsd7KljdJk25pYNJ8QIlcXcAEP9mTCIu7LGU1tQS35cU6vc2M1nxQf69VOpacukyKi66U73GHCJsa6giIAFBLz/2xN7bDZD0sFuW5F9MwDMJXA5vz5MfE2tW2ZoU9Vh8jdzTCGOnj8sV35FhoBv2GnfFwxMA2uEObc94WCGL1DYzrpTeTLOyEpKAADk38QWaNnYbPJuo8bk0u+uAk69pWZExj7dg0aI3xQI3YmAReJeCwCt1fUNLWMWxE+made+KiJO6winJNHCoVoAH/t5w2BdgzssICziKuK+rJjt7d8lgUDf9GW8iwBBJc29ueIfKNDBlaXmFxVlr34/5TBuddyRG+xH157ppzSR+dPF2f6xI/mDtuNk0a+Pnbh90Vcxf4bf1KcB4DC7Wp6zVEJwqCqoGkc3sBhMgU4/5hzxBL55ore9Z7VnNqAcnBquBWedagQcaf39NbSSEU4YgtVoACxG0Mrc0AZXSKZNpMiSvGTQ1dzUDLLA66WIQs5zAKjgicsEWdQBAG6gCwAQCgGDxcVWAC4Uvg9F09hI6Vy3zG1zzOTLf3VCLZa763/772PPRj9hH1HTo5vZ3zvfdoQEfbAlEVgJMwLzLCYVH1jsUiW7uydYa2qJITYtSLn5Z4KhD3JWr7Ih3PaIsgECphLAC+Oq+la+nzouRxXU4CE2RWQFYcLjkXGPtkxtMEm4UC3QYxYAMMgEACRJ37uTWMsHIGIEZk78ITeZakGgAkBoe5eFq4ufE4lXICvotKk9+/WEL+DUJTF1TlvoXL0VLzz91NtOvTrBmryMwSP7a8iFBjFUMUi87Khv8eLFwB4hs2vJp7fOKKB7R1MTB9Oznpb3OpWqV8QamuA5wJUuJxjUSkfopEnVtAbdyUPqBqWSWdcgDNgTiViKIXV94zlwrOaFGMQA4rgy6ClTCUwKmj8CGClOA2kkBNjPQSaQBJEz9pw89LBl2b1/eOT79obVqa/p9Bqf1bictr1DJT6nTg8hC3EmhAUrX1pqTI0nwchkjCOGxQCEhqdijy18+sD8nL28ypmz9z5yFDmdkpotJocJOAxBLaggmR6YPKvBNIYqalELoDmzej2IWMVwWXbxUCBFqg5GZYAYVxcOUGnAdgGKMDAYgSs5QZxT5s00BIu/VPv50MDDhS/8InOREXsgXSu35cLL1eChP6eOxky5s3d49B6q91gBbew3KlQ61VToAZOUsQHz4pFdTPebXwU+EKUVQSwIhVyJW9+aEZir9a23je4Gxg5OPQ7ALjJc4qyWFiAo4EYu6Iu11WAYEo+OiWIGpUgkSUfLpnox2HgcmHw+sYgiDu/mnwDUYRldqXo2G4QAI9rhH/NIQyNLtThyKNL35NRDNy6WOZeei4hlGu9DHNCYe1zDm2DbthsQJCFyq9jYykJjrp+nAsSiHHgqCzgUs8hvl5cbnQisfZwkdt9A74kBhn8MFIQT2rmA9yNusHB0htsjvBTl1wJ4eQvn3IgrSlOczRmjWsuogzTgmUREIqbhjybV791K4yoNy+TbKaHlDBk+8BZnOq+H+1hZS+CVJhN3p3HlwqwhkR0DD6gfmPfJb2/3cm0qgpCSk5XNzPAAGlOfKz3qmTGAiC5gZFc4hdI9KImKIKUAE1UzWaxRlWPKfTP/3bdu3bo1ENG43AtX/+Ju7e0AhBL2VchtVHQ5hEwA0EpGnXcV59SFNp5m0hwdSOPrWxUReTx4pWBfJI5LAMAOgtTRg7Z4sZE6CZBaSekrzSnBYaNry5CQcWtfzhl41/YO/gutwt+Mh0LWgDY/7xEP4Bw5BIkdaUPuozpPKSvx887zeXk0M9XMa3iGlyQYCz/y0cJvvmFyN79a9vU+mqcRwSmx+ec6AVfjGAN7WJukl0PTOH+NfIw6HLiqNKLRflQ+p3AQDYCKAYTaSbUiCICgFyqAikTcDVk5bS50UWDE3KqCORaehwrHTVpO9Ov1U5gKz/O+vCWbb0r7+cI5aXPG5kQ2w+ESPGJ0Ixfnjc+bcdSPKnbihkEwuEfr00UJw5Ptu1PCxcq+2cDrX5W3U5HCFd8+JJj2cw/QkCZeXc9LNQrf5attQBO00dja5mtPglsEXHzGuXF53TqnIATo7q1KXAKSeC6CuEIxDz18RHNyVeXRd/b3dhdq4MpYmzfK9v7BsHJh1meVdrULmSieLSTgqUn5mCxdL5gHRgu3TBDTeKEDkFu2elZarjXMk67LQ5d0VTG33F5SeTCR/c84i286lHOcW+POPk/6cgGARBoDIOQZnxzT3EQ5lhJkXudEm0Pku3MSism3rCZKAhBAyY8NAURpfmL3qz+9j+4lYgAod2JeyCD55dCJJ2V5tUV554tBqJ43EieWpwww5IXsMuw1xLtOJ8Q66EWwvS6NIh9s9yQc6MIuRj2/f2m18IeFe/lVoXu2fQuKP+cL+c97gFXm5W7QnIwM0jLJLzpi0fB83STvxuTSoLaow82bKCBRcW8kJtX4pGLAkiNQpNJRv5Lg0EAxCFDpQLx0zjZ97Xmlab9j8JV++5TuUgYwAqYwa5czUuZLmwMQFOSgJ+70JIBN5Xl3BuOiq0auYqL+hx4u09ylEGyPHMgOrj40E1a+UFBuAsj0PwI0wNvWYpJftJQSlQHN142VqAEJisTBzQwBWExSUbA3MxIEM+46XTegIvsJigA4KXAIC3oUcfSv2yVMSj31+kojcztgdLlghIvyYcmCPxcCi6SnFbZI44kMjO36emkShBV1XTX0LsZl0nySWvW6rOq2s2nSxH8HTF9ktB3tTQA7y84TvEJEySuUdbgDPONA7XU4q6YGULFJSxlkkONKK3ERoILU7FK9VBSCVqk8RbJBTQ5QCP6UZ3xYPF5lkenL1o7vJzPOdh7Z8Yb/NtvK1ayocgFlTTDj+7L0Ocr3pg2LSVFiocHgov5rRmfUOR44o38qnLVgMT9zH+U+F1D+xqAR+IuDCfhZCcm9IjB57a+FAfu/jviIKAS8fRRiAOzeyRX/JUsC7AlvcR8mjnxAugkB4iUa4xeP7tnCRh2D1UXcbed69h/FX2a1P/1q6vy5JVJ0JlCN6jlZwsOdnMKwb1BgimMBOFHV1SML29ji8MzzZsBoe7XkrtSXTcocJnEawCqHR4OYjj9xRTit7i2SO/QvcbSA1bmnjkQRAXBlM4eBsmIS6LyRP0wQmnECgDMNELfv8zm92izWtREv9Ju/WhYfdgVnn9dHc23BN57nowU6fStI3L2fXxgFZh+fI+y/65QmLrxm/2fohzZRLCjPhEvzSWGJ8GmxdHXWud8DD/fKX4QhySuudLiLuUT/vyRICwSpAyLxnE0Sg+TKGtHdySBlWTPZoGKCNAjPYwOYgdMwF3zijAvO+6JubIZ6wXDG0Y6NupPxgTtPJhW/NbnLeR082Elkw76pUcARvgvpeN8vPIVr/BtM5Y0Md9ag5xR5RuhViun2wEfJKvNevJF/4iPwlpGxKyK6ivRCr/XqPiYV7iGMn4g1gRVApJq0syU+AysSIKTqZKEJAmv+cgQnCIDgObffKR6VCpngltDQisOeSBOpS2VRF3Sun1L4Pty5wN6k3raK8QACYZffcNfcDHY2o1g8azEA4CKPMWlPGDrznWd83lP/zM5ysppXlvbmqLFoZwdHbPZ+RxYa0HJpPs1jSVdGz7+M7qqpqYHnt8QbVJkEcgQMv8XdInz3He6+G3s/a3XwgPebvYfoKxYKVANJEwCQuoLihcOQBaLZXHd16dxxd+NDlhZkakJSx+3I7Mpzb3jR2fRPCoDPEXZ+llAzSYgFQcaxuARVxaiqqqqsAhjnluD0XoHYw2vnsMn8XIBP3WIEvt19GJqiylIdaUbNpVurdC1rsjf+36K70LhJzJXUxwEOAc9vP1NdjAIUoVUMaCioD2GyGQNkRhIAzRCtbR/qkCappbgimZ8QKH/ORzcn2LUoYz6SDTAe0YdnkgXRf1uu0QOm01YFeriQMa7nGSoLJBfv6gYmvATM1zuhlQVjnMCHXk5+CB055/4IVNfPIw0Ys0fPhfnNqNkEAGiC5b/IaNb/DQYA69hM2RaIGQDUU+3Bolvw2WcAUA2ql2UHU9MaK2WYmm06/DgA5+GEzjh7BmvQBOKf3ybfIyXLbh2YOmN69sBea+UUmpqlr7r/mEaa6wQAiEUWT05c6RCfj3I8T0XeollJALt2AYxWFvJArwqGNEz+NokpN/dv508AD7UNvwz79AKJ3BIeqUc96usBNXqJWHLf9YXhhdKK1aLjtr4MCQEkbMBw96Q6gTh8hijshWNUj7NA5bsATBWsVtY+kJIeKKLLLXf+7u2V8lu/fftm2dg0vXsFrfQGxv22GxInRA43ADc+xQ1BNXBMLOaPE55hZIxjdHQUAMjhL7YOdPzMZgQkzmk3bLOZyL4VosRvlvlWtrgzE5JBq8A5o32WE3YA8sRNvePXvdR7BXOVKHfG5a54AoCSH/1MlACwtypRbSa8JscbLsOnK6c77w7wdg0QFezoigoVJJS9h3mb13uMZe1QEObDr7EERcquVdS/P1Ep9Rq+n8Wa4poQV6TnDxWzZ6bSvqmKoIbwAImJjwFVzE/MmTF+e0zuRVwdZ8CQxkoknBnn+1GjYn0O2GOm4cpjI6NAA0KWveT/iQOWXd3hOSBEACAUk1+u4BJUkQqr/HCG8I0ZcE6IglW+JZLyaCQ0mPb24STDy08rFYWM/03nknn3FJpKTpyl+aXJ76n27hyZw8l+g1giVtJ9Jk8qQ+8xVSxKGFAJMxUAUzlyPCXA/nlnz/7tLnfr2GnmD0YgCEa8tslM4pKXEXEQnWgKQ+UbFGkJw9h1535FGbf4ph0vlCcjACCUfHdJd2SRZKN07NitfZLFGDSCAjA+F4kJpsLq5FYcpuY+02BoWuEnrWOrnpS8MEUBk06pFYYypaLeQIAX2E4uLcoJS+jiWTIAwLEecyxKeHC9wC5hnOd+utUdD56cp9Gs3FY7R7fyQzg6805GrW6JP9uz7mVssXlTbelUPN1hGRxVXH/ykwsxD0VLTkAcjQMSVrz1UoU8IewFwUz/O5Q/cbeLpwA8ex7f53lLO2p+egMi36x1mtXtjpQVD3/6IB/1u50m+E93lQZu97mVIYM3OQexIBdiHEjQPgAl8JiFo2LNnqm9ALPgTyVfo+Zv8lnFgiPvIu/uog8B4Y+HUwEUp8FkAVarhEP/I08mBunQYSG/oen/GbtNUn1cCURX+OQXJTA1IoaZVi6M8iePx6v6kWIFDO36/RGiRVmB5e3SR3c80f7pZ98wz9/QRqRL/+LUy4LOk8xd3N5Bh/G4E2hxm3LCk91MlAoh1GJxLwDyQ2XKoHH7scSvH/9cIHN/c/JRPRD4qVsiQKRknzl1dMKoaqZ8NDtXdOud9/NtPJgGNIv8F3T7mmuAbDDOTuku/NQVD0GCYlfjGEkbO7K076yrc2H3jeJueb9AaAr+vt90Tg9n2Tu3biBWf3gp85WIpAYxc0cR66PTRVVZ3QZpwGCfdfooxe0YfOZlRpfhXjHGMt3X//eE/KEx5dixigTfamLd7mefZIHcJtFLLR494TI8sQvGYS1Qv6vg80+TihNDqw7G15OQsh5ouRbExB+F04WIEk7FQnziPfWMaTr5jt+eH3QuOBZ5aKgts5+j5342AFgBpn/fpijsMo6hCw6SkYpj+y3DOoWLVHtPq50yw0iRWMgevWsQKCZDKrf7zqRl979gA+H2W1j8vmr7bc+hLw+CrREtwMEPaJ7H52HSVw8F6urRgHqa173gEEuYtEOmZDK3LbCesa5BPa6NrW8O/HRXSrJonYRGgaAOYXfW0NMt7WeyxruBgaz/3QfC3/DeHJMjbEJamIZVYapV03f01qyhHrGktimuzhaOajgwBbuFZ4Th3MFeQgPds/MTKMzn3LNY857rASFbp9w6otjDiJfkcoNOeee0nkVOxYbkqwCaAxKzaDwCUDAAeDkVipGgFNGEQgux0BEMqQiuRdI8qpvv4e9bF5H6QoDu3mLpjC5avxQ7VWB0/x0eew9T//aalJp25pjhU73nZeo26TiSeXAj0FLToPHLA5Xzk2u2AdLAsaQEsVvc5NYd/MFyTW52gPA0hp7rAWESOxKi/bt7I+gYQ3r+bSagbZ/i1YnKOJdgLRaLZp6Vp4o8SlIAa53XwzPRjJFRVmmaSXgKNAOtk72KUBv7bfcBckAikSS+K0j0J7g/srsIoVljZDsOlOlaLNlwTjcDBEtRtyESnMknSdMr8LcAiJS3JwVfSg6tjAWLVyXJzGE2uYM5uJXFtICK5wUy6awSFF8LJLIAqfyS6R86yXkw/jNYVH2wQwmg+QVOagWj8Y/4I4N8poQf1ubCX+PCpkbVRqaN8Yr8gohZw5FNgSYMVbfWNwNAazPAZ7cJmWZYJmRiaGgZxZM/4e/LAEb+5JnQ3tU7PKk/AMbZACy0h9SXzVXTZXQu623KsqMGsj0vFGbFmbIamRaHCqemgc4s6vwhx3Snk/eKCctTCly74hnpnS4iHom1CjiTRzdiAabcKCbAZqqmZeJnXC6iYhK/FOQv8heiuk+yxdsM1KLh5bRX+iNjDqE2LZXPiKwPbDhhrQWA6lpA5MpxpEZaajYZxRwArSkD36m+WLUVQcWJ959LOBH5eGxW0EhnASA5klCAaWUFXYtUC7miqCEL9fkvFQ0ajX5u9u6jem0f79exYubm8zeAIHrMHyM8f/waqwoA+fIOyfbE2UxtSdK0+8agEXiXl64GNtDMmMiR4chENZpdRVq5xDUGOiozjlJVHVpQ04IavKJ3kwhnQnj6+ABP/K82o/ajbp0l5I8Z/Joa9LwZAuLq/6E6bw1ZtZ8juTiuLAkGPbNFqmXjNK4HLH//O1wPqrpGbokol6k+KTsYi/SP/3eecDCY7nj66ZWDh+WeJd48993vGJBrjYeEDEhUdrUHZQLIvdtQvbq9/uFX9a7Ts5TAqkeWfORKHQxaRKknog0AsNZY+4JgkfJkpjcgGE6n4ic3QUKMLqPLnwuXkR+NilUCAon1BG8dR1hhig1L1+OVgLy2tatfAkjSf6n1yw/tMBS2ZQ3xhOYkvDkKJWZ35+uBR996IiuNYx778S3Z4ysLO3a8N3twkVI6S8vc8LXoq9vV59VE6LeOpQvdO8m8MqFAHkF3yXVxgByIbdkKIPeQ6Td3FeqB3QjfiS02oV4YCeqfb62euE6yYYZLPma1RxirgGcZ0YhfmeeByaYBUNNkgVubdBq5cxmgBNnRc8EEDxWpxTN+SKAo/uFvsl0/w20fcJ2zmxSMJCTQ5t+xIyTashUO3VZXeMr0+84wHe9uU2DZ493ZCW14Yao/KCHHivhu4UyJS5J1Jsj0VdClwqgxeEFb2DW195o1Mmd3+Q6fCzaTYXiWHpAk+jrRbM+wCEcYDVA94eJtVijPPyJYvU4lHzaNiCSJKqnGJ3/RIWVrANR5PCafm0staWATiaypf5WOGSSZfCSwfkJLiTEEjgrq+irLcp+Fn6EOJQrThU6cYz8BjrdlJVTJB/zUXPYmSBiE2/XpF3MSMZhiRzGTvQkGiExuY3YiO15tZJldUU9yIpaNXo0DJPeNc1OkT4wpXDuqQjpgu8R1RsOxKsX4ugbNZfVj05xB4WoAaM48IUc4uWJHTlw4ljJa2kEa0CLgarAhdUhBRYV7lEDegFXAChNZh6JBFlBII87NUlFmPyhIe6a2PqVwrOhWW/NzSiNWPe0f5+JPdv58kBIjsIOkdSnE9/RpAPe5FTbBg+9pJK6YyWGGqZxxAElBTKzdAwDF12xbRP4ZfhIFZDf+mPJo1ATHn/KcMg1vGfKua84cvQSkSU2ZyxmPNlt7NIGwIM1uQrjokFzyItBc++kxhezF5loAzbVNNKQyj6rtToiRRKbpceR2niolVOcykR2zZ876zezsz9ytX7mxMl9EUkq+fiEXSqZ1qtr1mye3PHCXtcMAOHslm/5tKjUGeC0c5jtHAZ6AJIWgQfReF8gg/obpWp/Qmfw3P+D7MJoGBCdnBmmuBTbJxPaXL32tlyd1Dj606JSWJBkq8mTeD7wgyEvE1qKhfm1ZNYBmSqeNJVznDOF0M3v41SwP4EnzH5mjp8STZTPB8+R9WA74Ow5YCr9eePbAvoHE+7MpCf3vp3tmPLINALwisYATm6IhOMz4mUcUkHJCCsITPnx9IAQAPhfvwor3P4Th0/PjkriBtauuvOTepGKj6yZ9jQwuntBdqECiYuTj4he3yTR7xJPjnupR6oq234BkQvZlx+C+5XHAKZESauAJoTuWHz8zTwsE93ebojO/SzuQd+OXy4fYvVPWSmS6FBsAz5QI/JIgZGl9Jtw5wunciGY5GQZR8bHrspZwVxmezJLQRWOxD4FfnYxmR8/zNnldyyX9vEFeu/W8wCuf2L5aJn6uQPhlAKiX80IhK9M0HedHMsUXcFxog3Bpm8MRqpy1uiC71U8f/sEEp1ioBh/o733plOB5wMV8PI2bFYA9ix8i+7MTj9z5H9PIsNYlSSbTRnVSEi1yGkwEEFEZAAN0AQrzHlRh19UwAKa/puyvd+Og/VwC2GtVW6r7+IxbFVuMgot+ucJauLgxLnzx35742TQRPdcgjvtNYmkkXGZ+nF6ZcyG4x76DF8nyXaw3cmZVh/ivspDTpFF0n2W8vdu9BE8AuSZKjIe69A35GqfqZadnZ/U0TpwLkVQuT9M5vzbz/V63TwC8ZUkEY+zhXYgl1cKqKgBRXF0YP+1I8LQ8Y/6dgP+cs6dJYBzoNZqgMV6gSDUaI5YMNFx0AtUANI2cT21paWlpaTFq1nbanqJpQhxW1AKTAp8UKzLmpa0tjot+YL8o/IgcTDCne4NfQK/oZqvt8gPzFgHDogeM48awHxypA7IaHK/J/J1uZ2omRG0Qztsjnt2JU2LFb/JJkJefmToL0F8wEK/NU0H+VNPakxm312Y5gdXzpbJBzWBcb41DMEKZ6R671d5Qz1slznWbJ6LMWmrqARmfVP56UidNVCrDlBNif27vJaW+KWxhY5KBm0WMqLRzQez5J1j5kVLCr3IFAJPi43tccezcu/j4vINcZO7Zc1RBlFkn+yNHZ79p+nqp3p1QQiZQA+Pc51VOY/V4XEqhAbDnWp4CABSImZqWao1zJJU6gVUltKeDCvIWsUNGMTmXge7RBrsVsinC89bJ0XI0xSgwTO6mjnDOjPN8jeahSzg28wbqXou0fX1KWUdwx7f3uQJdhThKznhVUodzcOq8OLBDzv4KXWxIuca1dJ4kilLTngBMThmFMQGJCwH4v4FYbDALkQYS/7/gKDnTzWzwbJCBxL4HkKHyNxoI62gn5IRLOzuZws/YRO2NUX5IekWiIBpwTfFe0VHdr/khkmysuXx7ObBOJKDN/vjySjpr9+F410HXWHqkI9XBHvwmIPfvNGxDNZg01duz7i9fOYd7/CbVQh1kywdsX0D8IYhdB6fZ5RoSLv18SUZ+0GN082ozILzmeGeiLNaXzmIWculjQcPUOwCT0h9pTjETjigbVOsGY8+IpvjkqTLWcFWALyAkV7u31iaHBfrw5Si0+oJX6SgzLOdiHiF3Z8VJwrj9hzqzjquZecw7ew8IdzvQ+t3NGYI79y66eSlvutdQvh3ib3ZLp7B4/uFsdwIeKaG5ul5IjtjyblINd2o9e4RXJSe6jMPhkDDMQxv66VClAsAWfcga6guAVdWiFnVr4QlSEUN7RRmyK695SxjL1VEzRitRkbRLGtBmGheM8HiVs7In//zD5nbZywqGUSrPyON767+MHWbFyUKA6Hd26cW/4x2mcgrS/zBWNMQDwMPlJ6N5OEucgcFbzV+UvPYwEftF2GP+F9QoBgB1XEBU5IvZh28SA66/DjejKWQRKx642KgpSCTcz0YCNlzK9tdSg8+dNlG+q+aK7ppVGJFrxpQTcrTeOiIyBteiKSFRpMgS5Ai5EOrsuuHXv9LEfDMS6puBXTJawR7JG1wGlJ8Oje1eKMvxxIC8di3gUkPnTU94dhdqVwrtokMXD3SuI0CAxT4Bk2S+OSU7qg4B+LdIcQvAEO7y2V/dRgiweziUnFK76ZV1F/h/Q2csh159z7rWPobiUnVBPYAWYERi8YQAnls4Q/vJiJQiNFEk2mNjZzISttQ/A1CSE4f3561/j7jQHnYcmv9kxHsecL1VBiCd6F05MY+7wPaoMKI/hImjg39R9iCZpMw73RFFlR54+E32BBDKouLL63hzk1xliikVVfybFFohAPhBk+JhVetVfTVb+TxNQuEorQdQD4VlLL0YsM+J9/BPpey73K4k75eGNlFZ6feAs2POuXclb+JxB1RYEYwI9mLUBMwtswEuf6ZD2CGEOCUhh89eOUGNXf8KzLHjkWNM+k+PJC0AXn8mK90PhRmPXs5FaueNlGDI4TEItSLZi5u2NKMeZEpUqL468KF2lJ5+z5MRFwkBP2iMLx+rRtPskX9YSjlpORO8UKiVVIikKaK4B3gm73DVyuzfVu744Xvi2VpHSaAiCUzcDZG028xtz7qN0jGyO6KxoLi4uLg4Ly/v6qAkAKgqAUrExeTdGeV7q4Cd3JDuPqBRz44TlNyzzgL4eaElrhhfh9YhyjOcVhBVj0de3nLesLDdO8lTWt+AFiQCmrknRhR09th4dnVTwXGTfLwOzcbR39aXCNsZAFBC6CvWzJuKn7rcxY3bAPm33b50Kgh7BFQ7jhLhQp7TA5q/VwEuDcfl98mQ/RH7i7wgFxdd68mqAoYoZJCrsKskCsgY15fxmQCY4dFzABCVyCl/fMOmMUFNvcycLhpfB1TXknXhIjMVJlQVG8+pnJ2rUVNzZb8Mr/aNbIxGjrLR/vVxkV42VgfUnhY1T+/vuBhsl8Rx1jLgf23f9HuOAk5Ht1/ErIb03+uYkVKzvF/argec7NMAxMdFQhKHsfA1MMpYgr8+Q4EQIDLuQJdShS5mLjPdBHiP+fIjACxyJ7LnSciG0uebNhUnznu9aAZQC3TahsfE/tH5Pn+KdPNVMGp0eivlNrZATZi4U2rtD46tBYBGkjl0SS1qrpWHmBVk5SIZ874NYDbNMgUf2nJ29UfNtf7vs+fckzkbgGjcBhgkLAS+XAx0/UU0e5yB8LquxV29vb3dKehG0Wx0yqqY3vlDeuw8Wki9GqAZMKhig3p2xgnwKQOc23sxYkmprNsYIAJn513FOO27Migen4zFiLcTaKiFZc49vUQUuRBPnll9yUIJhZrCS97f6n347xvI6ZUAU3/8fN5Lwwu2OF31hYuIuEKqB5ynTQD6O2bG24bdD0v9pgc57SnxGVxbLuQq2mWYlZSAzuoCef0Bo97zG2NUb3TVoNnslEpSw55DFXZxuuVsxNt45eMfnRmYl/uxdcEhyjQAExfCN9sb1mfQETpj1Gir3yQbm3IkXZy87BCewOzTgpIF84j7BCsUKIOqB05DtIvt4Pmq895EaAGdkzmc0AN5nWrAMMokhLowQhKtptwuOlSccp3N6oJltdjHShA3Qwim0AjPqhVxpfGhGqAWYqlg10++ucIpzFQaZa7CgYdUZobXG4YsGfhDU2vz0NrNm5vtaGISVDajGq76pphYmWZNTgrUap4QhWmKhlS61ZNNOz9lDKRyKT0t3v/e/rm65W/nMpq5WyKZtkenAu6jcQC29qSZLIO7YAx5SZEU3ePXenoBAFUlpQ5WIYyLIQSYKmDskV6OiCdEQ5BXql5d50vLLPMfJ9eG76ZUIWROjvuTaaJwPw1l26EC4oa2kWj1R37/C7wO8Y7GbJnsqkMtRTiEqYPV5Uzfb81LiExlP39jB31cLHv21q9eF3I9f7wvJjjidjgFOSbAWVRh9CT/DMlgH6MdDwkXXx9FMZA081BQSGVIJncxAGQnhjfWVp+sBzAu4gJlL7wi7uvrSAhSr42KGuvjuwXr5IwqKk0xROioFfYGhYlJow2wReoREzB0439TjfZiwHMzhgEgTNF48L6DhO7+i+zo4my+MBS4N97T/xag/Oqxx1+eO2VsTjskOqsTgJChpJ01uwv0t33j5SiwOHqtPQgA2ONhFEkRz0R8ABhAckoy4+KwdUEPL5gJjVgRu/N6CZlJKKCshVju0o2InObMCt8owLNMZRgtMPaoF7ZL1Q0kDa7QFY9Rxdz0KN29ZJDOE4xAlkjrLjj+Aal89lkjQgomaevsWXPYtFPROQwAyW6t/944JK285wGWVwavZw4CAKqq1DQphZgTUR8gBLa/mbUGzSEAtZvtVmeAy4pEzd0b0XrqipCzFtQ0h4jZK5gQhmu9QvloVMhwn++dKuz5I2oAKjgzdWwtPnYhSSYeqA9BCwCho5ab2YrnRf90mMq5hRWnDRnJuJS+B7cBTOdUIslZYsDt+xdHAMAEYahb7zme8dXSTE6oAnBFou0LpRvYVdJV2jm1t0gdF/G+xQx8PffQxsYAz/NbmkbhL+nOlhQKvGjCUOHVa72WFyH1ovFUVzeeJnKnaASGc0+uQzMAi947hUEzm6ScEpNPSYl/SuIU8T0OL/oa53zysTX4jxl0547Ho6+fui202CDq8H0MkMR5AIY8vzup0UMGg0gbUWlduy7utNeWLiSRmZcIxCkj8DGu1EH5PG3xvHnz5sU0Yj4yMve74IHMhIk2114bKTeopI4LzqtGNGWv9olk2m1luZu2rK1trm8akBrGMpHCxXwTrS8j0faPWqKD5HAbM/szNnD/ntMzZ845+9vsd2f2ykZjD6fHuDgwMsMAoC9ChCOerDzu1uB7vqNOHMOulH8FpARm7JLLABFHqFA83tgHOgRQAhjEMeuooxNdSbM9c8uViXBRA2SLkqJLXgdSDYbYxNVR3hQzNNbW82mJYGSo2c5pBBuviruhJISFx7O+mUVE5OjPBEUlf2vTQ77tmf8Qoh77Y2UjekAPp0CPNP+UAOsmPfEuKfilOwFgV9V1DqgWAyNx7ALMDqHeAZmImdZ9a+aUXxocBuYZQzBDx/UyC/iGdXFexZzfBDRfceegiSkJJlovbK3Ntc2oxUb0nhJRXqXdUJrCZwatoZjU+KwEta0A0HRRS1KCyttfH5SfbhX45o+6ZkCQB7w++oeax8N/9JTbyURGDYkAEr/+vIBoF3aeHC+0xYNTZwH/whRxQCGfWVJSBbN5D8QiSsznEz+gUwG4DSKWahJj+tIfNgLrFcYpfJfkxcvZtlpQ01g85JBd4Uyth5WhIkc8LcbYrFq7yS7jyviuC97VpojwgmikdLBhBOy+TM/CP30I5yDvvA1uSaZ7R+IOpySRYzMCgMQdNQWn+T0RrVex6i8W+7JI5zXTr7qIqQhmP0iyC1XArqpdRWrGGXTNFMhJXVZj1otrwwyTo44DwMbo0FC/LN6UeZlJahDqOyclk7imFeDPcyOudTKXK5F3g0/skyU1+zsmcNTXhyoEFw4yZoZXmZC1RTYyj31FjnKwBwER69bceAeKCqRDEwqd9BGTW+L3JJOGzrYcQWT6JXG8ePF1KAI/DMkuYNeuXcXjVeIAA1P2vw2l8Khurm5tZk7nkOmS8mYADWlepcDED16WJi1QCRbSyUHx1QBJYxV1zVnruCwckyl0KWaOSU6kswLIct2EDKBdK5jH8UkOJKIK2Tg4BP4Lpjz92GdGgJyzlAEADOffhBhAYs25+a9DnswKSvKK/xWMErVESFx6lACzpgLjx8wMgG22ZLKxSYTqWrxycPS7MyIOAOzrdL6oiV5O5oG1pmGeuWIr20wlQi9BbXVr+WCxPWgnBUyUsfqBpsZNFNhwKQlkDL/HdH+CS9IeS+ALNgks/yskd8chHc4annipzE3UJEnNUie5jvxlGB3xcXqJ7HqUAIASJIScmPWgC7kAwFaNM78G8Idf3lwWTACtDc3FYlrCxNZjcz022+PPsarxLcBH2AzUeCWj6Ucmd9fSsoaGfsomQP3AUVkAYYbb5RY0KDW0cfrCYFCh08EHKECDgY/l5PUbXGcXCKP3j5/iS+6E5423HQIbnFO0f2fhcAKu3yTgdPcPJhDPp88+3lFI/Xu6uwHs2bNnz6UhdwFAUREjIJxYKqDFWIygXi5P55RkT2QFgNz//YoJFK4BsP7cE6xt9MKldJ5Jw1NbB6Kb6gFYR9OSgoGLQrK+AS3Qnb/Jsm0t0FQwjBAiFqdE/GKLIBkYeOuIKLFLXlcPKMLBm/HJa8HBBBcpfme+tlgdkfj1CCb0fqLGyrdBdPBOWfbnqefVLlX2gP68OD//9JHeylujUf56hghQondIhOBFhyoj6AZQFQRJnhOenRl4olVvy7npB2a0ubaZ194aCY+ljvBpdgBp2nPJtwckF3ZRysA++WpITUNMujvBAM3cGFUEw1ZkQoYabJqyPOuzOwVbvp6wRegPVS8JBsFvpZ+9I/LIWYbVw0v1ucIonKKkMAmc8dHESBRzxzzZ9sdqeISKuvNyNcHrqSaoApIicBAk5kplQHEKoAol1Ukm133gaYMH5iXrpKmB1loq7Ip0iJMpqlEADbEzNC1hsPD1AGBH5KrTVGmKmoEVzTSWCA6HLeQ0VlcDiGT+88zd0+gvFlOABgM3yXfiLdDYStOd7QdKcn7RGQOEuehMNUJoYWCE9G6dIZ8zud7iHjz92AcVwXbC3zxbE828DgwAcHhFhA9rmETcAciDSJKkesDFsAeF+N+dqEbkpeIKppkZE3hJeJwY5ABg1KwdV0pDUtlEEBBxTwbSWk/5hIhZAxc1kQibKRpPlQHNwMsjFYnPdv1zEUJUUTGX6ay86UwlRN+jIb38pvixFxNJrKROF+mDQ8QIywDnIMFZFmvuWLGN3W7RE6gUlPVJqfwaDCUAYIZWzYvHWSamcZQAiPmGjtlcxN++3XVjvO1Dhzk38TfP7kIfa7QzvCCVGWKsdkZTg6a4cPaQQxIG+MzRpOry7lsvK2HszKC8dpOOpDrGVT7RWgDNAC/0keBSMjQKUnxaNTvZOXtuyo5g13h+QaVA4tQro05ZzOjP8GPlX0lIB3cmcTJFfU7bzTJ3UGyktjzemu8WSKORazWTIjGMGE/ZVSI7PJcV8BxPU6hfbLdJtjPin2lyLXlzdpodtsVzFTfbI7xwCp/GpU3hebu1vgaokxYNJTQhvgEIY1K6inoaHTo77kVtUzwRPWo2iCYuK6qCQWO4kio72gMv+62S+NDnFdXiFLzbBmN2UM6wM+l5iJNGd3sfnFtzYnmAwOPMoRR5Sd7tERqoEjvswmA4JsQ12mIJwNDkrhSgK1IiFXM8SSo4v9h+TtKfzXSGfja//ZC0w2nG1pBfWDpD6k4I/MwhPlMq09fX1wO13/uUIotkk4I4DJPd8nI9jTHQgIqYWMmQYFjaALS+YIdwetVPlQIOIy/cwo5GsIj2JZTK+/2FFvVflbrur6JGza9yIS41QWjsS7rhPA1jcLrNZY+fQwWIM5SXgDmeduxqj3VJFeIFUsqgZNcuoBt7Dul4SGShIYFtjFEYmTm5SxNzMDKrHU5rcfpAx+A6JqAMgemKamb0T9ywkMnJmEQrC4syJncsKynPtNf5sUlrHGBPiJiZ0ADVr/LpP5v+4AfVS2Yabrv5E/vgz6t+eCSrcxDzFndw9F3DUDTxaODcV24vEshlhtkkICwD/ed5CGmp2X2cOE3YsfsOqnJi/AqzDsCuEkgpE59I7rS4q7g4FCMM+d6713TMLkiSPaLXn3snM0SW7rqL/FFY5/8hLaLL3yNY9xEXEg3nDtZj3SbUN3wyoCPJrKMLepQu1HzkAmo+94aCxP7qR6PhtGgUrCFE6tBSs1Za2vu82N11qviBv39ZIXr8kx0MU350oUjYusg5s2OjX3JeFHt0G7wiQxyauB06wC0UnCjUOGUIWTRJt9GGtbSf1e6c2ls1iSIlZiThE/AgPN8FYFYQcjlkZMR3wugWP/oXTsfsY597/YnITYvGqp2Fb71L/HNHmPGYnnlFPD6etNjVDS0WAPX3rfM95R/UMPZho7/hIb+fbhKyHIm+iod4AeeKRIQSGgZq0Eg/fToM6rd2e5fc1E4G33jpifJ2C+2+GduMiTUx6jhGk9scAWE8Dtc5SpKASwJ2Ogdh7iMW9/BYDnJ7H96vEtCqXiQXX0USAc8Q/lhXcXExtCApUJEgPEa3+NH3zTonM3t7Gchy2R59t7k8TTb/H58q7d49MLDVdQpm5px4vR8taGgA1jYxDH/MzI1KZPVSSYIOxKJRbEZjid4NAkRgBYAtknk/JiA2ah927DwmHhp56smTNy3snVo8sDxlCoV78JgwqoOUqgwOrGEc1ASsKZDJeL3zTPB1TDEzQYA+Pc11jbuha1fSF+DBE7aoCgD22GS7VCQoHmDdYu59U8wgZUS3ss++Lp6LdtM7vw7EhplnpMpGhYxLNmKt74eE4fML3tFm1DGBiDBqUs5ks5JBlSHHGQUWNlmGeZrmm3AxAK+cU86pNJuedwe/L77PTojtq3sWSZUv1aJH7HblHQhpMV0Dv4WFw4z3pcIk4Nw+oDcl8Aw3YvGMj0+lLjKLC4mujmKaiqm+YxSEYWRIdgPFxZUpJZxXbI+7xUmBKeYcepS8c2aRomCApNUbl/fdrz385p1pQ91pPpkoBDV8Jf0+oeCy5GgOymM6sYADWA+vDsFqlxkTow/sO6Wx+Mk6oJmf8enTc3HoiBPhe/OMu3uns1vJ4xVG+k2aTZevyjv+XerCuEeUAqsN7ixPRAP45AZXXA1D+DydgYHOZbb7T5a7VFSIXVdEakzlNRQkBgkIr91TDDlUxCu22yTb33w/qXNKk3nCEWXHAp0pe94taZGMk86zr9T8yqAI2LUWSVZnQ32CK08extrGCyHXtcCGqKcC4cFg4FUA9XyxoEOxz75Aet5q2xyM8AHd249DylceSflyuqr6mLy75El6q5sS9oS85EjuIe4ONg5xipdVASJPMgE4T5c6DEMwuGG6S32yA44UozIYiaRezVq9mMkQHmJCKeMAicpVyZB6H+0rfvPrpM4pSyQHGSpO35cwBl/Ma9uTnHuk+NTvE0oL/yovSz8hw/SOqFwXXt+4tuZCfy0tqetw+MRgmHkaAECGzs7QAqf6z40zdlF9ZIFg31a4y98kJx7IwbdzI23vli8jRqc7TtWHZ/9Npeh4Cp7j3mw44aaFxUbgmVIDYzcgEvPgH31PFjNHVdMyaVpinF5jpgtCfvQc4wkE0lkMoiQk/hs7JlvxPtU5ZWwy00ReimrYgTcKgtu/58pPrEXeADoTe0m4VHV6yFCHRno6mqYgLwMXomlqgAteeACbqMFP1aNyXcIfYxpajL0D74T0nlOv5UmJ6SmM63+8HQBw27O70h5/Yg2z4NcviaHQ9eYOhAya/rQRAxxyMUcielPU2zYz2wn0WvlZUyJ+W1VQdQVrVe3CrKANqNq1OECFXEwsZSDY6xYnBcVDTmlSF0rohGRuX8KY7MvL0nn2OB/8ccRVnBDLEthD8rSC17ia9XMfazvu/fxOABBwRleLHxqcagFqgC3ntTRA4qmiqCTGoB4Prb9v/xJHpmfra0ldGqS6Q7eXox2wJc6IZv3l/a8GQp3/Do9KZ3JzFc7jdCwXyPAbXKweA1at+pw4rB627tw8hTf4i4NXXNmYQMIAxcHiPYsDSUjFjCthWyVOFsiGnLJEMpTQOUlDyTESUsz9sT77p/dnCcfyFLP9iu8Sg3WbdIkBkxTGUWX2WcGAaV0TtYyROqClpqUGQIuAq9kSKgwQ+SmG8QgZEn6pJR5e5rjDwH7DvPqguMwUnNZHjIBy2jfOM0STzZwt6qbzkXNGB7Uv4gUlOiAk5hHReyXU4kBOTOETSPIR8zO9VeOTr91fWO+9KOnKhW0JcQtFLqfbI04IkzqDpiMhf2QbgozCOW+GctahhUaakhbqSld5xCY2Y3u8RRGW3RWmcIlwMjM2P/m5SRubEV6/vjmBmmYANfBvZWlU1NsnCipF61IzX0I8JfHQHXAHffx7N99gchZQrLEB09pz+ENKjqhv6ha9AtdpvdM1OALRdFES8Ip5U1IPUYrASUDZqVSp1Eo6bb3Y1X0NDvQCXQApDkGq+q7P7RGxgqTOOdiRlCW2OWW8MGSSduZ2hQpW7BGSPnJCl4kM1aIfnF1SZiieZAmhYYNxNMV1UncOvCVsHGPQnAmgdTTrZG7e3nSd1eNfBTy0toVVP3jkRZMH+hVYucWEjF2lJmwD2l1MtJSr/rQoch85BylxmNzJPLfVEzbB0bkAzijcBS6aA4TIEcWZh0auvnF/ZbEVd1dxCXd60iNKiJI6pzTJyVi9M2MFZRA/m+iH8o1XsepAZTDIyQ58nMaQGEORa8zwhYJ1omdOen+iYDLFUh/LmpybKABUJ+yKgYP5RqHTvq4BgJGiuL3Q5JRIAw9jmyLu9ONCapoc3fFPZw7na9I+r4C7gBqRw7ol33YkgOnzKfR5EA8a6Q093GkP11/ipIeK/8X5FABUVcrBBeUJd+9FHEkpq3dJ7e8xhKkPKImybpf4DfqHf7jowNzSeYHp8ZE3o3GNbvWb/Bh5uYnCgjHLeF0TpUlGzfFxQS2aeHqzxz6olHE1ALC2sVE7u0iBiNEuS3KsAQ5RmteoGDDB1V7izvDrgURu2C0LaIm6V+GSCBIaQObnaUznVvMkroIzKBD+Kj7GHyu+jqf3EpCginjFbewXY78lZ3TOrlJOyupzj5kk59VMPc8sIqH6ge7ntot+kiDb1rm5SLSQzIlJMbill7HQJrJW4l29dnUd6tauSxeIZFKOb9zCGwyHB07mii/kA2uEhbkzA36J6FSWWZQZdJt1kci4QLCDPnLYOWLXA7mkx53ryyQEqyFkVyUBtw4mLoH0NmNnUrZyWo5kzlHgX52pT5i5u1Qh71Ab6247039WZ5CWlkuz9c5jprHzajAgsEFJvcnQzjzMW4jFbf/97pld7cIqWlPvUBDGquYnhQesZnwRkV4pY42U+mdk9NVM5HFpBnpGzwTHuvccTfa7KMTSgAe60MnEXO2zXacZBYC3O2I4yticrr43nU+k7jQA4jMskma3v9ydr+Pf09linHmskxan/AuCdKGqpIRLijm2L3hLVVJraH2Ue5t1uqSHJUwMXgZEcRrk5VDocKHq6/kEHYanl7C+udPluk2oTRuxU2btpsn9rWUD7qTCOSoeZr8VMvUXEpu1NjfKXN/2BPeNZNFMk8uQkno26DZr0x9YIKj+tFwHGGTTjYY0ChMpMT2zd/xLwNOmiu8sgxjGhMAd1xwcGJ6n6CzGtdr7JZI4TCkjYrvr4aFpibk6w+Cbb0pn63MlpnvOq81+EQOEVHBBxc4Ah8Nn5imVaUeTcImifE4j1hRjLPF2cv1lx3Ut6n4t1vmFmY6NRE6IosYPALXVta1170f7DjLH6KNESV0uUiKS+42ebR/7bN/vBKCriKJfozeq9Qfxm37mLkA4G08X2nILqGo1P8fvNlUVJQNT+WsN9Ull3OU/YnM/hVN36zBgfUdq1Ocee3Ts52qsZISkARfEKCU3MuLXm1/l9er0T35VTPu+Vvxbg6bmFX0i5ueTDWiuvRyaDKDFL4uYva5XJr411wL1vCJKQ0v6hCV0GUDKdpjHuD134OH7V7mBKTaJ80zFT/NyezTSAEJ6uMTZGGCNAdnh2WGzI+OfwqpFMU7tlquQ3HM1gKminmJeqQppgl/osep1vmshHEJKoHeJOVLeBx8Tlwlx8dIqUXTOEO+tPPu9D3bpH38U/3XGqa2rWhqIh2fLhHs3XOdo1cLPPnjh/l6oHgATRUh1IiQ9OvublaEyZG9/trh7B3vnhwBW1kUhEP40H1tZMDmnk4CId3tL+1ypO4jpPMz45UNQRsV7iiORlOuGLsoRiuvWx/TA1q3AxazMQoaSPgTEQZOTwUXHCC2S0hDpPyrog/feLYLwjSlFo6jR+MeZCH9aM7Gd1EzqOoKxa69xqBBRxQYDs4/c1vHNAGJHoDTkAcCLZQlkP3hD55MlJpOHPmJGriCBOX6I3MtuFcwIulYefznXSWMlAJLJqztFrwCHIyIZK5Ltdnm8Xu9Kjcbv9we8YHmixkomMQUmBhQI0iCAYekwNwDST8aE410jbpkgLfg5ajSWQKBLoZgiEKy9EkkjFZ7/nkzOLg0AChBGeaipe/6OR555TypNDb93FICPiZlw7p3kL7aY0Bs9/RbQmWZydzidAiNRUCIRvP9LFEOEru4UA65T5JWLFamMZXWeVvsUeRJfDQ7yKcmk0GtWq+F/RhmbAjDWUDCgmANQMjo8uvtHF539SMiq6oylBvLYnx/dhJrU+le1/YNjqfGiLZP7treidMrUq/KyQgGESvwqHHIHHok9AVTh7TiANeX7nA7MLLEBHuRPMcAlMDrEeXhGtL0srByMeVwf7nQlYseAXbg25RUQUsXN/PYXvYWJ9m3abbqYTqeLGfRxiQTQtJfAZJNImQBdtHzRpzdBSYmKKOm/AcORvpAovycw87afD56sfwHNWLOxSEkM4cFN9ZcTsjUOUol0FPgEmBQSHw4DXVOIihHSpc/G8bv4voQRcB/YBWIGbACyud5+YA1nIyanc4sRp5Qxg4Oo8STYMIDFkJqvBFECFBOCbS/784U75s6dVDO3ZBj+4WoTgBEnM7Z88fGPHmmniQoATOSR7NcrM8PmkuMbNQlv9ImMUu1QLYDVXNDus+r49RfTODW38lwgizbgX72ZTNZWPueNXvGiXQCktsSNByZCMdw/J08YgL8kYYohT0SXheH4BMRwlzTO9wLYs+fqtwF2oYCRJplsf/sp9zQDAOeF7IJ5R/tMPkHMDQDGuJDkByorSOXBNDtCpOFFIln405ofe+fpEpow3HMlET4TAFrsjVswqk3mb/JKp1cDQD9ncp6+PoYQADb+9nuZztlrmtMBt2TvtrYLR3aVPYkvgZXE4JwSd9oMhDrJ4aRAA2q8eKyz5yqCdEEksB8s2Iaf7/1SBQAZLrcBQN5IFBpB1AQADhiZqTZT2XvbJcSGbIoN6kXRJySZbzylB7sTriPpszxl0Va0ANbW1asjBoPVaJENNgNNTLFmKKZXoQVout6bnhVtj0pUBzc+fxyApI2/B6uqyyqA3C7Cx+F4n8UzdgirnE5nuytdTvQGV/RCKFLxNdpvCRW/tv9YoXhvcQngz/PrCnqdQKAzas77LGviFWlmgHy1uKDf6Ox4J3Pjdr4tpAi9NE3qd8P2PkboO7nCFkvnqFIC1KxtBOqpvGQIiUBcgahekHuIVbAvt8ArSsrDPu3EoA3NNNxQDxokS5ccTbrEigWAUxtTfa4sPl4ZN8Ev58IGeAXqXFevOZjqNLqOEMfs7g+iCcHOC/O+rP0udpjdkB+eB0GjxT6D6boBBlvRYNYgH9U5pEQFnyB26VVvYMjhPhOAR9LWjx+jiyJZHne/2/XNUEya8Tw99w5mVJ6ZFqtBs7G5FQ0vrztozpy1ODlHaBnzxyvTjUBNIhhdGKG4cB282UVytlAAshk/xuOCwSAASdsh3FxqfqvUBBfZxxoAQRLtd5qlIgriv++dxbhjb9BLL8a+d09SGvdAjrnqHX/ls5f1ZefLoJUNcoNcug4yqJAnyLqMA8ynW4xuZE8VuskAK2jLLMqKO/1TVRW8R+QTfLGkWnJvcllsY0KUWVsNABu7ugf2WH/SMaLY6VGfXwXUKm44YZmTholMEAGZZNgg4eny2wa3ZPXKiucASKVLH27TGT44DAiTs5NwBUr1sG4FQ5xGqllIBedxExu/ThDQnp6qFFWciE7F7+V2/9xpTAvaIoY8fYYTQaqG/62YG7mX0ooyZblv/rQylEteCAEV8mlV2CUrlP/M+/xi0LZbsSfR99GJpUwgXt06oTgq13aKNAmhVLmRsGbUAk1ptsynv1dT2AHQcGXngoXMlPAOvP74eok0ZgIwlLrj2dm4iTPABZ6ZCpHsuG/lCLxa3gQn804LsxCd1IxrD9qKK5EMZ+iPEo//8E0nVqKPBnQ/60s6EaBqrBQsMcH19iXNifxPZXtwAwfG17xo9Mwf8cUg9q2ZZ1H0twbL2sn4B2cKkj19zTc7BNLMarSOTiwWAC1sJJVKVwMblqVk/zbzrDygVYZAFzA3sux/yW4gWz54+d9/slWbAKcJ7qNVhsh5I1a+Tajeabs78O2ssDkkMrgoybnhWGIoc6poXHLtQVuxXBVWn5m9NeU7SS5rDlI1AojPtUE2rgY8orjRJU3onHMn4g2I539f+C9JxTK4j7aqA4uFtrydcP1JnPJt8ON7/3bvcMXMcO6QFK/m2McU63DxytuYBdANm0TOOmwZjpxt3dE7FYegCgGBc+8Tbu+pYlWFQXn2xEwF4Hn/SdYISB1qGKJOLm5aeaAfHa9sM0VdRhfN9Y3MHnRWFrioznEFkBIzHFQui+/trJDt58r3zDQiQDXw5zkdUqjh5YwecUL46DZnhnIiP5LQsOMti/g+OI3bGd4lHymMuFbu6Uz4srmziY/bERxWbi8888yWf8wblGwUM7U1FwdqhnJApMQG2dz3W3ftmWfvu8PdRgB1Rv3LNWmCAxs48s+eykcBtFU89r5P65DlAH0KEjQZflOq9wq2oV9kgtGFESJH3nn13ORV2nUXAMwNWLPn/6Psxm3hJTCdVgcCMQ0gLe2D/1TYqfdM4WNOmV17YY2gIrb3bwtBnicoNw+l70sUOKaete11+4VTXgsp23bqZwpOvOpbMSVdd8OM2IbLIdhj/tyycP2AKvaha+5vDu63d06owjeqmtNurrh5FTCj+sBWwPVJfBtPIIITTnFOPImb7jG4kQ+TiMLlYs7yzPdjPSZYifOaJYK5Zs/LuR+bHSea1HAPAGpkAAH0wc+seFOaqx+MGaRp2otvOnYapr50z7senvnnTcPuiC3Vr6dUnvaB3WMgU5amWke+Y48n3ScZaYlHmWIIlV4UfqGIgcPA3AZxKY7QrtvuW3V4twoA+uPK0L7vK7eYx1I+/SeAlijvJCwECSCd+hJm55b+c9PjeoRAHDAaHql8zJLGxkGvfQV28RLptkX/1X/TK3eSbfDICQVi55EHNfIYlXsbfwxm5yDnByaQkICmz2U6+3GmQCklWW3ZkYQ3k+OGUeMfwbIdwYPKEJPKlbz2xZ5lvaffWgNfV0JCagE0Rcw2/vb5lAQN/u443a6xjJIJU9N66mbBzY9+bZ/WLwZcmv+uX/meRkqiMCRjjrjZo4orvUTrzqIuozOnN1F2oGt6Tvy28ahZON5d3A1gMRxmtxwyEtOvpw+EvlnRbYTvdLEoGTUAAagRIFEz3GJTzCGbcjkymajEnsCPf8ubMq3La2UimZ0sILGmHuLLTyxEefbZ3yss9si5++ZN79RH1HlnuOPfmJ2sCnUbKtUxdis+yJP2Sb6nse2WiPXsRI8c859HCwaSc2RBLRCQip2ymFE2qoO3o5RAKDQPFESHTIEMzmFyLdN3dujfekB92zhV7wGKge6qXSiN9VQC8Yx1TLGAQXuBziERnFhKtadUCKRE4bdEAc/ZxTFD5OL6AADmOw7sJ4tTHX29scHhEVqYRhgh0zsn1BELZLa3+hbNOJZH07mOT/qoGqemHh7Wl2rCoVCjiCR2yHJoDvXh9orAVnUEdpUKgEr16vzOGYNZ5RI+F4A4DglvdDsSMDCziXC62fjN3AG7yS0+Q6E0fPhxmd754O1FdqreAxSJmG7sQok+tQoqIuPvKDqdcwxzdc5MSu92erbFEUiJIo+JAh7x7TFXq51oLt8sIt/eNfLHKecUwvAs55p66n91w8svQEOAgBK5YbS9nSkrzVCS4MxQaseSt97qdd15/3OC12bPYAdIxsLnnqiMqg2Snz20XRFWXgqY1jzxP/1PVUoiasCrUsb8rCmY1EHKLD/WE9LDp+AlCIoNAGU8Uq56z8JhLtpTDJ7KjGwgKj5WDDlkjiz/qzMj3bLoDXDJVr+T4SKdK9wBooJfkOmGacAQd0kf+YuUhC/RhGzXkHeqxcODsNovWK1rjSGqDDHztytzz0X/pIxJNo7KSGjjn6aMraz9Mbloy0GJ6YsnCYNDbDkz9bjJf/LtJ2Y6GnIoCKBL1H58+mbg6BriNwLx4zMjOkhcWW4EpXExqwSw8l2tS8YQo9N1brm/WrbXkiDJuBi81CwUjFIuGRUrIVfxv379y59mR1RwZ7ljwhT133NNeSNR+ARRMzxTuLhEoODPidnYJcuYGT3bW3jkYFQsX6NEM9CMZiMoQgoJo5mjKF3qIRJmMD0ZJuv9qpGzz/5lcIt8TqHq6Xikzvv3csZyyuSUvVP87vGh1/XzUgMoste+cPLGHe8l8/P2GQGHYRarCEniUTdMYv5EVhSA4S9lEFlMKA/MS/Wj808WjgSpGDGhccvnn6WaaJIyIGJ+g3zH6N2HVDBlqvTT8tx/zzX5j0bhE2aZ4ZGcj7v2jjjdkUj0soVP/kfApAyYiMh7MQy2GQBClNGrbUDl9H87GHRsnDI6j7NniPozjQXZI7E01ekJM84lTJhkO2f/17KsoczarfFn7zgRM3KxhaLtWYWCm+IA4GWIQKiNAgFp5xKh8YgePkbtkgmw+vn3WoyJrEKvzslzQHepKbL3u3dbUSQj6pgsbn1sWZvgnkF4ZIzBCUFnrsnPXNDbTQNxg1uS0F21W5OXlOIafDDCKiO5l25JNgMhRdg6mvZTZvnRGyVZA++lGoree2bHeLaxwJDMG4zPv9xB8Ml3Dx87In18mct4j1EnimQHZ2P2oeQNKsBZ5IRLMMc5KvKT3KXvMwfmThH2nckzBqbZTM7OEhWyprs5yh8rRlKWEtoLfCdZdNcZhVgdPq1muwNzj5r3lRMT4Omc4Cu/IGqCu3dRXLI3fyLk2XHZvmdCRIDN/UIg14VXJiGso6NMkhnyZXfs/cd9//zLS49viS/OVqoOlfBnBKsBPQwOwAGofnkY3i/+XEGM5F1JhFO6Zy97nV+onAVAOhaQGHWHf852ZqfH9hZwD57sU/UUGd2iBYQKWRXU0zkBzx0rBi8mob3f3Q1J/Lt/9MjVX/7R3okn8kfMnnIzXE5PIteUdzSKlYKoCe70/LjLna+HwQEHJvkpyEtKGXSln4BCGZFYHXVAS80L2oZ6BaF125Wn/GI2xfa/x6fSoPoTNvaJUZkdLI9UweCGKTKWNfGCr32PHTsx48RSfqeYxr/p2xMe75oTVgPOso9XHY0b4ZzXnmrX7JYWiCnLa4Imfxrhva4jdxZlu922Kjc0PipQ7N0b3/wZvgNuQfbfs5N6Xjtk3LfMRWD0sFFTXqcamuGYCS4pq5e4Wf0VxAAACCtXvOZJfhxcnvhJrSbDYqAF0KIpTCjgDD3d7CH99I8bHut7rhw5weQv4bD4lgNugB+VSgNxE4CFiBWZv7SfuEvA2+4NOnMP9nL5AF79jI0SCqcJ5Pukt6dY7eIlsv/4/c5ZRBE64rszV5UMGo1Bo2jcitBeLALgmOYBhs1HRLoDVRGjR+IiMHo6f2ELpKgn+CpXmtDnHk/oYXBfhQNC9Vtyh6+ilRkckccI4YCaFljtYQRnzAgpj20IAaUChjJTvqE7js4iL++RnNKhutVpwikNNFJZMG4EYIRLjBkf4YbcoMs0dmj2NA3gPnv0Wy9v8ki8OraKkt0JGOEpGEXFCcasXRpBvmv4VJXTLCcpNLQXhv6kAWYAaQ5JwamOElnEIzW7jC5PZ64tj0Tha692I/f4I9uc0oTuCp66uEZed/VG9J/Gd7kKUlWpqAdQgzXw8RXG0Rd+DJfzc3i7bMkKIhd8fscL/f1C9XzPHdWtfa/sg9kBv/gB66zwhGNJHeMUlQkfIS5eulkDQMac/nKMRZpE6X3G49GUZrkBHIuj7L3xHYeSKHJ3CIudZjn57MChvRjrCEtdAOD3xkXkroUityeDAQXTmWvK61TB11FyAYfsUd11YADC97kTs7OD+DzaNqhcAwBrDaR2+omKT3/3m7b2H/cWCxayu8Rn0/whueuG3L4UT6geT7T2jkY0fSYA25BM0R663TlBFY75siKBk/dXAvB8J3W4eKMr/f6/nvoGsXlql8VlFCaBvmU9C1k2Vx8t4JVqxWffvXF2ERyR2clTw7k2sF0o6uW6dfAKb6Vug0drteWNqKERlpjgkia2GaTJbdcsjwmKmKyzMzkKMjLjgju0MRH+CMDqiq+j5ftW7FDNEy/YLranKkPf46hQp9LpccvKKlowWjJxlTkW6rpZHPUAgFETLydmOudv2wD8/ra/PmjWQLJim/8Po/sT20Z4muWneYaVO6cuj+jvMrB6CMPyz75DN1A9I3WszDj7aO5PXSt9itl36+ATZW2LZXs7h2yBzij8w1ET3BmszjnIaQHz9UhCVFCGoBzoOMEMbwTQHJKa7ZkPY0PqzLuD6Bnanl7wtWIefzJMaPjl4ND9/QY3PKfmjPdueUA1Z5doKQDA1ceVxiYklEtwZuVxA/Cb6i+iy/mlfkaF3BHFeU4Fl3ia0BFT23ln/Yd3jYq8p2Yev0X2j72I3/Lbm1ctGCP0LMjnd50PPP6uBit/vXTICN/pX9gCRAXNSNQEj8QQc3bd7b8+PRxmonL5kec09fRulxfYM6ubTEnhox891Fr9ovrWu1txGCIvRyhBcFpG70+/KYpU+N1eJeXakT0cZnb2PzlrQkmQuMSGYS0AwE2NQHXN0XQRlhkHYias3It/iqbFTYaBnhV0kKV5phl2Gje7EgY9/tGn14+dXGW7Ffha8qMsR3ESM8XQqPqRiBngMPuJGj5BlhumAVbvkj7yL/jKYXYK8UYF2eG3J4U32RPC6rUpZyXTXrChA680frqOjU1DG1So2zDwgOr1V/99/5CQc68s7terKbkl9myCefct8e5ZBgBxlXNUmnpSB8AAAJ0khyWKle+wJrhEZofomJSYnGqn20SNwJIo4nzIKBcIW93p50XKlUkj6VOSNg1rchPiR97WsqTZY3EbzAGokSeIueE5Gze4+n6/DdcKEAAwI4s88Pv355c/9pVkxLpynp+g9ncm3ckGbF5TD7rANgIosz2jyuCjI/eEAocLVMfmu8/M/EkUr3i7EhQ7bNKfjoFr+CMAwDAo4JKcERAlHEc//rnw09+Z7UoDfHHZ8/tGvJbRpA745pP3cXfku+lEYJIx5LMvxN/9USJPUsBp3HPXcPgkFnnZuBQiIzwJfTzvqAo+YdQEz9mpBpf0Gv3qUjHEXWS9OZggm1x5pOD0//baGxrUiTpsPqW12gGqJDRMF/SsTlaeMI1LDpd0zUgx/v2uj3bmnFNG+0sq3208e1/A/iM9cGOlDnvfaIWz7V6/JgLgP8vFybEialYYbt07tCPr0cp/zpV+PbMjbl750Kva6Lg0ZOWUAvoP6Znjd4ypRAbqxPF7P3Pc78od8BtdRuT16D2deca8kSj8TMwEjzhukOwtuC4OhxlwqCBjTg+lzb15p5Dajnx6dEwBDalDPXRZCALktlAY2D71oLArZ1x8NF9ZVDT8yd1nRQvPE8JnjoZi6vx+ZbqKqaWS1auKnvjuO9OKyAOpBsD1UtvRweD/2ZS5DA/+rXnP7MXw+b878w//f4wcL9botX3+zPFF8jXrxv+Mom94/JQfXPj7ikE00fiOUea+KxasIgwiDAynBN+dUxbhf8rFEML8Q5Th3S1h4Tdv1QWxTmaJMTC85hHjZAAAnrvBcGtNvJIAAAAASUVORK5CYII=";

// src/control/images/forvaltning_thumb.png
var forvaltning_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////c8v/59/j//f/9+/37+fv18/Xt6+3p5+nX1dfV09XT0dPRz9HPzc/Ny83LycvJx8nHxcfFw8XDwcPBv8G/vb+9u725t7mfnp+cm5y1s7axr7Ld297Z19rk4+Xg3+G3trnr6u3b2t3X1tnDwsX9/f/7+/35+fv39/nV1dfT09XJycu/v8G9vb+7u72zs7Wjo6TKy87m5+nQ0dPd4eXMztDz9PXHyMnFxse1u8Df8f++xszd8f/X4+vBytDCxcfX7PnO4OvBz9je6fC7w8jHz9Ty+v/Y8P7d8//b8PzV6fXf8//S5vHK2+XG1t/h5unr7/G7vb7r7e7b3d7T1dbLzc7AwsPa9P/c8/3e9v+8v8D6/f7d9fvi+f/g+v/9///5+/vV19fR09PJy8vAxMC6vrr6/vr4/PiztrPFyMX9//3X2de9v72mp6bj8OG2vLWyuLH2/fXCyMGgpZ+wta/n7Obe7NvZ5ta4wbbO18zEzcLT39Dm8uPv+uzg6N7S2tDr7+rV2dTW49Lo9uTi797K0cju9ezk6+Lb6tbs+Ojq8+e8wrra4NjHzcXy+PDe5Ny1uLStsKzt8OzT1tLR1NDz/e/X39TY6dHe79fM2MfR3svCzb2/x7vN0cv1+fPI08K/wr3z9vHZ58vKzMjr/NXn99Lf78vj8dHg7s/s+dvj8s7n9dTx/9vm79jr8uD8//XY2dX+/vvQ0M3GxsP///3Dw8G+vbn8+/nc29nIx8XTzMH//Pfd1cnW0szKwrfn3tL++PDi39vw59z68+rz7OPc19HZ0Mbh2M7Oxr3r4tj47+XAurPUzsfIw764tLDKxsLPy8e0sa7MycbEwb/Bvrz8+ffp5uTV09LPzcz//f39/f37+/v5+fn39/f19fXz8/Px8fHu7u7q6urm5ubi4uLe3t7b29vZ2dnX19fV1dXT09PR0dHPz8/Nzc3Ly8vJycnHx8fFxcXDw8PBwcG/v7+9vb27u7u5ubm2traysrKvr6+rq6uhoaGUlJT///9XRU/aAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAbEpJREFUeJyNfXdgFGX6/+edndleUneTzfbNJiG0YKF4ds9DTz275jzPggoKiIICioAiRYkKioKCJ2A7sZ933t2Xs5xdQVFq2vaeZDe72WzfmZ35/RFaEL3f88/OvPvOzPuZ533fp77vkGHZ6R8XDQCASFOvHr9KdMMe4dTAWtWDvTqo3/h8aAtCjvzoKl9JZz2bvfD4EvdV/1cPYJZEqha7lly9keyoBuXbclyNVTbK/6T9OyQkxh6T+LaWsOrWxrs4iXXGvAmO8ZbesfkcKB5AWHLpfgKvTfKjGZJI8YrdLt2S1/dYH33wtf3rKY3qX4qaiTVhP2D3lH4dBzi/vSUwk71SxMIn+6p6CyDuHl3jA5H59eIoHJCjAQA2bxiiQsYXnbLe59spvmLeumOvh6bBMPvhaiZlCwn6ZrZxHcm56Wx5rm2i+luW8nTC1QPAx9j+DcAicpmBYt3EtyFb8tR+6zLZgz+tb6FRbADtb63FMH3Cuz0ZeXVDet1wYzCJcbEn3IDPmh1dQZO+6DHZqBJa82n1yNEWYKVZ1HrBUE0GW+N9i+oWjJR31GDo2se7TVJyXssHdGP3v//U88KSZ6uqhk9bLPK1KjW8BU08AJGN5nxWeGUPAoBbqnVX4qwUmHtf+w5+CgC4hpS/TxD9Xq6SS5y/CkRitUCpleTtlPQhsgUQ15xQQWbqVZ01Gjt9HNaMqBDrhROYsaijpm/2SCFHc6lmYoLCh86VTKh5aGjigLVJGkr+ePMdD8wV8qahIA8AlKjPZvbASi0G0Dsmi3WLn3yne5leCG+WMNThJzhMNUP/V2XoT9XLzK5fxEFN6CzNGux0cDCEZCWgl/l0dIWPUsv+Vh5dpOJMR4/n0/fW6nUVRgDAIpwGPPLILJSAMsXCv5zdWd4qrr9uOMV2+CBav+qClNwx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";

// src/control/images/orto_foraar_thumb.png
var orto_foraar_thumb_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD///+ZZGiFV2FvTVXk4eJ2aG6Ie4JsVmdbTVh+c36Ng42dk52VjJWtpK21rLXVzNXMxMyko6S8tL1aTmdEPFR0bIR0c3yEg4yUlJ2kpK20tL2cnJ68vL7DxM12fJRFTGVNVG1VXHRdZH1lbIRsc408RF49Q1RNVGRma3Y2S3ZGW4RcZHRGTFhsdISGi5UnO16nrLVRa5Q0Q1xkdI1VXGdEVGxUZHx2fIWMk53GzNUrS3U3S2dHW3ZXa4YbOV4bMUwoOlA0QlNnfJZcY2xsc3x8g4wsSGgkRWg5XoVBZ4w8VGxaepw8TFxsiKVEVGRMXGxUZHRcbHxkdISKoLZsfIxMVFzP2uXZ2904WXdKaIVYd5R5kKYsVnguOUKZqbaRnKWwvMZJdZg0VGwrRVlJZHhjhZ9adIc0TFw8VGREXGx4ipeKnqyftcWElJ8bPVJTbHx7nLBifIxrhZYhMjzr8PM0VGQ8XGxchJk8TFREVFxMXGRUZGxcbHRkdHxsfIR0hIxLdYksVmjb5ek0XWw6ZHSDm6SZpKgyTFRjfIQpQklEXWRTbXR7lJuptLe6xMc8XGQ4VFs3R0trhIo0XGRLZGlbdHlVW1zJ1dcsVFrBzM1MdHRTbGxjfHxEVFR0jIxUZGRcbGxkdHR0hIR8jIyElJSMnJxOVFRsdHRGS0t0fHx8hIReZGSirKyEjIyUnJyMlJSzvLxmampDXVxsfXxMXlybtLFMdGw7VExjfHRDXFODnJNTbGJbdGo8RkJzjIB8lIhsfnRMXVNcbGKMnJJHVEtXZFt8jIGirKR4hHpodmqzvLSJlIqbpJuUnZSrtKvDzMO7xLvL1Mt0fXOEjIJVXFLe49l0d2ukpZuMjILMzMOEhIHX19RnZl1+fXOWlYutrKLV1MuenJO2tKvGxLu+vLPp59/VzMiOhICWjIjqzcO1rKnMqJ+vo6DHjoKrkYyonJrFem+qfXl+c3LIu7q+tLPOxMN+fHyWlJTMzMzExMS0tLSsrKyMjIx0dHT///8CMPxvAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAjrdJREFUeJw0vGd4XNX1vr32OWd6731Goxlp1IslW25g3HsHk0ILHWxMhxAIHQKBQMAGEkjov4Tm3jA2NsWWu9W7RqOpmt77nPJ+yP/9tD/va13PWs+997M3+hzscxk4QNWXRRnv1fJgaw0ozuu+b65t4I/kR88DoNUtICIzGXydjyATI1MDNCO7V526/Zqar6G8DNtzAzQAv5pjc14D/xKFLNK8gB+sTOpJkDGIFGeEKMPm5Jkop8gK0UK2ZtYhdlQRzX5vJBY0TsP9DObaXf38EIR//nmUAelE1SIXQKEuVuceM5NDdJYmq6eqQTH3ugLv16+KpM/Wfq2g3b67/qfb4FBFWGqlaWm5LXxoA4k+VVXVH1xfZvcKRtf5bliOLtyrR7F/a6vjLU3xzL9TzEoey8qfzsPzgR7g5iA7NvnD89bmQ4ccAf+cc2iBK8A4n9Wz5CVe2cqaqoYReyQhLoTZZZqmMBYZK0CViOFGeWRhtMA3xSdbHrn8JgiStWlwxpvbO6Vsq+qxv54nc/iXvmEAKS4NmbyLjy1KXBxa3sMp3LY/q82Igp3R37WyoqO9mUBV67l1hKUBAOCYcWp9qMKrJNbDNDAqLCKLl1ZNfXqkbdk65uqOutqbGc/4edqSqGHlh6NrtwrdFcArPJnhnakpig/j0+C2M4Krbgt7tfb4POgOLJBk6QDEc7EqvSXj77P3IihFuUUe5q9Me7z9SrmLgThJJiDPyo2OWx+erIC3emlG2YjJ+dkIizEvPKtYr4VZU2kAQOAwuMzUanfgts1VdpP9XAUKLHw2vh5YJcE4itvsMBYLoWM2GAbzVBsOXC5WPznNkNbLWDKROHQUWq+fOn0ZygDwQXUjm5acw7A8tJi1ka0dUgC2BbvLWtRRQdSuydP+ycL4NJo6Ipmbpkg4pp7zr+8i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";

// src/control/images/natur_friluftskort.png
var natur_friluftskort_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////S+rGz0v7X0dKrpqfTzc/17fHKxsikm6Kfmp6XkpbX0tbj3eLs5evn4ObDvMPb1dualprf2t/++v769fuSjJSvrbSdnaOamp+Skpelparl5evh4ef19fra2t/6+v7V1tuVlprR0ta70/23zfe20v6yx+i5xtvn7PS20vqyy++60fSy0v6y0fqtw+HI3vu21v65z+q9xtGu1P6y1v631vqvwdax1vq01PW82PTCz9zM1+Gw2v7J3OytucGOkZPY4uiWmpvu8vPa3t+Rlpb5/v71+vrR0tKZn56mrKvV29rR19bl6+rh5+bL1dOeo6LGzcu4wb2ttK/L8dPD78uVmpZrynrh5+J8xIW63b7C4cbL6s6SxpbC7sWRl5Gan5rN0831+/Xa39rS1tLMzcy0tbSen56Njo2mz6OKx4K0zLDFy8SlraPe4t3W2tWRvoSXrpDA1Lq1vLPN+7vm6+TS3s3Z6NL6/vigvpCrv6DO/bLS/rbU/LvO4MLi9Nbu9OqDhoHQ/q7N+q3S/rLS+rbU9LzS+rLW/rbc+sTR/qrS+q7W/rLW6cXR/abW+bbT7LvS+qrW/q7W+rLa/rbc/busravW/qrW+q7a/rLa+rbT8LPW+qrQ8qbL66HU9Kva+rLf/rbO56/C4Zja+67e/rLa9bPJ4qbb8rvm/Mjf+bfb9a3f+bLb+KO604vU7KXE1aTM45uPk4fo/Lfn7NzF15Hb7Ka8xKP2+ezX3b3i493O0rPr7OW+xoTS1MSsraXDxLz9/vOlppf4+N/c3M3b29LMzMS8vLW0tK2fn5mbm5WWlpHm5uHe3tnb29b+/vrW1tK/v736+vns7OukpKOSkpG3tXXU0824tKLx7d2rqaC3rpPn49fz8evHwbK9uK2bkYPk2czUyLrb0cbb1Mzk3dXMxb6zrqnItaPSwbHTzMbgzb7r5eKalpTb1tTm4d/++vmgmpn79fTf2tr+/v709PTm5ubi4uLe3t7a2trW1tbExMS6urqampqWlpb///+maPEqAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAfmBJREFUeJx0fXd8FGX+//uZmZ3ZMlvSE9J7slEQlFPvzn7qqQjYKxZsJAFiJcYoRjDGgC1AAjYsnIoNBPGsX9vZUZCSTUIKIYX0bJvdKTszz++PAHqnv88/MPvKzD7v/Xw+z6c/Q17y6IqDjFQ8QIvs4YE61KMWK5bjCDVVAcCK5TUNANAIZ0J4QhWv4PSMXdHCTYoYi4sju+qP/jVW2lSbI3EcI8uBRqAa9RAVtQytcrKhj8Yjb7BtKTFLDabSYBc/9EbO5wUlbdy0rpvsZvyq+Z+f25DSf5EiXWG5L4XG7FG+SzhpwIHEf/QeiHWcEqQgFRtlC5wIw2y768PyljbBRRTHAfPf0UvfaySPcjSVOu2q//CJ6vBY3YrlNbapVQAAqusB1GLF8kZnP0QOOfzkxPDwmvAjL2X+sMGtiMRBmHDVURyN0GnStJjPePjIB/WobSEWCIcDDY3VK0HdxtCq83Na9hWR9EsMR7/5iXNiDv2KucgAO7R/fE+iMnpt8ebeEjqnMQ6H7QojRv6+e26Oq248MXGGPXBV3BPuT4tSSbjtedu/Ip8FS2huL6selD+ZFJkIs/yB2olox64ATswpnhb3GNeU6kZNjVxdXV1dXR2oAVALLIcTgLVa5QwTcXcH2ZcQaP+bjqCeSMJVxzhihWGHHkoix1iEmpjmsUhOAE3MQ3YOpyV8s46eBwzaF7NMol2NJqdgthsM2UXhYDlR/rX927yl/IV93UWn0Iwm+eaZatu7cslJo28Uj1WcIy1YdxtB0sMN13a68o4z0KEoh/BFLHwQLYQB8IiCVKcjHkqU56LDQauYMCxBAkRM4UATLLFhO8MhhxuIWG9QfOcmBD7ZS6OJFk9wglYfW3Zj9VPZ8qgceew3jjRZUgLjqK6vbZStnD1Sll5kMsQEEOOWGM6b0AI6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";

// src/control/images/kommunikation.png
var kommunikation_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAADAFBMVEUAAAD////c8v/Nzc3I8KD85uesm5z98fKyoKKdk5S7p6q2oqarlZykjZXj19utnKKzpaqynqaYh49QTk+klJ22rrTMxczr5Ov++v6clZ3Y0tnOys/SzdV8e3339PtlZGf6+P6PjZTR0dmEhIbf3+G8vL2mpqecnJ1qbIJ3eZGQkqmFhpWkpriChqO1uNCsr8Ocnq7IydCTlZ2Snb3Cyd2tr7Xg5O21t7vFx8vW2Nzm6/SbrMfK1unv9PzW3urY4u+mweHc5/OwzuxpuO6JyfXO0dPm6evD5/3Z8P3e8v6q3/vn9/71+vzf9v7a9v76/v7S1tbKzs7x8vLQ3dLN+86a4ZuV2JWj5qOh2aG05LTK8sre997s+uz0/PT6/vqNtIzH8sWcvprG58TX7NXJ0cjj7+HH28LB0bnP2cq0v63G8qLK9qHO+qWy0pOQon+HlnmxwqHV4snF8ZnQ/qK85ZLS/qax1Y3K8qLO9abD6J3I7qK94Zm32JbT9q/L7Kirx46wzZOkvYrF4qiasITY9bvQ67S/1ajM37l/inTS+qLW/qbO9qLS+qbW/qrV6b+NlITb/qvKy8OpqZ3k5Nfb29X+/vj+9gL79kb9+H/9/O7q1AXOvBS3qCOqoDqUizmgmVbk24l2ck6enZO9vLT59dyysKPPzsn+9cx1dHDX1tKoo5H867z95anDuqPd1sXy2qXu1qLcxpbu16bn0qPz4LXm1rPm2r7az7aclYbt48zt6eD43aTozpvRuo6KfmWgk3rYx6aOhXPy1Jy+pnvJsYarmXmyooXCsZPNxba8qYmzp5Tpx5PfvIyomYeaiHTt0L+um5KmiX3r08m0rqy1kIm2p6WrpKO7tLOVjIuwp6aGeXi+rKvayciahIOjjo20nJyslZW7pKS2oqKkk5OcjIyPgICUhobv29vi0NClnJzNxMTBubnX0NDEvr7OysqjoqL+/v76+vr29vbs7Ozk5OTc3NzW1tbS0tLOzs7KysrExMS0tLSsrKyUlJSMjIz////e5Z6pAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAboBJREFUeJyFfXd8FVX6/nPOtNtLctNoCSk3hJBQxC4iWBFRWSvqCrYlrq5uvOtXY8G+sew1q65r2F0VK/aGLiv2hqJ0SEJuEggtpN86t0w55/dHQgmgv/PJH8lk5sw8877vOW8fcssoPZl4rpYCqscRjzbit8btzNH/7C2+m095tmd+0ban+56u8VninrpDT6l1DDB78JADgeAdjwEIiFLkmMsmtjKTV2HSisSU9ogBV0yeuoXbkTSU6AlL7I9/OcBNMdt+XD+0VWMY99LMhK+4afv9ZxEAntLNyajoR6g0pVNuiQCexJTtiStfPsZ40mZQFk8L9OGM6FNLla6o/TdxgKnMU0s76Tcb+fL891KAVdC1ETgCDUq29VAc8N0n1gAIGnba+uC8ignSrK1NbwCr+2XpWHYuWXOZHbCBnEgfUAfTAInY8en2bXK+XZS75YkrTE5ofoQQwqNwFEz0twChUrOyEoTwiMb0qtWysVrPFIv2KOy2VE46LYThyqj1/SOe4rDhE5W9svX+affhts6n1wsSaJrREWeoN+6z5R56oCbi7AUABIHFtqT324qmzvG6ap/XRH9qMVbNfOF1J5Co+uVB1N3f0mGlQAY8yteScxyvRDa4EhInrldWhTi8KtQugfhDZnkPyfqMc3jTpbJ5UncVROdJs8UggMU25EZ9UtEPLkfEFwB+FUuvY9+4ffYSG2c5Rdbswb/XWsSekUQsHBT0ESSyxhP8wClZr0akzXGzYrMdKxJcQBqRUgIkbRH0m3JzZiprE6UeyrXMOOMt4sD8y6pLQ0akX3LnAZO3hmxMCAECI4OMgKDS0pJ+xlpx69rGe1aLALAUQM34nV02Mliw2w5WmzviWQ6OlOJkdK1iXH5pLKe27emAb49vJB8FBm1J38hLiMs9PNsto6XdFzHZXrwF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";

// src/control/LayerSwitcher.js
var LayerSwitcher = class extends Control_default {
  constructor(opt) {
    const options = opt || {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    this.visible = typeof options.visible === "undefined" ? true : options.visible;
    const cssClassName = options.className !== void 0 ? options.className : "ol-layer-switcher ol-unselectable ol-control";
    const label = options.label !== void 0 ? options.label : "Skift kort";
    this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
    this.button_ = document.createElement("button");
    const tipLabel = options.tipLabel ? options.tipLabel : "Skift kort";
    this.button_.setAttribute("type", "button");
    this.button_.id = "layer-switcher-button";
    this.button_.title = tipLabel;
    this.button_.appendChild(this.labelNode_);
    const _this = this;
    this.button_.onclick = function(e) {
      e.preventDefault();
      _this.toggleShow();
    };
    this.panel1_ = document.createElement("div");
    this.panel1_.className = "container1";
    this.panel2_ = document.createElement("div");
    this.panel2_.className = "container2";
    this.panel1_.appendChild(this.panel2_);
    const element = this.element;
    element.className = cssClassName;
    if (this.visible) {
      element.appendChild(this.button_);
      element.appendChild(this.panel1_);
    }
  }
  setMap(map) {
    super.setMap(map);
    if (map) {
      this.renderBackgrounds();
    }
  }
  renderBackgrounds() {
    let baseLayers = null;
    if (!this.getMap()) {
      return;
    }
    const lyrs = this.getMap().getLayers().getArray();
    for (let i = 0, l; i < lyrs.length; i++) {
      l = lyrs[i];
      if (l.get("title") === "Base maps") {
        baseLayers = l;
      }
    }
    const this_ = this;
    while (this.panel2_.firstChild) {
      this.panel2_.removeChild(this.panel2_.firstChild);
    }
    baseLayers.getLayers().forEach(function(e) {
      const div = document.createElement("div");
      const image = document.createElement("img");
      const label = document.createElement("label");
      div.className = "wrapper";
      image.className = "image";
      label.className = e.get("color");
      image.appendChild(label);
      div.appendChild(image);
      div.appendChild(label);
      this_.panel2_.appendChild(div);
      if (e.get("visible")) {
        image.classList.add("selected");
      }
      e.image = image;
      label.innerHTML = e.get("title");
      const name = e.get("name");
      let img = dtk_skaermkort_thumb_default;
      if (name === "dtk_skaermkort_daempet") {
        img = dtk_skaermkort_daempet_thumb_default;
      } else if (name === "forvaltning") {
        img = forvaltning_thumb_default;
      } else if (name === "orto_foraar") {
        img = orto_foraar_thumb_default;
      } else if (name === "natur_friluftskort") {
        img = natur_friluftskort_default;
      } else if (name === "kommunikation") {
        img = kommunikation_default;
      }
      image.src = img;
      image.onclick = function(f) {
        f = f || window.event;
        this_.toggleBackground(e.get("name"));
        f.preventDefault();
      };
      label.onclick = image.onclick;
    });
  }
  toggleBackground(background) {
    let baseLayers = null;
    const lyrs = this.getMap().getLayers().getArray();
    for (let i = 0, l; i < lyrs.length; i++) {
      l = lyrs[i];
      if (l.get("title") === "Base maps") {
        baseLayers = l;
      }
    }
    baseLayers.get("layers").getArray().forEach(function(lyr, idx, a) {
      lyr.setVisible(lyr.get("name") === background);
      if (lyr.image.classList.contains("selected")) {
        lyr.image.classList.remove("selected");
      }
      if (lyr.get("name") === background) {
        lyr.image.classList.add("selected");
      }
    });
  }
  setVisible(lyr, visible) {
    const map = this.getMap();
    lyr.setVisible(visible);
    if (visible && lyr.get("type") === "base") {
      LayerSwitcher.forEachRecursive(map, function(l, idx, a) {
        if (l !== lyr && l.get("type") === "base") {
          l.setVisible(false);
        }
      });
    }
  }
  forEachRecursive(lyr, fn) {
    lyr.getLayers().forEach(function(lyr2, idx, a) {
      fn(lyr2, idx, a);
      if (lyr2.getLayers) {
        this.forEachRecursive(lyr2, fn);
      }
    });
  }
  toggleShow(e) {
    if (this.panel1_.classList.contains("expanded")) {
      this.panel1_.classList.remove("expanded");
      this.button_.classList.remove("expanded");
    } else {
      this.panel1_.classList.add("expanded");
      this.button_.classList.add("expanded");
    }
  }
};

// node_modules/ol/source/Cluster.js
var Cluster = class extends Vector_default {
  constructor(options) {
    super({
      attributions: options.attributions,
      wrapX: options.wrapX
    });
    this.resolution = void 0;
    this.distance = options.distance !== void 0 ? options.distance : 20;
    this.minDistance = options.minDistance || 0;
    this.interpolationRatio = 0;
    this.features = [];
    this.geometryFunction = options.geometryFunction || function(feature) {
      const geometry = feature.getGeometry();
      assert(!geometry || geometry.getType() === "Point", 10);
      return geometry;
    };
    this.createCustomCluster_ = options.createCluster;
    this.source = null;
    this.boundRefresh_ = this.refresh.bind(this);
    this.updateDistance(this.distance, this.minDistance);
    this.setSource(options.source || null);
  }
  clear(fast) {
    this.features.length = 0;
    super.clear(fast);
  }
  getDistance() {
    return this.distance;
  }
  getSource() {
    return this.source;
  }
  loadFeatures(extent, resolution, projection) {
    this.source.loadFeatures(extent, resolution, projection);
    if (resolution !== this.resolution) {
      this.resolution = resolution;
      this.refresh();
    }
  }
  setDistance(distance) {
    this.updateDistance(distance, this.minDistance);
  }
  setMinDistance(minDistance) {
    this.updateDistance(this.distance, minDistance);
  }
  getMinDistance() {
    return this.minDistance;
  }
  setSource(source) {
    if (this.source) {
      this.source.removeEventListener(EventType_default.CHANGE, this.boundRefresh_);
    }
    this.source = source;
    if (source) {
      source.addEventListener(EventType_default.CHANGE, this.boundRefresh_);
    }
    this.refresh();
  }
  refresh() {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  }
  updateDistance(distance, minDistance) {
    const ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
    const changed = distance !== this.distance || this.interpolationRatio !== ratio;
    this.distance = distance;
    this.minDistance = minDistance;
    this.interpolationRatio = ratio;
    if (changed) {
      this.refresh();
    }
  }
  cluster() {
    if (this.resolution === void 0 || !this.source) {
      return;
    }
    const extent = createEmpty();
    const mapDistance = this.distance * this.resolution;
    const features = this.source.getFeatures();
    const clustered = {};
    for (let i = 0, ii = features.length; i < ii; i++) {
      const feature = features[i];
      if (!(getUid(feature) in clustered)) {
        const geometry = this.geometryFunction(feature);
        if (geometry) {
          const coordinates2 = geometry.getCoordinates();
          createOrUpdateFromCoordinate(coordinates2, extent);
          buffer(extent, mapDistance, extent);
          const neighbors = this.source.getFeaturesInExtent(extent).filter(function(neighbor) {
            const uid = getUid(neighbor);
            if (uid in clustered) {
              return false;
            }
            clustered[uid] = true;
            return true;
          });
          this.features.push(this.createCluster(neighbors, extent));
        }
      }
    }
  }
  createCluster(features, extent) {
    const centroid2 = [0, 0];
    for (let i = features.length - 1; i >= 0; --i) {
      const geometry2 = this.geometryFunction(features[i]);
      if (geometry2) {
        add3(centroid2, geometry2.getCoordinates());
      } else {
        features.splice(i, 1);
      }
    }
    scale(centroid2, 1 / features.length);
    const searchCenter = getCenter(extent);
    const ratio = this.interpolationRatio;
    const geometry = new Point_default([
      centroid2[0] * (1 - ratio) + searchCenter[0] * ratio,
      centroid2[1] * (1 - ratio) + searchCenter[1] * ratio
    ]);
    if (this.createCustomCluster_) {
      return this.createCustomCluster_(geometry, features);
    }
    return new Feature_default({
      geometry,
      features
    });
  }
};
var Cluster_default = Cluster;

// src/control/images/pin.png
var pin_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAMAAACjKNoqAAAACXBIWXMAAAAcAAAAHAAPAbmPAAAA0lBMVEUAAADmSzHqQzXePzEAAAAAAADqRzzePzEAAADePzHqQzXePzHePzHqQzXePzHmQzUAAADePzHqRzzaQy3ePzXqQznqPz/qRzwAAADqRznqQznvRznaPzHqQzXqQzXqQzXePzHeQzHqRzzePzHaQzHePzHWPDHaPzHqSzzePzXePzHmQzXKOS3ePzHqQzXqQzXaPzXePzHmQzW+OSnePzXePzHmQzXqQzXqSzzqSz/qTz/GKSGyHRnqT0OXCQnaOS3SNSnqU0O+JR3GLSXOMSW2IRnQDRqUAAAANnRSTlMACdaUGAmXsgg1ZMbqgO/vEM7WHVNDDuISR0tHT0NLvlMd3r4lLbDGoIBcxpew3nA5P758bGAX/DEaAAABEElEQVR42u39B3bEIAxEAQgb8PYt6enp6ekCvH3L/a8UEO4+w+Aivmf8nsQFgMRO5Ejr68fjfci0N5oup3FsHwfnCWJdszSKZKZGMoJdE6tMsZGOnekCs2bdsuGgxKz3ncGR0lTP1+M5FVp9gPTfxzOrla8vIPC+GWlBmwCQ3msPJ7TBBI7LcFiMb5J46H++cmzr6wiaPq8Wk4n3KbwEuFEVDW2bqTUV7rrmwxLFiKa00ynCzpUf6GnBik/p5N8yiu3sOG57Kezd5Yf0m1gxzBkw36wKWAHCJ1nxD0qKHGyXGfWFzxXoRhhUGbSUCmuwifhVg41+v1GH3y812BjcPxxWqeA/r1zUnJwP6nkhMvYPs65RdNkbMm4AAAAASUVORK5CYII=";

// src/control/markers/CreateMarkers.js
function createStyleFunction2(icon) {
  const styleCache = {};
  return (feature) => {
    const size = feature.get("features")?.length;
    if (size === 1) {
      return new Style_default({
        image: new Icon_default({
          anchor: [0.5, 1],
          anchorXUnits: "fraction",
          anchorYUnits: "fraction",
          src: icon
        })
      });
    }
    let style = styleCache[size];
    if (!style) {
      style = new Style_default({
        image: new Circle_default({
          radius: 10,
          stroke: new Stroke_default({
            color: "#fff"
          }),
          fill: new Fill_default({
            color: "#C84A38"
          })
        }),
        text: new Text_default({
          text: size.toString(),
          fill: new Fill_default({
            color: "#fff"
          })
        })
      });
      styleCache[size] = style;
    }
    return style;
  };
}
async function createFeature(marker) {
  const dawsUrl = "https://dawa.aws.dk/adresser?format=json&struktur=mini&q=";
  const feature = new Feature_default();
  for (let key in marker) {
    feature.set(key, marker[key]);
  }
  if (marker.lon && marker.lat) {
    feature.set("geometry", new Point_default(fromLonLat([marker.lon, marker.lat], "EPSG:25832")));
  } else if (marker.address) {
    const response = await fetch(`${dawsUrl}${marker.address}`);
    const data = await response.json();
    feature.set("geometry", new Point_default(fromLonLat([data[0].x, data[0].y], "EPSG:25832")));
  }
  return feature;
}
async function createFeatures(markers, icons) {
  let featureGroups = { default: [] };
  Object.keys(icons).forEach((i) => {
    featureGroups[i] = [];
  });
  for (const marker of markers) {
    const newFeature = await createFeature(marker);
    if (featureGroups[marker.type]) {
      featureGroups[marker.type].push(newFeature);
    } else {
      featureGroups.default.push(newFeature);
    }
  }
  return featureGroups;
}
function createLayer(features, iconUrl) {
  const styleFunction = createStyleFunction2(iconUrl);
  const vectorSource = new Vector_default({
    features
  });
  const clusterSource = new Cluster_default({
    source: vectorSource
  });
  const vectorLayer = new Vector_default2({
    source: clusterSource,
    style: styleFunction
  });
  return vectorLayer;
}
async function CreateMarkers_default(markerArray, icons) {
  const featuresByType = await createFeatures(markerArray, icons);
  let layers = [];
  for (const [key, value] of Object.entries(featuresByType)) {
    const iconUrl = icons[key] ? icons[key] : pin_default;
    layers.push(createLayer(value, iconUrl));
  }
  return layers;
}

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
var BaseTileLayer = class extends Layer_default {
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  getPreload() {
    return this.get(TileProperty_default.PRELOAD);
  }
  setPreload(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  }
  getUseInterimTilesOnError() {
    return this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR);
  }
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  getData(pixel) {
    return super.getData(pixel);
  }
};
var BaseTile_default = BaseTileLayer;

// node_modules/ol/Tile.js
var Tile = class extends Target_default {
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.interimTile = null;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  changed() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  release() {
    if (this.state === TileState_default.ERROR) {
      this.setState(TileState_default.EMPTY);
    }
  }
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  getInterimTile() {
    if (!this.interimTile) {
      return this;
    }
    let tile = this.interimTile;
    do {
      if (tile.getState() == TileState_default.LOADED) {
        this.transition_ = 0;
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);
    return this;
  }
  refreshInterimChain() {
    if (!this.interimTile) {
      return;
    }
    let tile = this.interimTile;
    let prev = this;
    do {
      if (tile.getState() == TileState_default.LOADED) {
        tile.interimTile = null;
        break;
      } else if (tile.getState() == TileState_default.LOADING) {
        prev = tile;
      } else if (tile.getState() == TileState_default.IDLE) {
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  }
  getTileCoord() {
    return this.tileCoord;
  }
  getState() {
    return this.state;
  }
  setState(state) {
    if (this.state !== TileState_default.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  load() {
    abstract();
  }
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
};
var Tile_default = Tile;

// node_modules/ol/ImageTile.js
var ImageTile = class extends Tile_default {
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  getImage() {
    return this.image_;
  }
  setImage(element) {
    this.image_ = element;
    this.state = TileState_default.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  handleImageError_() {
    this.state = TileState_default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  handleImageLoad_() {
    const image = this.image_;
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState_default.LOADED;
    } else {
      this.state = TileState_default.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  load() {
    if (this.state == TileState_default.ERROR) {
      this.state = TileState_default.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
};
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile_default = ImageTile;

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD = 0.5;

// node_modules/ol/reproj/Triangulation.js
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = class {
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = this.sourceWorldWidth_;
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  getTriangles() {
    return this.triangles_;
  }
};
var Triangulation_default = Triangulation;

// node_modules/ol/reproj.js
var brokenDiagonalRendering_;
var canvasPool2 = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool2);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool2.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool2
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  const canvasWidthInUnits = getWidth(sourceDataExtent);
  const canvasHeightInUnits = getHeight(sourceDataExtent);
  const stitchContext = createCanvasContext2D(
    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution),
    canvasPool2
  );
  if (!interpolate) {
    stitchContext.imageSmoothingEnabled = false;
  }
  const stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function(src, i, arr) {
    const xPos = src.extent[0] - sourceDataExtent[0];
    const yPos = -(src.extent[3] - sourceDataExtent[3]);
    const srcWidth = getWidth(src.extent);
    const srcHeight = getHeight(src.extent);
    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(
        src.image,
        gutter,
        gutter,
        src.image.width - 2 * gutter,
        src.image.height - 2 * gutter,
        xPos * stitchScale,
        yPos * stitchScale,
        srcWidth * stitchScale,
        srcHeight * stitchScale
      );
    }
  });
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    context.scale(
      sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio
    );
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });
  releaseCanvas(stitchContext);
  canvasPool2.push(stitchContext.canvas);
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}

// node_modules/ol/reproj/Tile.js
var ReprojTile = class extends Tile_default {
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, interpolate) {
    super(tileCoord, TileState_default.IDLE, { interpolate: !!interpolate });
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent,
        this.sourceZ_
      );
      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  getImage() {
    return this.canvas_;
  }
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((tile) => {
      if (tile && tile.getState() == TileState_default.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState_default.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState_default.LOADED;
    }
    this.changed();
  }
  load() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach((tile) => {
        const state = tile.getState();
        if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(
            tile,
            EventType_default.CHANGE,
            function(e) {
              const state2 = tile.getState();
              if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
                unlistenByKey(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            },
            this
          );
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function(tile, i, arr) {
          const state = tile.getState();
          if (state == TileState_default.IDLE) {
            tile.load();
          }
        });
      }
    }
  }
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool2.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
};
var Tile_default2 = ReprojTile;

// node_modules/ol/renderer/canvas/TileLayer.js
var CanvasTileLayerRenderer = class extends Layer_default3 {
  constructor(tileLayer) {
    super(tileLayer);
    this.extentChanged = true;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.newTiles_ = false;
    this.tmpExtent = createEmpty();
    this.tmpTileRange_ = new TileRange_default(0, 0, 0, 0);
  }
  isDrawableTile(tile) {
    const tileLayer = this.getLayer();
    const tileState = tile.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  }
  getTile(z, x, y, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == TileState_default.ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  }
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = source.getTile(
        z,
        tileCoord[1],
        tileCoord[2],
        pixelRatio,
        projection
      );
      if (!(tile instanceof ImageTile_default || tile instanceof Tile_default2) || tile instanceof Tile_default2 && tile.getState() === TileState_default.EMPTY) {
        return null;
      }
      if (tile.getState() !== TileState_default.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(tile.getImage(), col + gutter, row + gutter);
    }
    return null;
  }
  loadedTileCallback(tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return super.loadedTileCallback(tiles, zoom, tile);
    }
    return false;
  }
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    let extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      extent = getIntersection(
        extent,
        fromUserExtent(layerState.extent, projection)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    const findLoadedTiles = this.createLoadedTileFinder(
      tileSource,
      projection,
      tilesToDrawByZ
    );
    const tmpExtent2 = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation ? getRotatedViewport(
      viewState.center,
      resolution,
      rotation,
      frameState.size
    ) : void 0;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
          continue;
        }
        const tile = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile)) {
          const uid = getUid(this);
          if (tile.getState() == TileState_default.LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            let inTransition = tile.inTransition(uid);
            if (inTransition && layerState.opacity !== 1) {
              tile.endTransition(uid);
              inTransition = false;
            }
            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            continue;
          }
        }
        const childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord,
          tmpTileRange,
          tmpExtent2
        );
        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord,
            findLoadedTiles,
            tmpTileRange,
            tmpExtent2
          );
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    compose(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    const canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(ascending);
    let clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile = tilesToDraw[tileCoordKey];
        const tileCoord = tile.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = z === currentZ;
        const inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
              if (z !== currentZ && currentZ < clipZs[i2]) {
                const clip = clips[i2];
                if (intersects(
                  [x, y, x + w, y + h],
                  [clip[0], clip[3], clip[4], clip[7]]
                )) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(
          tile,
          frameState,
          x,
          y,
          w,
          h,
          tileGutter,
          transition
        );
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile);
        } else {
          this.renderedTiles.push(tile);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(
      frameState,
      tileSource,
      tileGrid,
      pixelRatio,
      projection,
      extent,
      z,
      tileLayer.getPreload()
    );
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  }
  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
    const image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  getTileImage(tile) {
    return tile.getImage();
  }
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      const postRenderFunction = function(tileSource2, map, frameState2) {
        const tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(
            frameState2.viewState.projection,
            frameState2.usedTiles[tileSourceKey]
          );
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(
        postRenderFunction
      );
    }
  }
  updateUsedTiles(usedTiles, tileSource, tile) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }
  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation ? getRotatedViewport(
      frameState.viewState.center,
      frameState.viewState.resolution,
      rotation,
      frameState.size
    ) : void 0;
    let tileCount = 0;
    let tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == TileState_default.IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([
                  tile,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (tileCallback !== void 0) {
              tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
};
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/Tile.js
var TileLayer = class extends BaseTile_default {
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new TileLayer_default(this);
  }
};
var Tile_default3 = TileLayer;

// node_modules/ol/structs/LRUCache.js
var LRUCache = class {
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  get(key, options) {
    const entry = this.entries_[key];
    assert(entry !== void 0, 15);
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  remove(key) {
    const entry = this.entries_[key];
    assert(entry !== void 0, 15);
    if (entry === this.newest_) {
      this.newest_ = entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  getCount() {
    return this.count_;
  }
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  peekLast() {
    return this.oldest_.value_;
  }
  peekLastKey() {
    return this.oldest_.key_;
  }
  peekFirstKey() {
    return this.newest_.key_;
  }
  peek(key) {
    if (!this.containsKey(key)) {
      return void 0;
    }
    return this.entries_[key].value_;
  }
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  set(key, value) {
    assert(!(key in this.entries_), 16);
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  setSize(size) {
    this.highWaterMark = size;
  }
};
var LRUCache_default = LRUCache;

// node_modules/ol/TileCache.js
var TileCache = class extends LRUCache_default {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile = this.peekLast();
      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = fromKey(key);
    const z = tileCoord[0];
    this.forEach((tile) => {
      if (tile.tileCoord[0] !== z) {
        this.remove(getKey2(tile.tileCoord));
        tile.release();
      }
    });
  }
};
var TileCache_default = TileCache;

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  TILELOADSTART: "tileloadstart",
  TILELOADEND: "tileloadend",
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/tilegrid.js
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX3(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}

// node_modules/ol/source/Tile.js
var TileSource = class extends Source_default {
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tileCache = new TileCache_default(options.cacheSize || 0);
    this.tmpSize = [0, 0];
    this.key_ = options.key || "";
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    let covered = true;
    let tile, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = getKeyZXY(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = tileCache.get(tileCoordKey);
          loaded = tile.getState() === TileState_default.LOADED;
          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  getGutterForProjection(projection) {
    return 0;
  }
  getKey() {
    return this.key_;
  }
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  getOpaque(projection) {
    return this.opaque_;
  }
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  getTileGrid() {
    return this.tileGrid;
  }
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    assert(
      sourceProjection === null || equivalent(sourceProjection, projection),
      68
    );
    return this.tileCache;
  }
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale3(tileSize, tilePixelRatio, this.tmpSize);
  }
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX3(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear();
    super.refresh();
  }
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }
  useTile(z, x, y, projection) {
  }
};
var TileSourceEvent = class extends Event_default {
  constructor(type, tile) {
    super(type);
    this.tile = tile;
  }
};
var Tile_default4 = TileSource;

// node_modules/ol/tileurlfunction.js
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return void 0;
    }
    return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
      const z = tileCoord[0];
      const range = tileGrid.getFullTileRange(z);
      assert(range, 55);
      const y = range.getHeight() - tileCoord[2] - 1;
      return y.toString();
    });
  };
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return void 0;
    }
    const h = hash(tileCoord);
    const index = modulo(h, tileUrlFunctions.length);
    return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
  };
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

// node_modules/ol/source/UrlTile.js
var UrlTile = class extends Tile_default4 {
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  getUrls() {
    return this.urls;
  }
  handleTileChange(event) {
    const tile = event.target;
    const uid = getUid(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile));
    }
  }
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
  useTile(z, x, y) {
    const tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
};
var UrlTile_default = UrlTile;

// node_modules/ol/source/TileImage.js
var TileImage = class extends UrlTile_default {
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
    this.tileCacheForProjection = {};
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
    return false;
  }
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(
      this.tileCache == usedTileCache ? usedTiles : {}
    );
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  getGutter() {
    return 0;
  }
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  getOpaque(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return false;
    }
    return super.getOpaque(projection);
  }
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new TileCache_default(
        this.tileCache.highWaterMark
      );
    }
    return this.tileCacheForProjection[projKey];
  }
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
    return tile;
  }
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const cache2 = this.getTileCacheForProjection(projection);
    const tileCoord = [z, x, y];
    let tile;
    const tileCoordKey = getKey2(tileCoord);
    if (cache2.containsKey(tileCoordKey)) {
      tile = cache2.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const newTile = new Tile_default2(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.getInterpolate()
    );
    newTile.key = key;
    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      cache2.replace(tileCoordKey, newTile);
    } else {
      cache2.set(tileCoordKey, newTile);
    }
    return newTile;
  }
  getTileInternal(z, x, y, pixelRatio, projection) {
    let tile = null;
    const tileCoordKey = getKeyZXY(z, x, y);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        const interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);
        if (interimTile.getState() == TileState_default.IDLE) {
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  }
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }
  setTileGridForProjection(projection, tilegrid) {
    const proj = get3(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
};
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage_default = TileImage;

// node_modules/ol/uri.js
function appendParams(uri, params) {
  const keyParams = [];
  Object.keys(params).forEach(function(k) {
    if (params[k] !== null && params[k] !== void 0) {
      keyParams.push(k + "=" + encodeURIComponent(params[k]));
    }
  });
  const qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri += uri.includes("?") ? "&" : "?";
  return uri + qs;
}

// node_modules/ol/source/WMTS.js
var WMTS = class extends TileImage_default {
  constructor(options) {
    const requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : "KVP";
    const tileGrid = options.tileGrid;
    let urls = options.urls;
    if (urls === void 0 && options.url !== void 0) {
      urls = expandUrl(options.url);
    }
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.version_ = options.version !== void 0 ? options.version : "1.0.0";
    this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
    this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
    this.layer_ = options.layer;
    this.matrixSet_ = options.matrixSet;
    this.style_ = options.style;
    this.requestEncoding_ = requestEncoding;
    this.setKey(this.getKeyForDimensions_());
    if (urls && urls.length > 0) {
      this.tileUrlFunction = createFromTileUrlFunctions(
        urls.map(this.createFromWMTSTemplate.bind(this))
      );
    }
  }
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    this.setTileUrlFunction(
      createFromTileUrlFunctions(
        urls.map(this.createFromWMTSTemplate.bind(this))
      ),
      key
    );
  }
  getDimensions() {
    return this.dimensions_;
  }
  getFormat() {
    return this.format_;
  }
  getLayer() {
    return this.layer_;
  }
  getMatrixSet() {
    return this.matrixSet_;
  }
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  getStyle() {
    return this.style_;
  }
  getVersion() {
    return this.version_;
  }
  getKeyForDimensions_() {
    const res = this.urls ? this.urls.slice(0) : [];
    for (const key in this.dimensions_) {
      res.push(key + "-" + this.dimensions_[key]);
    }
    return res.join("/");
  }
  updateDimensions(dimensions) {
    Object.assign(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  }
  createFromWMTSTemplate(template) {
    const requestEncoding = this.requestEncoding_;
    const context = {
      "layer": this.layer_,
      "style": this.style_,
      "tilematrixset": this.matrixSet_
    };
    if (requestEncoding == "KVP") {
      Object.assign(context, {
        "Service": "WMTS",
        "Request": "GetTile",
        "Version": this.version_,
        "Format": this.format_
      });
    }
    template = requestEncoding == "KVP" ? appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function(m, p) {
      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
    });
    const tileGrid = this.tileGrid;
    const dimensions = this.dimensions_;
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const localContext = {
        "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
        "TileCol": tileCoord[1],
        "TileRow": tileCoord[2]
      };
      Object.assign(localContext, dimensions);
      let url = template;
      if (requestEncoding == "KVP") {
        url = appendParams(url, localContext);
      } else {
        url = url.replace(/\{(\w+?)\}/g, function(m, p) {
          return localContext[p];
        });
      }
      return url;
    };
  }
};
var WMTS_default2 = WMTS;

// node_modules/ol/source/wms.js
var DEFAULT_VERSION = "1.3.0";

// node_modules/ol/source/TileWMS.js
var TileWMS = class extends TileImage_default {
  constructor(options) {
    options = options ? options : {};
    const params = Object.assign({}, options.params);
    const transparent = "TRANSPARENT" in params ? params["TRANSPARENT"] : true;
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
    this.params_ = params;
    this.v13_ = true;
    this.serverType_ = options.serverType;
    this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    this.tmpExtent_ = createEmpty();
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  }
  getFeatureInfoUrl(coordinate, resolution, projection, params) {
    const projectionObj = get3(projection);
    const sourceProjectionObj = this.getProjection();
    let tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }
    const z = tileGrid.getZForResolution(resolution, this.zDirection);
    const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    let tileResolution = tileGrid.getResolution(tileCoord[0]);
    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    const gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer2(tileSize, gutter, this.tmpSize);
      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = calculateSourceResolution(
        sourceProjectionObj,
        projectionObj,
        coordinate,
        tileResolution
      );
      tileExtent = transformExtent(
        tileExtent,
        projectionObj,
        sourceProjectionObj
      );
      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    Object.assign(baseParams, this.params_, params);
    const x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    const y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? "I" : "X"] = x;
    baseParams[this.v13_ ? "J" : "Y"] = y;
    return this.getRequestUrl_(
      tileCoord,
      tileSize,
      tileExtent,
      1,
      sourceProjectionObj || projectionObj,
      baseParams
    );
  }
  getLegendUrl(resolution, params) {
    if (this.urls[0] === void 0) {
      return void 0;
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params === void 0 || params["LAYER"] === void 0) {
      const layers = this.params_.LAYERS;
      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      const mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      const pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    Object.assign(baseParams, params);
    return appendParams(this.urls[0], baseParams);
  }
  getGutter() {
    return this.gutter_;
  }
  getParams() {
    return this.params_;
  }
  getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    const urls = this.urls;
    if (!urls) {
      return void 0;
    }
    params["WIDTH"] = tileSize[0];
    params["HEIGHT"] = tileSize[1];
    params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case "geoserver":
          const dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params) {
            params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case "mapserver":
          params["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case "carmentaserver":
        case "qgis":
          params["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 52);
          break;
      }
    }
    const axisOrientation = projection.getAxisOrientation();
    const bbox = tileExtent;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      let tmp;
      tmp = tileExtent[0];
      bbox[0] = tileExtent[1];
      bbox[1] = tmp;
      tmp = tileExtent[2];
      bbox[2] = tileExtent[3];
      bbox[3] = tmp;
    }
    params["BBOX"] = bbox.join(",");
    let url;
    if (urls.length == 1) {
      url = urls[0];
    } else {
      const index = modulo(hash(tileCoord), urls.length);
      url = urls[index];
    }
    return appendParams(url, params);
  }
  getTilePixelRatio(pixelRatio) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
  }
  getKeyForParams_() {
    let i = 0;
    const res = [];
    for (const key in this.params_) {
      res[i++] = key + "-" + this.params_[key];
    }
    return res.join("/");
  }
  updateParams(params) {
    Object.assign(this.params_, params);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  }
  updateV13_() {
    const version = this.params_["VERSION"] || DEFAULT_VERSION;
    this.v13_ = compareVersions(version, "1.3") >= 0;
  }
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    let tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    const tileResolution = tileGrid.getResolution(tileCoord[0]);
    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    const gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer2(tileSize, gutter, this.tmpSize);
      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (pixelRatio != 1) {
      tileSize = scale3(tileSize, pixelRatio, this.tmpSize);
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    Object.assign(baseParams, this.params_);
    return this.getRequestUrl_(
      tileCoord,
      tileSize,
      tileExtent,
      pixelRatio,
      projection,
      baseParams
    );
  }
};
var TileWMS_default = TileWMS;

// src/constants.js
var Center = [10.61010906, 56.15950977];
var Extent = [12e4, 59e5, 1e6, 65e5];
var Resolutions = [1638.4, 819.2, 409.6, 204.8, 102.4, 51.2, 25.6, 12.8, 6.4, 3.2, 1.6, 0.8, 0.4, 0.2];
var MatrixIds = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13"];
var Size = [256, 256];

// src/utility/IsMobile.js
var Android = function() {
  return navigator.userAgent.match(/Android/i) && navigator.userAgent.match(/Mobile/i);
};
var BlackBerry = function() {
  return navigator.userAgent.match(/BlackBerry/i);
};
var iOS = function() {
  return navigator.userAgent.match(/iPhone|iPod/i);
};
var Opera = function() {
  return navigator.userAgent.match(/Opera Mini/i);
};
var Windows = function() {
  return navigator.userAgent.match(/IEMobile/i);
};
var any = function() {
  return Android() || BlackBerry() || iOS() || Opera() || Windows();
};

// src/CreateLayer.js
var kfText = any() ? "SDFI" : "Styrelsen for Dataforsyning og Infrastruktur";
var kfLink = "https://download.dataforsyningen.dk/content/vilk%C3%A5r-og-betingelser";
var kfAttributionText = '&copy; <a target="_blank" href="' + kfLink + '">' + kfText + "</a>";
var dfLink = "https://datafordeler.dk/vejledning/brugervilkaar/sdfi-geografiske-data/";
var dfAttributionText = '&copy; <a target="_blank" href="' + dfLink + '">' + kfText + "</a>";
var createUrl = function(service, auth) {
  if (auth.source === "kf") {
    const baseUrl = "https://api.dataforsyningen.dk/";
    return baseUrl + service + "?token=" + auth.token;
  } else if (auth.source === "df") {
    const baseUrl = "https://services.datafordeler.dk/";
    return baseUrl + service + "?username=" + auth.username + "&password=" + auth.password;
  }
  console.error('Unknown source: "' + auth.source + '"');
  return null;
};
var createLayer2 = function(opt) {
  const name = opt.name || "";
  const type = opt.type || "";
  const title = opt.title || name;
  const color = "white";
  const visible = !!opt.visible;
  const auth = opt.auth;
  const service = opt.service || "";
  const layer = opt.layer || "";
  const style = opt.style || "default";
  const version = opt.version || "1.1.1";
  const matrixSet = opt.matrixSet;
  const format = opt.format || "";
  const tileGrid = opt.tileGrid;
  const attributionText = opt.auth.source === "kf" ? kfAttributionText : opt.auth.source === "df" ? dfAttributionText : opt.attribution;
  let source = null;
  if (type === "WMTS") {
    source = new WMTS_default2({
      attributions: attributionText,
      crossOrigin: "Anonymous",
      url: createUrl(service, auth),
      layer,
      matrixSet,
      format,
      tileGrid,
      style,
      size: Size
    });
  } else if (type === "WMS") {
    source = new TileWMS_default({
      attributions: attributionText,
      crossOrigin: "Anonymous",
      url: createUrl(service, auth),
      params: {
        "LAYERS": layer,
        "VERSION": version,
        "TRANSPARENT": "true",
        "FORMAT": format,
        "STYLES": style
      }
    });
  } else {
    console.error('Unknown service type: "' + type + '"');
    return null;
  }
  return new Tile_default3({
    opacity: 1,
    title,
    name,
    color,
    type: "base",
    visible,
    source,
    preload: Infinity
  });
};

// src/control/markers/CreateMarkerTooltip.js
function markerTooltip(map, custom) {
  const mapDiv = document.getElementById(map.target);
  const popup = document.createElement("div");
  let closer = document.createElement("a");
  const content = document.createElement("div");
  const title = document.createElement("div");
  const description = document.createElement("div");
  title.className = "title";
  description.className = "description";
  popup.className = "ol-popup";
  mapDiv.appendChild(popup);
  if (custom) {
    popup.appendChild(custom);
    closer = custom.getElementsByClassName("closer")[0];
  } else {
    closer.className = "ol-popup-closer";
    content.className = "ol-popup-content";
    popup.appendChild(closer);
    popup.appendChild(content);
    content.appendChild(title);
    content.appendChild(description);
  }
  map.olMap.getOverlays().clear();
  const overlay = new Overlay_default({
    element: popup,
    autoPan: true,
    autoPanAnimation: {
      duration: 250
    }
  });
  map.olMap.addOverlay(overlay);
  if (closer) {
    closer.onclick = function() {
      overlay.setPosition(void 0);
      closer.blur();
      return false;
    };
  }
  map.olMap.on("singleclick", function(evt) {
    const clickedFeature = map.olMap.forEachFeatureAtPixel(
      evt.pixel,
      function(feature) {
        return feature;
      }
    );
    if (!clickedFeature) {
      return;
    }
    const features = clickedFeature.get("features");
    if (features.length > 1) {
      const extent = boundingExtent(features.map((r) => r.getGeometry().getCoordinates()));
      map.olMap.getView().fit(extent, { duration: 1e3, padding: [50, 50, 50, 50] });
    } else {
      const feature = features[0];
      if (custom) {
        custom.childNodes.forEach(function(element) {
          const content2 = feature.get(element.className);
          if (content2) {
            element.innerHTML = content2;
          }
        });
      } else {
        title.innerHTML = feature.get("title") || "";
        description.innerHTML = feature.get("description") || "";
      }
      overlay.setPosition(feature.getGeometry().getCoordinates());
    }
  });
  map.olMap.on("pointermove", function(evt) {
    map.olMap.getTargetElement().style.cursor = map.olMap.hasFeatureAtPixel(evt.pixel) ? "pointer" : "";
  });
}

// src/Map.js
var Map2 = class {
  markers = [];
  icons = {};
  markerLayerGroup;
  markerLayers;
  popup;
  showPopup;
  set markers(markers) {
    this.setMarkers(markers);
  }
  constructor(opt) {
    this.icons = opt.icons || {};
    const background = opt.background || "";
    const zoomSlider = typeof opt.zoomSlider === "undefined" ? true : opt.zoomSlider;
    const scaleLine = typeof opt.scaleLine === "undefined" ? true : opt.scaleLine;
    const layerSwitcher = opt.layerSwitcher || false;
    const myLocation = typeof opt.myLocation === "undefined" ? true : opt.myLocation;
    const view = opt.view;
    const autoCenter = view && view.center === "auto";
    const center = view && typeof view.center !== "string" ? view.center || Center : Center;
    const autoZoom = view && view.zoom === "auto";
    const mouseWheelZoom = typeof opt.mouseWheelZoom === "undefined" ? true : opt.mouseWheelZoom;
    const overrideExtent = opt.extent || false;
    this.zoom = view ? view.zoom || 2 : 2;
    const fullScreen = typeof opt.fullScreen === "undefined" ? true : opt.fullScreen;
    this.popup = opt.popup || null;
    this.showPopup = typeof opt.showPopup === "undefined" ? true : opt.showPopup;
    this._target = opt.target || "map";
    this._source = opt.source || "kf";
    this._token = opt.token || "";
    this._username = opt.username || "";
    this._password = opt.password || "";
    this.autocenter = autoCenter;
    this.autoZoom = autoZoom;
    import_proj42.default.defs("EPSG:25832", "+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs");
    register(import_proj42.default);
    const projection = get3("EPSG:25832");
    projection.setExtent(Extent);
    const kfTileGrid = new WMTS_default({
      extent: Extent,
      resolutions: Resolutions,
      matrixIds: MatrixIds
    });
    const kfTileGrid2 = new WMTS_default({
      extent: Extent,
      resolutions: Resolutions,
      matrixIds: ["L00", "L01", "L02", "L03", "L04", "L05", "L06", "L07", "L08", "L09", "L10", "L11", "L12", "L13"]
    });
    const dfTileGrid = new WMTS_default({
      extent: Extent,
      resolutions: Resolutions,
      matrixIds: ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13"]
    });
    const kfAuth = {
      source: "kf",
      token: this._token
    };
    const dfAuth = {
      source: "df",
      username: this._username,
      password: this._password
    };
    const layers = [];
    if (this._username && this._password) {
      layers.push(createLayer2({
        name: "dtk_skaermkort",
        type: "WMTS",
        title: "Sk\xE6rmkort",
        visible: background === "dtk_skaermkort",
        service: "DKskaermkort/topo_skaermkort_wmts/1.0.0/Wmts",
        layer: "topo_skaermkort",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: dfTileGrid,
        auth: dfAuth
      }));
      layers.push(createLayer2({
        name: "dtk_skaermkort_daempet",
        type: "WMTS",
        title: "Sk\xE6rmkort d\xE6mpet",
        visible: background !== "orto_foraar" && background !== "forvaltning" && background !== "dtk_skaermkort",
        service: "DKskaermkort/topo_skaermkort_daempet/1.0.0/Wmts",
        layer: "topo_skaermkort_daempet",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: dfTileGrid,
        auth: dfAuth
      }));
      layers.push(createLayer2({
        name: "orto_foraar",
        type: "WMTS",
        title: "Ortofoto",
        color: "white",
        visible: background === "orto_foraar",
        service: "GeoDanmarkOrto/orto_foraar_wmts/1.0.0/Wmts",
        layer: "orto_foraar_wmts",
        matrixSet: "KortforsyningTilingDK",
        format: "image/jpeg",
        tileGrid: dfTileGrid,
        auth: dfAuth
      }));
    } else if (this._token) {
      layers.push(createLayer2({
        name: "dtk_skaermkort",
        type: "WMTS",
        title: "Sk\xE6rmkort",
        visible: background === "dtk_skaermkort",
        service: "topo_skaermkort_wmts_DAF",
        layer: "topo_skaermkort",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: kfTileGrid,
        auth: kfAuth
      }));
      layers.push(createLayer2({
        name: "dtk_skaermkort_daempet",
        type: "WMTS",
        title: "Sk\xE6rmkort d\xE6mpet",
        visible: background !== "orto_foraar" && background !== "forvaltning" && background !== "dtk_skaermkort",
        service: "topo_skaermkort_daempet_DAF",
        layer: "topo_skaermkort_daempet",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: kfTileGrid,
        auth: kfAuth
      }));
      layers.push(createLayer2({
        name: "orto_foraar",
        type: "WMTS",
        title: "Ortofoto",
        color: "white",
        visible: background === "orto_foraar",
        service: "orto_foraar_wmts_DAF",
        layer: "orto_foraar_wmts",
        matrixSet: "KortforsyningTilingDK",
        format: "image/jpeg",
        tileGrid: kfTileGrid,
        auth: kfAuth
      }));
    }
    if (this._token) {
      layers.push(createLayer2({
        name: "forvaltning",
        type: "WMS",
        title: "Basiskort",
        visible: background === "forvaltning",
        service: "forvaltning2",
        layer: "basis_kort",
        format: "image/png",
        auth: kfAuth
      }));
      layers.push(createLayer2({
        name: "kommunikation",
        type: "WMS",
        title: "Kommunikation",
        visible: background === "kommunikation",
        service: "kommunikation",
        layer: "Kommunikationskort",
        format: "image/png",
        auth: kfAuth
      }));
      layers.push(createLayer2({
        name: "natur_friluftskort",
        type: "WMTS",
        title: "Natur og Friluftskort",
        visible: background === "natur_friluftskort",
        service: "natur_friluftskort",
        layer: "nfkort",
        matrixSet: "View1",
        format: "image/jpeg",
        tileGrid: kfTileGrid2,
        auth: kfAuth
      }));
    }
    const overlays = [];
    if (opt.overlays) {
      opt.overlays.forEach(function(e) {
        if (e.source === "kf") {
          e.auth = kfAuth;
          e.tileGrid = kfTileGrid;
        } else if (e.source === "df") {
          e.auth = dfAuth;
          e.tileGrid = dfTileGrid;
        }
        overlays.push(createLayer2(e));
      });
    }
    this._map = new Map_default2({
      target: this._target,
      layers: [
        new Group_default({
          "title": "Base maps",
          layers
        }),
        new Group_default({
          "title": "Kort",
          layers: overlays
        }),
        new Group_default({
          "title": "Hidden",
          layers: []
        })
      ],
      controls: defaults({ attribution: false, zoom: zoomSlider }),
      interactions: defaults2({ mouseWheelZoom }),
      view: new View_default({
        center: fromLonLat(center, "EPSG:25832"),
        zoom: this.zoom,
        resolutions: kfTileGrid.getResolutions(),
        projection,
        extent: overrideExtent ? overrideExtent : Extent
      })
    });
    this._map.addControl(new Attribution_default({ collapsible: false }));
    scaleLine && this._map.addControl(new ScaleLine_default());
    zoomSlider && this._map.addControl(new ZoomSlider_default());
    fullScreen && this._map.addControl(new FullScreen_default());
    myLocation && this._map.addControl(new MyLocation({ zoomSlider }));
    this._layerSwitcher = new LayerSwitcher({ visible: layerSwitcher });
    this._map.addControl(this._layerSwitcher);
    this.setMarkers(opt.markers);
    this._map.on("click", function(evt) {
      const focus2 = document.activeElement;
      focus2.blur();
    });
    if (zoomSlider) {
      this.adjustControlsCss();
    }
    this._map.on("change:size", () => {
      this.adjustControlsCss();
    });
  }
  async setMarkers(markers) {
    if (!markers) {
      return;
    }
    this.markerLayers = await CreateMarkers_default(markers, this.icons);
    this._map.removeLayer(this.markerLayerGroup);
    this.markerLayerGroup = new Group_default({ layers: this.markerLayers });
    this._map.addLayer(this.markerLayerGroup);
    this.autoCenter();
    this.showPopup && markerTooltip(this, this.popup);
  }
  addVectorLayer(vector, styles, name) {
    this._map.addLayer(new Vector_default2({
      name,
      visible: false,
      source: vector,
      style: styles
    }));
  }
  getVectorLayer(name) {
    return this._map.getLayers().getArray().find(function(e) {
      return e.get("name") === name;
    });
  }
  autoCenter() {
    if (!this.autocenter || !this.markerLayers[0]) {
      return;
    }
    const extent = createEmpty();
    this.markerLayers.forEach(function(layer) {
      extend2(extent, layer.getSource().getSource().getExtent());
    });
    if (extent[0] === Infinity) {
      return;
    }
    this._map.getView().fit(extent);
    this._map.getView().setZoom(Math.floor(this._map.getView().getZoom()));
    if (!this.autoZoom) {
      this._map.getView().setZoom(this.zoom);
    }
    this._map.updateSize();
  }
  toggleBackground(background) {
    this._layerSwitcher.toggleBackground(background);
  }
  toggleLayer(layer, value) {
    const layers = this._map.getLayers().getArray();
    const vectorLayer = layers.find(function(e) {
      return e.get("name") === layer;
    });
    if (vectorLayer) {
      vectorLayer.setVisible(value);
      return;
    }
    const overlays = layers.find(function(e) {
      return e.get("title") === "Kort";
    });
    overlays.get("layers").getArray().forEach(function(e, idx, a) {
      if (e.get("name") === layer) {
        e.setVisible(value);
      }
    });
  }
  adjustControlsCss() {
    const findElementBelongingToThisMap = (collection) => {
      const array = Array.from(collection);
      return array.find((el) => {
        return !!el.closest("#" + this.target);
      });
    };
    const slider = findElementBelongingToThisMap(document.getElementsByClassName("ol-zoomslider"));
    const button = findElementBelongingToThisMap(document.getElementsByClassName("ol-zoom-out"));
    const myLoc = findElementBelongingToThisMap(document.getElementsByClassName("ol-my-location"));
    const mapHeight = document.getElementById(this.target).offsetHeight;
    if (mapHeight < 300) {
      if (slider) {
        slider.style.display = none;
      }
      if (myLoc) {
        myLoc.style.bottom = "97px";
      }
    } else {
      if (button) {
        const m = Math.floor(mapHeight * 0.25) + 6 + "px";
        button.style.marginTop = m;
      }
    }
  }
  addOnFeatureClickFunction(callback) {
    const map = this._map;
    map.on("singleclick", function(evt) {
      const feature = map.forEachFeatureAtPixel(
        evt.pixel,
        function(feature2) {
          return feature2;
        }
      );
      callback(feature);
    });
  }
  get olMap() {
    return this._map;
  }
  get target() {
    return this._target;
  }
};

// src/Initialize.js
function scrapeMarkers() {
  const markerElements = document.querySelectorAll("span.geomarker");
  const markers = [];
  markerElements.forEach(function(element) {
    const dataset = element.dataset;
    let marker = {};
    for (let key in dataset) {
      if (key === "lat" || key === "lon") {
        marker[key] = Number(dataset[key]);
      } else {
        marker[key] = dataset[key];
      }
    }
    markers.push(marker);
  });
  return markers;
}
function initMaps(options, markers) {
  const mapElements = document.querySelectorAll("div.geomap");
  let maps = [];
  mapElements.forEach(function(element) {
    const d = element.dataset;
    const types = typeof d.type === "undefined" ? [""] : d.type.split(",");
    const filteredMarkers = filterMarkers(markers, types);
    const overlays = typeof d.overlays === "undefined" ? [""] : d.overlays.split(",");
    const filteredOverlays = options.overlays ? options.overlays.filter(function(e) {
      return e.name ? e.name.indexOf(overlays) > -1 : true;
    }) : [];
    const map = generateMap({
      element,
      filtered_overlays: filteredOverlays,
      filtered_markers: filteredMarkers,
      opt: options
    });
    maps.push(map);
  });
  return maps;
}
function filterMarkers(markers, types) {
  return markers.filter(function(marker) {
    return marker.type ? marker.type.indexOf(types) > -1 : true;
  });
}
function generateMap(options) {
  const d = options.element.dataset;
  const center = d.centerLon ? [
    Number(d.centerLon),
    Number(d.centerLat)
  ] : "auto";
  const map = new Map2({
    target: options.element.id,
    token: d.token,
    username: d.username,
    password: d.password,
    background: d.background,
    icons: options.opt.icons,
    overlays: options.filtered_overlays,
    markers: options.filtered_markers,
    popup: options.opt.popup,
    showPopup: d.showPopup !== "false",
    zoomSlider: d.zoomslider === "true",
    mouseWheelZoom: d.mousewheelzoom === "false" ? false : true,
    fullScreen: d.fullscreen === "true",
    myLocation: d.mylocation === "true",
    scaleLine: d.scaleline === "true",
    layerSwitcher: d.layerswitcher === "true",
    extent: d.extent ? JSON.parse(d.extent) : null,
    view: {
      center: d.center === "auto" ? "auto" : center,
      zoom: d.zoom
    }
  });
  return map;
}
var Initialize = class {
  maps = [];
  constructor(options) {
    this.init(options);
  }
  init(options) {
    this.maps = initMaps(options, scrapeMarkers());
  }
  refresh() {
    const markers = scrapeMarkers();
    this.maps.forEach(function(map) {
      const t = map.olMap.getTargetElement().dataset.type;
      const types = typeof t === "undefined" ? [""] : t.split(",");
      const filteredMarkers = filterMarkers(markers, types);
      map.setMarkers(filteredMarkers);
    });
  }
};
var Initialize_default = Initialize;
export {
  Initialize_default as Initialize,
  Map2 as Map
};
/*!

The MIT License (MIT)

Copyright (c) 2022 Styrelsen for Dataforsyning og Infrastruktur

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

 */
//# sourceMappingURL=okapi.js.map
